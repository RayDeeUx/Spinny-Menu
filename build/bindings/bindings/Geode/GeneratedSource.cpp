
#include <stdexcept>
#include <Geode/Bindings.hpp>
#include <Geode/utils/addresser.hpp>
#include <Geode/modify/Traits.hpp>
#include <Geode/loader/Tulip.hpp>

using namespace geode;
using namespace geode::modifier;
using cocos2d::CCDestructor;

std::unordered_map<void*, bool>& CCDestructor::destructorLock() {{
	static auto ret = new std::unordered_map<void*, bool>;
	return *ret;
}}
bool& CCDestructor::globalLock() {{
	static thread_local bool ret = false;
	return ret; 
}}
bool& CCDestructor::lock(void* self) {
	return destructorLock()[self];
}
CCDestructor::~CCDestructor() {{
	destructorLock().erase(this);
}}

auto wrapFunction(uintptr_t address, tulip::hook::WrapperMetadata const& metadata) {
	auto wrapped = geode::hook::createWrapper(reinterpret_cast<void*>(address), metadata);
	if (wrapped.isErr()) {{
		throw std::runtime_error(wrapped.unwrapErr());
	}}
	return wrapped.unwrap();
}

// So apparently Clang considers cdecl to return floats through ST0, whereas 
// MSVC thinks they are returned through XMM0. This has caused a lot of pain 
// and misery for me


auto cocos2d::CCEaseBackOut::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x4ef300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCEaseBackOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseBackOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseBackOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseBackOut::update not implemented");
}

auto cocos2d::CCEaseBackOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseBackOut::reverse not implemented");
}

auto cocos2d::CCEaseBounceOut::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x4eeb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCEaseBounceOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseBounceOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseBounceOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseBounceOut::update not implemented");
}

auto cocos2d::CCEaseBounceOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseBounceOut::reverse not implemented");
}

auto cocos2d::CCEaseInOut::create(cocos2d::CCActionInterval* p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCActionInterval*, float);
	static auto func = wrapFunction(base::get() + 0x4ecd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCEaseInOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseInOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseInOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseInOut::update not implemented");
}

auto cocos2d::CCEaseInOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseInOut::reverse not implemented");
}

auto cocos2d::CCTintTo::create(float p0, unsigned char p1, unsigned char p2, unsigned char p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(float, unsigned char, unsigned char, unsigned char);
	static auto func = wrapFunction(base::get() + 0x399290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto cocos2d::CCTintTo::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCTintTo::copyWithZone not implemented");
}

auto cocos2d::CCTintTo::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCTintTo::update not implemented");
}

auto cocos2d::CCTintTo::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCTintTo::startWithTarget not implemented");
}

auto cocos2d::CCEaseOut::create(cocos2d::CCActionInterval* p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCActionInterval*, float);
	static auto func = wrapFunction(base::get() + 0x4ecb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCEaseSineInOut::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x4ed980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCEaseSineInOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseSineInOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseSineInOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseSineInOut::update not implemented");
}

auto cocos2d::CCEaseSineInOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseSineInOut::reverse not implemented");
}

auto cocos2d::CCEaseElasticOut::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x4ee120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCEaseElasticOut::create(cocos2d::CCActionInterval* p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCActionInterval*, float);
	static auto func = wrapFunction(base::get() + 0x4ee060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCEaseElasticOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCEaseElasticOut::copyWithZone not implemented");
}

auto cocos2d::CCEaseElasticOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCEaseElasticOut::update not implemented");
}

auto cocos2d::CCEaseElasticOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCEaseElasticOut::reverse not implemented");
}

auto cocos2d::CCFileUtils::addSearchPath(char const* p0) -> decltype(addSearchPath(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::addSearchPath not implemented");
}

auto cocos2d::CCFileUtils::addSearchResolutionsOrder(char const* p0) -> decltype(addSearchResolutionsOrder(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::addSearchResolutionsOrder not implemented");
}

auto cocos2d::CCFileUtils::addSuffix(gd::string p0, gd::string p1) -> decltype(addSuffix(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, gd::string>::func(&cocos2d::CCFileUtils::addSuffix), this);
	using FunctionType = decltype(addSuffix(p0, p1))(*)(cocos2d::CCFileUtils*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x419590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCFileUtils::createCCArrayWithContentsOfFile(gd::string const& p0) -> decltype(createCCArrayWithContentsOfFile(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::createCCArrayWithContentsOfFile not implemented");
}

auto cocos2d::CCFileUtils::createCCDictionaryWithContentsOfFile(gd::string const& p0) -> decltype(createCCDictionaryWithContentsOfFile(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::createCCDictionaryWithContentsOfFile not implemented");
}

auto cocos2d::CCFileUtils::fullPathForFilename(char const* p0, bool p1) -> decltype(fullPathForFilename(p0, p1)) {
	throw std::runtime_error("cocos2d::CCFileUtils::fullPathForFilename not implemented");
}

auto cocos2d::CCFileUtils::fullPathFromRelativeFile(char const* p0, char const* p1) -> decltype(fullPathFromRelativeFile(p0, p1)) {
	throw std::runtime_error("cocos2d::CCFileUtils::fullPathFromRelativeFile not implemented");
}

auto cocos2d::CCFileUtils::getFileData(char const* p0, char const* p1, unsigned long* p2) -> decltype(getFileData(p0, p1, p2)) {
	throw std::runtime_error("cocos2d::CCFileUtils::getFileData not implemented");
}

auto cocos2d::CCFileUtils::getFileDataFromZip(char const* p0, char const* p1, unsigned long* p2) -> decltype(getFileDataFromZip(p0, p1, p2)) {
	throw std::runtime_error("cocos2d::CCFileUtils::getFileDataFromZip not implemented");
}

auto cocos2d::CCFileUtils::getFullPathForDirectoryAndFilename(gd::string const& p0, gd::string const& p1) -> decltype(getFullPathForDirectoryAndFilename(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, gd::string const&>::func(&cocos2d::CCFileUtils::getFullPathForDirectoryAndFilename), this);
	using FunctionType = decltype(getFullPathForDirectoryAndFilename(p0, p1))(*)(cocos2d::CCFileUtils*, gd::string const&, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x41bb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCFileUtils::getNewFilename(char const* p0) -> decltype(getNewFilename(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCFileUtils::getNewFilename), this);
	using FunctionType = decltype(getNewFilename(p0))(*)(cocos2d::CCFileUtils*, char const*);
	static auto func = wrapFunction(base::get() + 0x419400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCFileUtils::getPathForFilename(gd::string const& p0, gd::string const& p1, gd::string const& p2) -> decltype(getPathForFilename(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&, gd::string const&, gd::string const&>::func(&cocos2d::CCFileUtils::getPathForFilename), this);
	using FunctionType = decltype(getPathForFilename(p0, p1, p2))(*)(cocos2d::CCFileUtils*, gd::string const&, gd::string const&, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x4197b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCFileUtils::getSearchPaths() -> decltype(getSearchPaths()) {
	throw std::runtime_error("cocos2d::CCFileUtils::getSearchPaths not implemented");
}

auto cocos2d::CCFileUtils::getSearchResolutionsOrder() -> decltype(getSearchResolutionsOrder()) {
	throw std::runtime_error("cocos2d::CCFileUtils::getSearchResolutionsOrder not implemented");
}

auto cocos2d::CCFileUtils::getWritablePath2() -> decltype(getWritablePath2()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCFileUtils::getWritablePath2), this);
	using FunctionType = decltype(getWritablePath2())(*)(cocos2d::CCFileUtils*);
	static auto func = wrapFunction(base::get() + 0x41bd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCFileUtils::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCFileUtils::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCFileUtils*);
	static auto func = wrapFunction(base::get() + 0x4190a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCFileUtils::isAbsolutePath(gd::string const& p0) -> decltype(isAbsolutePath(p0)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string const&>::func(&cocos2d::CCFileUtils::isAbsolutePath), this);
	using FunctionType = decltype(isAbsolutePath(p0))(*)(cocos2d::CCFileUtils*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x41bc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCFileUtils::isPopupNotify() -> decltype(isPopupNotify()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCFileUtils::isPopupNotify), this);
	using FunctionType = decltype(isPopupNotify())(*)(cocos2d::CCFileUtils*);
	static auto func = wrapFunction(base::get() + 0x41bcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCFileUtils::loadFilenameLookupDictionaryFromFile(char const* p0) -> decltype(loadFilenameLookupDictionaryFromFile(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::loadFilenameLookupDictionaryFromFile not implemented");
}

auto cocos2d::CCFileUtils::purgeCachedEntries() -> decltype(purgeCachedEntries()) {
	throw std::runtime_error("cocos2d::CCFileUtils::purgeCachedEntries not implemented");
}

auto cocos2d::CCFileUtils::removeFullPath(char const* p0) -> decltype(removeFullPath(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::removeFullPath not implemented");
}

auto cocos2d::CCFileUtils::removeSearchPath(char const* p0) -> decltype(removeSearchPath(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::removeSearchPath not implemented");
}

auto cocos2d::CCFileUtils::setFilenameLookupDictionary(cocos2d::CCDictionary* p0) -> decltype(setFilenameLookupDictionary(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::setFilenameLookupDictionary not implemented");
}

auto cocos2d::CCFileUtils::setPopupNotify(bool p0) -> decltype(setPopupNotify(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCFileUtils::setPopupNotify), this);
	using FunctionType = decltype(setPopupNotify(p0))(*)(cocos2d::CCFileUtils*, bool);
	static auto func = wrapFunction(base::get() + 0x41bcb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCFileUtils::setSearchPaths(gd::vector<gd::string> const& p0) -> decltype(setSearchPaths(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::setSearchPaths not implemented");
}

auto cocos2d::CCFileUtils::setSearchResolutionsOrder(gd::vector<gd::string> const& p0) -> decltype(setSearchResolutionsOrder(p0)) {
	throw std::runtime_error("cocos2d::CCFileUtils::setSearchResolutionsOrder not implemented");
}

auto cocos2d::CCFileUtils::sharedFileUtils() -> decltype(sharedFileUtils()) {
	using FunctionType = decltype(sharedFileUtils())(*)();
	static auto func = wrapFunction(base::get() + 0x5d0020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCFileUtils::shouldUseHD() -> decltype(shouldUseHD()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCFileUtils::shouldUseHD), this);
	using FunctionType = decltype(shouldUseHD())(*)(cocos2d::CCFileUtils*);
	static auto func = wrapFunction(base::get() + 0x419560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCFileUtils::writeToFile(cocos2d::CCDictionary* p0, gd::string const& p1) -> decltype(writeToFile(p0, p1)) {
	throw std::runtime_error("cocos2d::CCFileUtils::writeToFile not implemented");
}

auto cocos2d::CCClippingNode::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x6e27c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCClippingNode::setAlphaThreshold(float p0) -> decltype(setAlphaThreshold(p0)) {
	using FunctionType = decltype(setAlphaThreshold(p0))(*)(cocos2d::CCClippingNode*, float);
	static auto func = wrapFunction(base::get() + 0x6e2ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCClippingNode::setInverted(bool p0) -> decltype(setInverted(p0)) {
	using FunctionType = decltype(setInverted(p0))(*)(cocos2d::CCClippingNode*, bool);
	static auto func = wrapFunction(base::get() + 0x6e2ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCClippingNode::setStencil(cocos2d::CCNode* p0) -> decltype(setStencil(p0)) {
	using FunctionType = decltype(setStencil(p0))(*)(cocos2d::CCClippingNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x6e2e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCClippingNode::init() -> decltype(init()) {
	throw std::runtime_error("cocos2d::CCClippingNode::init not implemented");
}

auto cocos2d::CCClippingNode::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x6e2990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x6e29c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x6e2a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::onExitTransitionDidStart() -> decltype(onExitTransitionDidStart()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::onExitTransitionDidStart), this);
	using FunctionType = decltype(onExitTransitionDidStart())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x6e29f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCClippingNode::visit), this);
	using FunctionType = decltype(visit())(*)(cocos2d::CCClippingNode*);
	static auto func = wrapFunction(base::get() + 0x6e2a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCClippingNode::init(cocos2d::CCNode* p0) -> decltype(init(p0)) {
	throw std::runtime_error("cocos2d::CCClippingNode::init not implemented");
}

auto cocos2d::CCCallFunc::create(cocos2d::CCObject* p0, cocos2d::SEL_CallFunc p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCObject*, cocos2d::SEL_CallFunc);
	static auto func = wrapFunction(base::get() + 0x76e860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCCallFunc::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCCallFunc::copyWithZone not implemented");
}

auto cocos2d::CCCallFunc::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCCallFunc::update not implemented");
}

auto cocos2d::CCCallFunc::initWithTarget(cocos2d::CCObject* p0) -> decltype(initWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCCallFunc::initWithTarget not implemented");
}

auto cocos2d::CCCallFunc::execute() -> decltype(execute()) {
	throw std::runtime_error("cocos2d::CCCallFunc::execute not implemented");
}

auto cocos2d::CCFadeIn::create(float p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(float);
	static auto func = wrapFunction(base::get() + 0x398ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCFadeIn::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCFadeIn::copyWithZone not implemented");
}

auto cocos2d::CCFadeIn::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCFadeIn::update not implemented");
}

auto cocos2d::CCFadeIn::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCFadeIn::reverse not implemented");
}

auto cocos2d::CCFadeOut::create(float p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(float);
	static auto func = wrapFunction(base::get() + 0x398d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCFadeOut::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCFadeOut::copyWithZone not implemented");
}

auto cocos2d::CCFadeOut::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCFadeOut::update not implemented");
}

auto cocos2d::CCFadeOut::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCFadeOut::reverse not implemented");
}

auto cocos2d::CCFadeTo::create(float p0, unsigned char p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, unsigned char);
	static auto func = wrapFunction(base::get() + 0x398fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCFadeTo::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCFadeTo::copyWithZone not implemented");
}

auto cocos2d::CCFadeTo::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCFadeTo::update not implemented");
}

auto cocos2d::CCFadeTo::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCFadeTo::startWithTarget not implemented");
}

auto cocos2d::CCNode::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x250d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

cocos2d::CCNode::CCNode() {
	using FunctionType = void(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2501f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCNode::~CCNode() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCNode(geode::CutoffConstructor, sizeof(cocos2d::CCNode));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCNode::getActionByTag(int p0) -> decltype(getActionByTag(p0)) {
	using FunctionType = decltype(getActionByTag(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x252000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::boundingBox() -> decltype(boundingBox()) {
	using FunctionType = decltype(boundingBox())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::convertToNodeSpace(cocos2d::CCPoint const& p0) -> decltype(convertToNodeSpace(p0)) {
	using FunctionType = decltype(convertToNodeSpace(p0))(*)(cocos2d::CCNode*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x252c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::convertToWorldSpace(cocos2d::CCPoint const& p0) -> decltype(convertToWorldSpace(p0)) {
	using FunctionType = decltype(convertToWorldSpace(p0))(*)(cocos2d::CCNode*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x252cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::convertTouchToNodeSpace(cocos2d::CCTouch* p0) -> decltype(convertTouchToNodeSpace(p0)) {
	using FunctionType = decltype(convertTouchToNodeSpace(p0))(*)(cocos2d::CCNode*, cocos2d::CCTouch*);
	static auto func = wrapFunction(base::get() + 0x252e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::numberOfRunningActions() -> decltype(numberOfRunningActions()) {
	using FunctionType = decltype(numberOfRunningActions())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::pauseSchedulerAndActions() -> decltype(pauseSchedulerAndActions()) {
	using FunctionType = decltype(pauseSchedulerAndActions())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::resumeSchedulerAndActions() -> decltype(resumeSchedulerAndActions()) {
	using FunctionType = decltype(resumeSchedulerAndActions())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::runAction(cocos2d::CCAction* p0) -> decltype(runAction(p0)) {
	using FunctionType = decltype(runAction(p0))(*)(cocos2d::CCNode*, cocos2d::CCAction*);
	static auto func = wrapFunction(base::get() + 0x251f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::schedule(cocos2d::SEL_SCHEDULE p0) -> decltype(schedule(p0)) {
	using FunctionType = decltype(schedule(p0))(*)(cocos2d::CCNode*, cocos2d::SEL_SCHEDULE);
	static auto func = wrapFunction(base::get() + 0x2521c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::schedule(cocos2d::SEL_SCHEDULE p0, float p1) -> decltype(schedule(p0, p1)) {
	using FunctionType = decltype(schedule(p0, p1))(*)(cocos2d::CCNode*, cocos2d::SEL_SCHEDULE, float);
	static auto func = wrapFunction(base::get() + 0x252220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCNode::schedule(cocos2d::SEL_SCHEDULE p0, float p1, unsigned int p2, float p3) -> decltype(schedule(p0, p1, p2, p3)) {
	using FunctionType = decltype(schedule(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::SEL_SCHEDULE, float, unsigned int, float);
	static auto func = wrapFunction(base::get() + 0x2521f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto cocos2d::CCNode::scheduleOnce(cocos2d::SEL_SCHEDULE p0, float p1) -> decltype(scheduleOnce(p0, p1)) {
	using FunctionType = decltype(scheduleOnce(p0, p1))(*)(cocos2d::CCNode*, cocos2d::SEL_SCHEDULE, float);
	static auto func = wrapFunction(base::get() + 0x252250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCNode::scheduleUpdate() -> decltype(scheduleUpdate()) {
	using FunctionType = decltype(scheduleUpdate())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2520a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::scheduleUpdateWithPriority(int p0) -> decltype(scheduleUpdateWithPriority(p0)) {
	using FunctionType = decltype(scheduleUpdateWithPriority(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x2520d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::scheduleUpdateWithPriorityLua(int p0, int p1) -> decltype(scheduleUpdateWithPriorityLua(p0, p1)) {
	using FunctionType = decltype(scheduleUpdateWithPriorityLua(p0, p1))(*)(cocos2d::CCNode*, int, int);
	static auto func = wrapFunction(base::get() + 0x252100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCNode::stopAction(cocos2d::CCAction* p0) -> decltype(stopAction(p0)) {
	using FunctionType = decltype(stopAction(p0))(*)(cocos2d::CCNode*, cocos2d::CCAction*);
	static auto func = wrapFunction(base::get() + 0x251fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::stopActionByTag(int p0) -> decltype(stopActionByTag(p0)) {
	using FunctionType = decltype(stopActionByTag(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x251fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::stopAllActions() -> decltype(stopAllActions()) {
	using FunctionType = decltype(stopAllActions())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::unschedule(cocos2d::SEL_SCHEDULE p0) -> decltype(unschedule(p0)) {
	using FunctionType = decltype(unschedule(p0))(*)(cocos2d::CCNode*, cocos2d::SEL_SCHEDULE);
	static auto func = wrapFunction(base::get() + 0x252280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCNode::unscheduleAllSelectors() -> decltype(unscheduleAllSelectors()) {
	using FunctionType = decltype(unscheduleAllSelectors())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::unscheduleUpdate() -> decltype(unscheduleUpdate()) {
	using FunctionType = decltype(unscheduleUpdate())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCNode::getChildrenCount() const  -> decltype(getChildrenCount()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getChildrenCount), this);
	using FunctionType = decltype(getChildrenCount())(*)(cocos2d::CCNode const *);
	static auto func = wrapFunction(base::get() + 0x250900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::getContentSize() const  -> decltype(getContentSize()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getContentSize), this);
	using FunctionType = decltype(getContentSize())(*)(cocos2d::CCNode const *);
	static auto func = wrapFunction(base::get() + 0x250a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::update), this);
	using FunctionType = decltype(update(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x2522a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setZOrder(int p0) -> decltype(setZOrder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::setZOrder), this);
	using FunctionType = decltype(setZOrder(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x2505c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::_setZOrder(int p0) -> decltype(_setZOrder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::_setZOrder), this);
	using FunctionType = decltype(_setZOrder(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x2505b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getZOrder() -> decltype(getZOrder()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getZOrder), this);
	using FunctionType = decltype(getZOrder())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2505a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setVertexZ(float p0) -> decltype(setVertexZ(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setVertexZ), this);
	using FunctionType = decltype(setVertexZ(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x250610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getVertexZ() -> decltype(getVertexZ()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getVertexZ), this);
	using FunctionType = decltype(getVertexZ())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x250730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getScaleX() -> decltype(getScaleX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScaleX), this);
	using FunctionType = decltype(getScaleX())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x250760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getScaleY() -> decltype(getScaleY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScaleY), this);
	using FunctionType = decltype(getScaleY())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x2506e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getScale() -> decltype(getScale()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScale), this);
	using FunctionType = decltype(getScale())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2506d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScale(float p0, float p1) -> decltype(setScale(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&cocos2d::CCNode::setScale), this);
	using FunctionType = decltype(setScale(p0, p1))(*)(cocos2d::CCNode*, float, float);
	static auto func = wrapFunction(base::get() + 0x250700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCNode::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(cocos2d::CCNode*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x250790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getPosition() -> decltype(getPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getPosition), this);
	using FunctionType = decltype(getPosition())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setPosition(float p0, float p1) -> decltype(setPosition(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&cocos2d::CCNode::setPosition), this);
	using FunctionType = decltype(setPosition(p0, p1))(*)(cocos2d::CCNode*, float, float);
	static auto func = wrapFunction(base::get() + 0x2507d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::getPosition(float* p0, float* p1) -> decltype(getPosition(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float*, float*>::func(&cocos2d::CCNode::getPosition), this);
	using FunctionType = decltype(getPosition(p0, p1))(*)(cocos2d::CCNode*, float*, float*);
	static auto func = wrapFunction(base::get() + 0x2507b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::setPositionX(float p0) -> decltype(setPositionX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setPositionX), this);
	using FunctionType = decltype(setPositionX(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x250830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getPositionX() -> decltype(getPositionX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getPositionX), this);
	using FunctionType = decltype(getPositionX())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setPositionY(float p0) -> decltype(setPositionY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setPositionY), this);
	using FunctionType = decltype(setPositionY(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x250870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getPositionY() -> decltype(getPositionY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getPositionY), this);
	using FunctionType = decltype(getPositionY())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setSkewX(float p0) -> decltype(setSkewX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setSkewX), this);
	using FunctionType = decltype(setSkewX(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x250550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getSkewX() -> decltype(getSkewX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getSkewX), this);
	using FunctionType = decltype(getSkewX())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setSkewY(float p0) -> decltype(setSkewY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setSkewY), this);
	using FunctionType = decltype(setSkewY(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x250580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getSkewY() -> decltype(getSkewY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getSkewY), this);
	using FunctionType = decltype(getSkewY())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setAnchorPoint(cocos2d::CCPoint const& p0) -> decltype(setAnchorPoint(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCNode::setAnchorPoint), this);
	using FunctionType = decltype(setAnchorPoint(p0))(*)(cocos2d::CCNode*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x250a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getAnchorPoint() -> decltype(getAnchorPoint()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getAnchorPoint), this);
	using FunctionType = decltype(getAnchorPoint())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2509f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::getAnchorPointInPoints() -> decltype(getAnchorPointInPoints()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getAnchorPointInPoints), this);
	using FunctionType = decltype(getAnchorPointInPoints())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2509e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setContentSize(cocos2d::CCSize const& p0) -> decltype(setContentSize(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSize const&>::func(&cocos2d::CCNode::setContentSize), this);
	using FunctionType = decltype(setContentSize(p0))(*)(cocos2d::CCNode*, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x250ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getScaledContentSize() -> decltype(getScaledContentSize()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScaledContentSize), this);
	using FunctionType = decltype(getScaledContentSize())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNode::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x2509d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::isVisible() -> decltype(isVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::isVisible), this);
	using FunctionType = decltype(isVisible())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2509c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x250630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getRotation() -> decltype(getRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getRotation), this);
	using FunctionType = decltype(getRotation())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x250680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getRotationX() -> decltype(getRotationX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getRotationX), this);
	using FunctionType = decltype(getRotationX())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCNode::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(cocos2d::CCNode*, float);
	static auto func = wrapFunction(base::get() + 0x2506b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getRotationY() -> decltype(getRotationY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getRotationY), this);
	using FunctionType = decltype(getRotationY())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2506a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setOrderOfArrival(unsigned int p0) -> decltype(setOrderOfArrival(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned int>::func(&cocos2d::CCNode::setOrderOfArrival), this);
	using FunctionType = decltype(setOrderOfArrival(p0))(*)(cocos2d::CCNode*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x250be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getOrderOfArrival() -> decltype(getOrderOfArrival()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getOrderOfArrival), this);
	using FunctionType = decltype(getOrderOfArrival())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setGLServerState(cocos2d::ccGLServerState p0) -> decltype(setGLServerState(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccGLServerState>::func(&cocos2d::CCNode::setGLServerState), this);
	using FunctionType = decltype(setGLServerState(p0))(*)(cocos2d::CCNode*, cocos2d::ccGLServerState);
	static auto func = wrapFunction(base::get() + 0x250c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getGLServerState() -> decltype(getGLServerState()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getGLServerState), this);
	using FunctionType = decltype(getGLServerState())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::ignoreAnchorPointForPosition(bool p0) -> decltype(ignoreAnchorPointForPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNode::ignoreAnchorPointForPosition), this);
	using FunctionType = decltype(ignoreAnchorPointForPosition(p0))(*)(cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x250b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::isIgnoreAnchorPointForPosition() -> decltype(isIgnoreAnchorPointForPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::isIgnoreAnchorPointForPosition), this);
	using FunctionType = decltype(isIgnoreAnchorPointForPosition())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::addChild(cocos2d::CCNode* p0) -> decltype(addChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCNode::addChild), this);
	using FunctionType = decltype(addChild(p0))(*)(cocos2d::CCNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::addChild(cocos2d::CCNode* p0, int p1) -> decltype(addChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCNode::addChild), this);
	using FunctionType = decltype(addChild(p0, p1))(*)(cocos2d::CCNode*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x251050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::addChild(cocos2d::CCNode* p0, int p1, int p2) -> decltype(addChild(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int, int>::func(&cocos2d::CCNode::addChild), this);
	using FunctionType = decltype(addChild(p0, p1, p2))(*)(cocos2d::CCNode*, cocos2d::CCNode*, int, int);
	static auto func = wrapFunction(base::get() + 0x250f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCNode::getChildByTag(int p0) -> decltype(getChildByTag(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::getChildByTag), this);
	using FunctionType = decltype(getChildByTag(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x250ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getChildren() -> decltype(getChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getChildren), this);
	using FunctionType = decltype(getChildren())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2508b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setParent(cocos2d::CCNode* p0) -> decltype(setParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCNode::setParent), this);
	using FunctionType = decltype(setParent(p0))(*)(cocos2d::CCNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getParent() -> decltype(getParent()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getParent), this);
	using FunctionType = decltype(getParent())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::removeFromParent() -> decltype(removeFromParent()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::removeFromParent), this);
	using FunctionType = decltype(removeFromParent())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::removeFromParentAndCleanup(bool p0) -> decltype(removeFromParentAndCleanup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNode::removeFromParentAndCleanup), this);
	using FunctionType = decltype(removeFromParentAndCleanup(p0))(*)(cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x2510b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeMeAndCleanup() -> decltype(removeMeAndCleanup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::removeMeAndCleanup), this);
	using FunctionType = decltype(removeMeAndCleanup())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2510e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::removeChild(cocos2d::CCNode* p0) -> decltype(removeChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCNode::removeChild), this);
	using FunctionType = decltype(removeChild(p0))(*)(cocos2d::CCNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeChild(cocos2d::CCNode* p0, bool p1) -> decltype(removeChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, bool>::func(&cocos2d::CCNode::removeChild), this);
	using FunctionType = decltype(removeChild(p0, p1))(*)(cocos2d::CCNode*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x251120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::removeChildByTag(int p0) -> decltype(removeChildByTag(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::removeChildByTag), this);
	using FunctionType = decltype(removeChildByTag(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x251270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeChildByTag(int p0, bool p1) -> decltype(removeChildByTag(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&cocos2d::CCNode::removeChildByTag), this);
	using FunctionType = decltype(removeChildByTag(p0, p1))(*)(cocos2d::CCNode*, int, bool);
	static auto func = wrapFunction(base::get() + 0x251290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::removeAllChildren() -> decltype(removeAllChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::removeAllChildren), this);
	using FunctionType = decltype(removeAllChildren())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x2512d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::removeAllChildrenWithCleanup(bool p0) -> decltype(removeAllChildrenWithCleanup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNode::removeAllChildrenWithCleanup), this);
	using FunctionType = decltype(removeAllChildrenWithCleanup(p0))(*)(cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x2512f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::reorderChild(cocos2d::CCNode* p0, int p1) -> decltype(reorderChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCNode::reorderChild), this);
	using FunctionType = decltype(reorderChild(p0, p1))(*)(cocos2d::CCNode*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x251410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::sortAllChildren() -> decltype(sortAllChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::sortAllChildren), this);
	using FunctionType = decltype(sortAllChildren())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::getGrid() -> decltype(getGrid()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getGrid), this);
	using FunctionType = decltype(getGrid())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setGrid(cocos2d::CCGridBase* p0) -> decltype(setGrid(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCGridBase*>::func(&cocos2d::CCNode::setGrid), this);
	using FunctionType = decltype(setGrid(p0))(*)(cocos2d::CCNode*, cocos2d::CCGridBase*);
	static auto func = wrapFunction(base::get() + 0x250980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getUserData() -> decltype(getUserData()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getUserData), this);
	using FunctionType = decltype(getUserData())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setUserData(void* p0) -> decltype(setUserData(p0)) {
	auto self = addresser::thunkAdjust(Resolve<void*>::func(&cocos2d::CCNode::setUserData), this);
	using FunctionType = decltype(setUserData(p0))(*)(cocos2d::CCNode*, void*);
	static auto func = wrapFunction(base::get() + 0x250bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getUserObject() -> decltype(getUserObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getUserObject), this);
	using FunctionType = decltype(getUserObject())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setUserObject(cocos2d::CCObject* p0) -> decltype(setUserObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&cocos2d::CCNode::setUserObject), this);
	using FunctionType = decltype(setUserObject(p0))(*)(cocos2d::CCNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x250c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getShaderProgram() -> decltype(getShaderProgram()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getShaderProgram), this);
	using FunctionType = decltype(getShaderProgram())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setShaderProgram(cocos2d::CCGLProgram* p0) -> decltype(setShaderProgram(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCGLProgram*>::func(&cocos2d::CCNode::setShaderProgram), this);
	using FunctionType = decltype(setShaderProgram(p0))(*)(cocos2d::CCNode*, cocos2d::CCGLProgram*);
	static auto func = wrapFunction(base::get() + 0x250c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getCamera() -> decltype(getCamera()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getCamera), this);
	using FunctionType = decltype(getCamera())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::isRunning() -> decltype(isRunning()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::isRunning), this);
	using FunctionType = decltype(isRunning())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::registerScriptHandler(int p0) -> decltype(registerScriptHandler(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCNode::registerScriptHandler), this);
	using FunctionType = decltype(registerScriptHandler(p0))(*)(cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x251ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::unregisterScriptHandler() -> decltype(unregisterScriptHandler()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::unregisterScriptHandler), this);
	using FunctionType = decltype(unregisterScriptHandler())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::onExitTransitionDidStart() -> decltype(onExitTransitionDidStart()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::onExitTransitionDidStart), this);
	using FunctionType = decltype(onExitTransitionDidStart())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::cleanup() -> decltype(cleanup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::cleanup), this);
	using FunctionType = decltype(cleanup())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x250d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::visit), this);
	using FunctionType = decltype(visit())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setActionManager(cocos2d::CCActionManager* p0) -> decltype(setActionManager(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCActionManager*>::func(&cocos2d::CCNode::setActionManager), this);
	using FunctionType = decltype(setActionManager(p0))(*)(cocos2d::CCNode*, cocos2d::CCActionManager*);
	static auto func = wrapFunction(base::get() + 0x251f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getActionManager() -> decltype(getActionManager()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getActionManager), this);
	using FunctionType = decltype(getActionManager())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x251f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::setScheduler(cocos2d::CCScheduler* p0) -> decltype(setScheduler(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCScheduler*>::func(&cocos2d::CCNode::setScheduler), this);
	using FunctionType = decltype(setScheduler(p0))(*)(cocos2d::CCNode*, cocos2d::CCScheduler*);
	static auto func = wrapFunction(base::get() + 0x252040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::getScheduler() -> decltype(getScheduler()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::getScheduler), this);
	using FunctionType = decltype(getScheduler())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::updateTransform() -> decltype(updateTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::updateTransform), this);
	using FunctionType = decltype(updateTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::nodeToParentTransform() -> decltype(nodeToParentTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::nodeToParentTransform), this);
	using FunctionType = decltype(nodeToParentTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::nodeToParentTransformFast() -> decltype(nodeToParentTransformFast()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::nodeToParentTransformFast), this);
	using FunctionType = decltype(nodeToParentTransformFast())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::parentToNodeTransform() -> decltype(parentToNodeTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::parentToNodeTransform), this);
	using FunctionType = decltype(parentToNodeTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::nodeToWorldTransform() -> decltype(nodeToWorldTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::nodeToWorldTransform), this);
	using FunctionType = decltype(nodeToWorldTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::nodeToWorldTransformFast() -> decltype(nodeToWorldTransformFast()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::nodeToWorldTransformFast), this);
	using FunctionType = decltype(nodeToWorldTransformFast())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::worldToNodeTransform() -> decltype(worldToNodeTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::worldToNodeTransform), this);
	using FunctionType = decltype(worldToNodeTransform())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::addComponent(cocos2d::CCComponent* p0) -> decltype(addComponent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCComponent*>::func(&cocos2d::CCNode::addComponent), this);
	using FunctionType = decltype(addComponent(p0))(*)(cocos2d::CCNode*, cocos2d::CCComponent*);
	static auto func = wrapFunction(base::get() + 0x252f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeComponent(char const* p0) -> decltype(removeComponent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCNode::removeComponent), this);
	using FunctionType = decltype(removeComponent(p0))(*)(cocos2d::CCNode*, char const*);
	static auto func = wrapFunction(base::get() + 0x252f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeComponent(cocos2d::CCComponent* p0) -> decltype(removeComponent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCComponent*>::func(&cocos2d::CCNode::removeComponent), this);
	using FunctionType = decltype(removeComponent(p0))(*)(cocos2d::CCNode*, cocos2d::CCComponent*);
	static auto func = wrapFunction(base::get() + 0x252fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNode::removeAllComponents() -> decltype(removeAllComponents()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNode::removeAllComponents), this);
	using FunctionType = decltype(removeAllComponents())(*)(cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x252fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNode::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&cocos2d::CCNode::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(cocos2d::CCNode*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x252ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCNode::updateTweenActionInt(float p0, int p1) -> decltype(updateTweenActionInt(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&cocos2d::CCNode::updateTweenActionInt), this);
	using FunctionType = decltype(updateTweenActionInt(p0, p1))(*)(cocos2d::CCNode*, float, int);
	static auto func = wrapFunction(base::get() + 0x252ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCGLProgram::setUniformsForBuiltins() -> decltype(setUniformsForBuiltins()) {
	using FunctionType = decltype(setUniformsForBuiltins())(*)(cocos2d::CCGLProgram*);
	static auto func = wrapFunction(base::get() + 0x40ad20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCGLProgram::use() -> decltype(use()) {
	using FunctionType = decltype(use())(*)(cocos2d::CCGLProgram*);
	static auto func = wrapFunction(base::get() + 0x409d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCString::createWithContentsOfFile(char const* p0) -> decltype(createWithContentsOfFile(p0)) {
	using FunctionType = decltype(createWithContentsOfFile(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x76cee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCString::createWithData(unsigned char const* p0, unsigned long p1) -> decltype(createWithData(p0, p1)) {
	using FunctionType = decltype(createWithData(p0, p1))(*)(unsigned char const*, unsigned long);
	static auto func = wrapFunction(base::get() + 0x76cc10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCString::getCString() const  -> decltype(getCString()) {
	using FunctionType = decltype(getCString())(*)(cocos2d::CCString const *);
	static auto func = wrapFunction(base::get() + 0x76c510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCString::boolValue() const  -> decltype(boolValue()) {
	using FunctionType = decltype(boolValue())(*)(cocos2d::CCString const *);
	static auto func = wrapFunction(base::get() + 0x76c980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCString::doubleValue() const  -> decltype(doubleValue()) {
	using FunctionType = decltype(doubleValue())(*)(cocos2d::CCString const *);
	static auto func = wrapFunction(base::get() + 0x76c950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCString::floatValue() const  -> decltype(floatValue()) {
	using FunctionType = decltype(floatValue())(*)(cocos2d::CCString const *);
	static auto func = wrapFunction(base::get() + 0x76c910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCString::intValue() const  -> decltype(intValue()) {
	using FunctionType = decltype(intValue())(*)(cocos2d::CCString const *);
	static auto func = wrapFunction(base::get() + 0x76c890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCString::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCString::copyWithZone not implemented");
}

auto cocos2d::CCString::isEqual(cocos2d::CCObject const* p0) -> decltype(isEqual(p0)) {
	throw std::runtime_error("cocos2d::CCString::isEqual not implemented");
}

auto cocos2d::CCString::acceptVisitor(cocos2d::CCDataVisitor& p0) -> decltype(acceptVisitor(p0)) {
	throw std::runtime_error("cocos2d::CCString::acceptVisitor not implemented");
}

auto cocos2d::CCScene::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x26ec40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCScene::getHighestChildZ() -> decltype(getHighestChildZ()) {
	using FunctionType = decltype(getHighestChildZ())(*)(cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x26ecf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCScene::~CCScene() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x26ebc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCScene(geode::CutoffConstructor, sizeof(cocos2d::CCScene));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCScene::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCScene::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x26ebf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCScheduler::pauseTarget(cocos2d::CCObject* p0) -> decltype(pauseTarget(p0)) {
	using FunctionType = decltype(pauseTarget(p0))(*)(cocos2d::CCScheduler*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x421430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCScheduler::scheduleSelector(cocos2d::SEL_SCHEDULE p0, cocos2d::CCObject* p1, float p2, unsigned int p3, float p4, bool p5) -> decltype(scheduleSelector(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(scheduleSelector(p0, p1, p2, p3, p4, p5))(*)(cocos2d::CCScheduler*, cocos2d::SEL_SCHEDULE, cocos2d::CCObject*, float, unsigned int, float, bool);
	static auto func = wrapFunction(base::get() + 0x41fe50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto cocos2d::CCScheduler::scheduleSelector(cocos2d::SEL_SCHEDULE p0, cocos2d::CCObject* p1, float p2, bool p3) -> decltype(scheduleSelector(p0, p1, p2, p3)) {
	using FunctionType = decltype(scheduleSelector(p0, p1, p2, p3))(*)(cocos2d::CCScheduler*, cocos2d::SEL_SCHEDULE, cocos2d::CCObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x41fe30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto cocos2d::CCScheduler::scheduleUpdateForTarget(cocos2d::CCObject* p0, int p1, bool p2) -> decltype(scheduleUpdateForTarget(p0, p1, p2)) {
	using FunctionType = decltype(scheduleUpdateForTarget(p0, p1, p2))(*)(cocos2d::CCScheduler*, cocos2d::CCObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x420a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCScheduler::unscheduleAllForTarget(cocos2d::CCObject* p0) -> decltype(unscheduleAllForTarget(p0)) {
	using FunctionType = decltype(unscheduleAllForTarget(p0))(*)(cocos2d::CCScheduler*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x420ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCScheduler::unscheduleSelector(cocos2d::SEL_SCHEDULE p0, cocos2d::CCObject* p1) -> decltype(unscheduleSelector(p0, p1)) {
	using FunctionType = decltype(unscheduleSelector(p0, p1))(*)(cocos2d::CCScheduler*, cocos2d::SEL_SCHEDULE, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x41f960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCScheduler::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCScheduler::update), this);
	using FunctionType = decltype(update(p0))(*)(cocos2d::CCScheduler*, float);
	static auto func = wrapFunction(base::get() + 0x421a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x48c2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

cocos2d::CCLayer::CCLayer() {
	using FunctionType = void(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48bcf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCLayer::~CCLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48bfe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCLayer(geode::CutoffConstructor, sizeof(cocos2d::CCLayer));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48cb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48ccd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48cc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::registerScriptTouchHandler(int p0, bool p1, int p2, bool p3) -> decltype(registerScriptTouchHandler(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool, int, bool>::func(&cocos2d::CCLayer::registerScriptTouchHandler), this);
	using FunctionType = decltype(registerScriptTouchHandler(p0, p1, p2, p3))(*)(cocos2d::CCLayer*, int, bool, int, bool);
	static auto func = wrapFunction(base::get() + 0x48c450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto cocos2d::CCLayer::unregisterScriptTouchHandler() -> decltype(unregisterScriptTouchHandler()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::unregisterScriptTouchHandler), this);
	using FunctionType = decltype(unregisterScriptTouchHandler())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::isTouchEnabled() -> decltype(isTouchEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isTouchEnabled), this);
	using FunctionType = decltype(isTouchEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setTouchEnabled(bool p0) -> decltype(setTouchEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setTouchEnabled), this);
	using FunctionType = decltype(setTouchEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x48c570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::setTouchMode(cocos2d::ccTouchesMode p0) -> decltype(setTouchMode(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::ccTouchesMode>::func(&cocos2d::CCLayer::setTouchMode), this);
	using FunctionType = decltype(setTouchMode(p0))(*)(cocos2d::CCLayer*, cocos2d::ccTouchesMode);
	static auto func = wrapFunction(base::get() + 0x48c5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::getTouchMode() -> decltype(getTouchMode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::getTouchMode), this);
	using FunctionType = decltype(getTouchMode())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setTouchPriority(int p0) -> decltype(setTouchPriority(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCLayer::setTouchPriority), this);
	using FunctionType = decltype(setTouchPriority(p0))(*)(cocos2d::CCLayer*, int);
	static auto func = wrapFunction(base::get() + 0x48c630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::getTouchPriority() -> decltype(getTouchPriority()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::getTouchPriority), this);
	using FunctionType = decltype(getTouchPriority())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::isAccelerometerEnabled() -> decltype(isAccelerometerEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isAccelerometerEnabled), this);
	using FunctionType = decltype(isAccelerometerEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setAccelerometerEnabled(bool p0) -> decltype(setAccelerometerEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setAccelerometerEnabled), this);
	using FunctionType = decltype(setAccelerometerEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x48c6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::setAccelerometerInterval(double p0) -> decltype(setAccelerometerInterval(p0)) {
	auto self = addresser::thunkAdjust(Resolve<double>::func(&cocos2d::CCLayer::setAccelerometerInterval), this);
	using FunctionType = decltype(setAccelerometerInterval(p0))(*)(cocos2d::CCLayer*, double);
	static auto func = wrapFunction(base::get() + 0x48c6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::isKeypadEnabled() -> decltype(isKeypadEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isKeypadEnabled), this);
	using FunctionType = decltype(isKeypadEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setKeypadEnabled(bool p0) -> decltype(setKeypadEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setKeypadEnabled), this);
	using FunctionType = decltype(setKeypadEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x48c800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::isKeyboardEnabled() -> decltype(isKeyboardEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isKeyboardEnabled), this);
	using FunctionType = decltype(isKeyboardEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setKeyboardEnabled(bool p0) -> decltype(setKeyboardEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setKeyboardEnabled), this);
	using FunctionType = decltype(setKeyboardEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x48c880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::isMouseEnabled() -> decltype(isMouseEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::isMouseEnabled), this);
	using FunctionType = decltype(isMouseEnabled())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::setMouseEnabled(bool p0) -> decltype(setMouseEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayer::setMouseEnabled), this);
	using FunctionType = decltype(setMouseEnabled(p0))(*)(cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x48c8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x48cd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x48cda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x48ce20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x48cea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchesBegan(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchesBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchesBegan), this);
	using FunctionType = decltype(ccTouchesBegan(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x48cf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchesMoved(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchesMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchesMoved), this);
	using FunctionType = decltype(ccTouchesMoved(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x48cfa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchesEnded(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchesEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchesEnded), this);
	using FunctionType = decltype(ccTouchesEnded(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x48d020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::ccTouchesCancelled(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchesCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCLayer::ccTouchesCancelled), this);
	using FunctionType = decltype(ccTouchesCancelled(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x48d0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayer::setPreviousPriority(int p0) -> decltype(setPreviousPriority(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCLayer::setPreviousPriority), this);
	using FunctionType = decltype(setPreviousPriority(p0))(*)(cocos2d::CCLayer*, int);
	static auto func = wrapFunction(base::get() + 0xa660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::getPreviousPriority() -> decltype(getPreviousPriority()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::getPreviousPriority), this);
	using FunctionType = decltype(getPreviousPriority())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0xa670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::didAccelerate(cocos2d::CCAcceleration* p0) -> decltype(didAccelerate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCAcceleration*>::func(&cocos2d::CCLayer::didAccelerate), this);
	using FunctionType = decltype(didAccelerate(p0))(*)(cocos2d::CCLayer*, cocos2d::CCAcceleration*);
	static auto func = wrapFunction(base::get() + 0x48c720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48c9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::keyMenuClicked() -> decltype(keyMenuClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayer::keyMenuClicked), this);
	using FunctionType = decltype(keyMenuClicked())(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x48ca40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&cocos2d::CCLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(cocos2d::CCLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x48cac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCObject::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x467310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

cocos2d::CCObject::CCObject() {
	using FunctionType = void(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x467020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCObject::~CCObject() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x467130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCObject(geode::CutoffConstructor, sizeof(cocos2d::CCObject));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCObject::autorelease() -> decltype(autorelease()) {
	using FunctionType = decltype(autorelease())(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x467260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCObject::isSingleReference() const  -> decltype(isSingleReference()) {
	using FunctionType = decltype(isSingleReference())(*)(cocos2d::CCObject const *);
	static auto func = wrapFunction(base::get() + 0x467290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCObject::release() -> decltype(release()) {
	using FunctionType = decltype(release())(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x467230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCObject::retain() -> decltype(retain()) {
	using FunctionType = decltype(retain())(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x467250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCObject::getTag() const  -> decltype(getTag()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCObject::getTag), this);
	using FunctionType = decltype(getTag())(*)(cocos2d::CCObject const *);
	static auto func = wrapFunction(base::get() + 0x4672e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCObject::isEqual(cocos2d::CCObject const* p0) -> decltype(isEqual(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject const*>::func(&cocos2d::CCObject::isEqual), this);
	using FunctionType = decltype(isEqual(p0))(*)(cocos2d::CCObject*, cocos2d::CCObject const*);
	static auto func = wrapFunction(base::get() + 0x4672b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCObject::acceptVisitor(cocos2d::CCDataVisitor& p0) -> decltype(acceptVisitor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCDataVisitor&>::func(&cocos2d::CCObject::acceptVisitor), this);
	using FunctionType = decltype(acceptVisitor(p0))(*)(cocos2d::CCObject*, cocos2d::CCDataVisitor&);
	static auto func = wrapFunction(base::get() + 0x4672c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&cocos2d::CCObject::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(cocos2d::CCObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x467300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCObject::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCObject::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x467320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCObject::setTag(int p0) -> decltype(setTag(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCObject::setTag), this);
	using FunctionType = decltype(setTag(p0))(*)(cocos2d::CCObject*, int);
	static auto func = wrapFunction(base::get() + 0x4672f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCOrbitCamera::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCOrbitCamera::copyWithZone not implemented");
}

auto cocos2d::CCOrbitCamera::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCOrbitCamera::update not implemented");
}

auto cocos2d::CCOrbitCamera::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCOrbitCamera::startWithTarget not implemented");
}

auto cocos2d::CCLayerColor::create(cocos2d::_ccColor4B const& p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::_ccColor4B const&);
	static auto func = wrapFunction(base::get() + 0x48e8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCLayerColor::create(cocos2d::_ccColor4B const& p0, float p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::_ccColor4B const&, float, float);
	static auto func = wrapFunction(base::get() + 0x48e710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

cocos2d::CCLayerColor::CCLayerColor() {
	using FunctionType = void(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x48dee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCLayerColor::~CCLayerColor() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x48e290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCLayerColor(geode::CutoffConstructor, sizeof(cocos2d::CCLayerColor));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCLayerColor::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerColor::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x48ea90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerColor::setContentSize(cocos2d::CCSize const& p0) -> decltype(setContentSize(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSize const&>::func(&cocos2d::CCLayerColor::setContentSize), this);
	using FunctionType = decltype(setContentSize(p0))(*)(cocos2d::CCLayerColor*, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x48ec80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerColor::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x48edc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerColor::initWithColor(cocos2d::_ccColor4B const& p0, float p1, float p2) -> decltype(initWithColor(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4B const&, float, float>::func(&cocos2d::CCLayerColor::initWithColor), this);
	using FunctionType = decltype(initWithColor(p0, p1, p2))(*)(cocos2d::CCLayerColor*, cocos2d::_ccColor4B const&, float, float);
	static auto func = wrapFunction(base::get() + 0x48eae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCLayerColor::initWithColor(cocos2d::_ccColor4B const& p0) -> decltype(initWithColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4B const&>::func(&cocos2d::CCLayerColor::initWithColor), this);
	using FunctionType = decltype(initWithColor(p0))(*)(cocos2d::CCLayerColor*, cocos2d::_ccColor4B const&);
	static auto func = wrapFunction(base::get() + 0x48ebd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::updateColor() -> decltype(updateColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerColor::updateColor), this);
	using FunctionType = decltype(updateColor())(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x48ed70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerColor::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerColor::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCLayerColor*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x48ee90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerColor::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCLayerColor*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x48f010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccBlendFunc>::func(&cocos2d::CCLayerColor::setBlendFunc), this);
	using FunctionType = decltype(setBlendFunc(p0))(*)(cocos2d::CCLayerColor*, cocos2d::_ccBlendFunc);
	static auto func = wrapFunction(base::get() + 0x48e520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerColor::getBlendFunc() -> decltype(getBlendFunc()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerColor::getBlendFunc), this);
	using FunctionType = decltype(getBlendFunc())(*)(cocos2d::CCLayerColor*);
	static auto func = wrapFunction(base::get() + 0x48e500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::create(cocos2d::_ccColor4B const& p0, cocos2d::_ccColor4B const& p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&);
	static auto func = wrapFunction(base::get() + 0x48f140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCLayerGradient::create(cocos2d::_ccColor4B const& p0, cocos2d::_ccColor4B const& p1, cocos2d::CCPoint const& p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x48f3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto cocos2d::CCLayerGradient::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x48f480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCLayerGradient::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x48f4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::updateColor() -> decltype(updateColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::updateColor), this);
	using FunctionType = decltype(updateColor())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x48f630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::initWithColor(cocos2d::_ccColor4B const& p0, cocos2d::_ccColor4B const& p1) -> decltype(initWithColor(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&>::func(&cocos2d::CCLayerGradient::initWithColor), this);
	using FunctionType = decltype(initWithColor(p0, p1))(*)(cocos2d::CCLayerGradient*, cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&);
	static auto func = wrapFunction(base::get() + 0x48f580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLayerGradient::initWithColor(cocos2d::_ccColor4B const& p0, cocos2d::_ccColor4B const& p1, cocos2d::CCPoint const& p2) -> decltype(initWithColor(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&, cocos2d::CCPoint const&>::func(&cocos2d::CCLayerGradient::initWithColor), this);
	using FunctionType = decltype(initWithColor(p0, p1, p2))(*)(cocos2d::CCLayerGradient*, cocos2d::_ccColor4B const&, cocos2d::_ccColor4B const&, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x48f520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCLayerGradient::getStartColor() -> decltype(getStartColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getStartColor), this);
	using FunctionType = decltype(getStartColor())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x48f820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setStartColor(cocos2d::_ccColor3B const& p0) -> decltype(setStartColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerGradient::setStartColor), this);
	using FunctionType = decltype(setStartColor(p0))(*)(cocos2d::CCLayerGradient*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x48f830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::getEndColor() -> decltype(getEndColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getEndColor), this);
	using FunctionType = decltype(getEndColor())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x48f880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setEndColor(cocos2d::_ccColor3B const& p0) -> decltype(setEndColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerGradient::setEndColor), this);
	using FunctionType = decltype(setEndColor(p0))(*)(cocos2d::CCLayerGradient*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x48f850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::getStartOpacity() -> decltype(getStartOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getStartOpacity), this);
	using FunctionType = decltype(getStartOpacity())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x48f8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setStartOpacity(unsigned char p0) -> decltype(setStartOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerGradient::setStartOpacity), this);
	using FunctionType = decltype(setStartOpacity(p0))(*)(cocos2d::CCLayerGradient*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x48f890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::getEndOpacity() -> decltype(getEndOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getEndOpacity), this);
	using FunctionType = decltype(getEndOpacity())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x48f8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setEndOpacity(unsigned char p0) -> decltype(setEndOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerGradient::setEndOpacity), this);
	using FunctionType = decltype(setEndOpacity(p0))(*)(cocos2d::CCLayerGradient*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x48f8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::getVector() -> decltype(getVector()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::getVector), this);
	using FunctionType = decltype(getVector())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x48f920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerGradient::setVector(cocos2d::CCPoint const& p0) -> decltype(setVector(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCLayerGradient::setVector), this);
	using FunctionType = decltype(setVector(p0))(*)(cocos2d::CCLayerGradient*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x48f8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::setCompressedInterpolation(bool p0) -> decltype(setCompressedInterpolation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayerGradient::setCompressedInterpolation), this);
	using FunctionType = decltype(setCompressedInterpolation(p0))(*)(cocos2d::CCLayerGradient*, bool);
	static auto func = wrapFunction(base::get() + 0x48f9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerGradient::isCompressedInterpolation() -> decltype(isCompressedInterpolation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerGradient::isCompressedInterpolation), this);
	using FunctionType = decltype(isCompressedInterpolation())(*)(cocos2d::CCLayerGradient*);
	static auto func = wrapFunction(base::get() + 0x48f9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

cocos2d::CCLayerRGBA::CCLayerRGBA() {
	using FunctionType = void(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x48d120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCLayerRGBA::~CCLayerRGBA() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x48d490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCLayerRGBA(geode::CutoffConstructor, sizeof(cocos2d::CCLayerRGBA));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCLayerRGBA::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x48d700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerRGBA::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCLayerRGBA*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x48d940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::getColor() -> decltype(getColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::getColor), this);
	using FunctionType = decltype(getColor())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x48d900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::getDisplayedColor() -> decltype(getDisplayedColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::getDisplayedColor), this);
	using FunctionType = decltype(getDisplayedColor())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x48d920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::getDisplayedOpacity() -> decltype(getDisplayedOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::getDisplayedOpacity), this);
	using FunctionType = decltype(getDisplayedOpacity())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x48d7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::getOpacity() -> decltype(getOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::getOpacity), this);
	using FunctionType = decltype(getOpacity())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x48d780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerRGBA::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCLayerRGBA*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x48d7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::isCascadeColorEnabled() -> decltype(isCascadeColorEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::isCascadeColorEnabled), this);
	using FunctionType = decltype(isCascadeColorEnabled())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x48dea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::setCascadeColorEnabled(bool p0) -> decltype(setCascadeColorEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayerRGBA::setCascadeColorEnabled), this);
	using FunctionType = decltype(setCascadeColorEnabled(p0))(*)(cocos2d::CCLayerRGBA*, bool);
	static auto func = wrapFunction(base::get() + 0x48dec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::updateDisplayedColor(cocos2d::_ccColor3B const& p0) -> decltype(updateDisplayedColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLayerRGBA::updateDisplayedColor), this);
	using FunctionType = decltype(updateDisplayedColor(p0))(*)(cocos2d::CCLayerRGBA*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x48dc40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::isCascadeOpacityEnabled() -> decltype(isCascadeOpacityEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLayerRGBA::isCascadeOpacityEnabled), this);
	using FunctionType = decltype(isCascadeOpacityEnabled())(*)(cocos2d::CCLayerRGBA*);
	static auto func = wrapFunction(base::get() + 0x48de60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLayerRGBA::setCascadeOpacityEnabled(bool p0) -> decltype(setCascadeOpacityEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLayerRGBA::setCascadeOpacityEnabled), this);
	using FunctionType = decltype(setCascadeOpacityEnabled(p0))(*)(cocos2d::CCLayerRGBA*, bool);
	static auto func = wrapFunction(base::get() + 0x48de80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLayerRGBA::updateDisplayedOpacity(unsigned char p0) -> decltype(updateDisplayedOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLayerRGBA::updateDisplayedOpacity), this);
	using FunctionType = decltype(updateDisplayedOpacity(p0))(*)(cocos2d::CCLayerRGBA*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x48dab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMouseDispatcher::dispatchScrollMSG(float p0, float p1) -> decltype(dispatchScrollMSG(p0, p1)) {
	using FunctionType = decltype(dispatchScrollMSG(p0, p1))(*)(cocos2d::CCMouseDispatcher*, float, float);
	static auto func = wrapFunction(base::get() + 0x53c670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCMoveBy::create(float p0, cocos2d::CCPoint const& p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x3960c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCMoveBy::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCMoveBy::copyWithZone not implemented");
}

auto cocos2d::CCMoveBy::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCMoveBy::update not implemented");
}

auto cocos2d::CCMoveBy::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCMoveBy::startWithTarget not implemented");
}

auto cocos2d::CCMoveBy::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCMoveBy::reverse not implemented");
}

auto cocos2d::CCMoveTo::create(float p0, cocos2d::CCPoint const& p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x3964a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCMoveTo::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCMoveTo::copyWithZone not implemented");
}

auto cocos2d::CCMoveTo::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCMoveTo::startWithTarget not implemented");
}

auto cocos2d::CCTouchHandler::getDelegate() -> decltype(getDelegate()) {
	using FunctionType = decltype(getDelegate())(*)(cocos2d::CCTouchHandler*);
	static auto func = wrapFunction(base::get() + 0x45d860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouchHandler::getPriority() -> decltype(getPriority()) {
	using FunctionType = decltype(getPriority())(*)(cocos2d::CCTouchHandler*);
	static auto func = wrapFunction(base::get() + 0x45d8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouchHandler::setPriority(int p0) -> decltype(setPriority(p0)) {
	using FunctionType = decltype(setPriority(p0))(*)(cocos2d::CCTouchHandler*, int);
	static auto func = wrapFunction(base::get() + 0x45d8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTouchHandler::initWithDelegate(cocos2d::CCTouchDelegate* p0, int p1) -> decltype(initWithDelegate(p0, p1)) {
	throw std::runtime_error("cocos2d::CCTouchHandler::initWithDelegate not implemented");
}

auto cocos2d::CCTextureCache::purgeSharedTextureCache() -> decltype(purgeSharedTextureCache()) {
	using FunctionType = decltype(purgeSharedTextureCache())(*)();
	static auto func = wrapFunction(base::get() + 0x5b16d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCTextureCache::sharedTextureCache() -> decltype(sharedTextureCache()) {
	using FunctionType = decltype(sharedTextureCache())(*)();
	static auto func = wrapFunction(base::get() + 0x5b1450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCTextureCache::addImage(char const* p0, bool p1) -> decltype(addImage(p0, p1)) {
	using FunctionType = decltype(addImage(p0, p1))(*)(cocos2d::CCTextureCache*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x5b2630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTextureCache::addImageAsync(char const* p0, cocos2d::CCObject* p1, cocos2d::SEL_MenuHandler p2, int p3, cocos2d::CCTexture2DPixelFormat p4) -> decltype(addImageAsync(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(addImageAsync(p0, p1, p2, p3, p4))(*)(cocos2d::CCTextureCache*, char const*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler, int, cocos2d::CCTexture2DPixelFormat);
	static auto func = wrapFunction(base::get() + 0x5b18d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCTextureCache::addUIImage(cocos2d::CCImage* p0, char const* p1) -> decltype(addUIImage(p0, p1)) {
	using FunctionType = decltype(addUIImage(p0, p1))(*)(cocos2d::CCTextureCache*, cocos2d::CCImage*, char const*);
	static auto func = wrapFunction(base::get() + 0x5b3350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTextureCache::removeTextureForKey(char const* p0) -> decltype(removeTextureForKey(p0)) {
	using FunctionType = decltype(removeTextureForKey(p0))(*)(cocos2d::CCTextureCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x5b38d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTextureCache::textureForKey(char const* p0) -> decltype(textureForKey(p0)) {
	using FunctionType = decltype(textureForKey(p0))(*)(cocos2d::CCTextureCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x5b3950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCPoint cocos2d::CCTouch::getDelta() const  {
		return getLocation() - getPreviousLocation();
	}

auto cocos2d::CCTouch::getLocation() const  -> decltype(getLocation()) {
	using FunctionType = decltype(getLocation())(*)(cocos2d::CCTouch const *);
	static auto func = wrapFunction(base::get() + 0x5c750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCPoint cocos2d::CCTouch::getPreviousLocation() const  {
		return CCDirector::sharedDirector()->convertToGL(m_prevPoint);
	}

auto cocos2d::CCSet::addObject(cocos2d::CCObject* p0) -> decltype(addObject(p0)) {
	using FunctionType = decltype(addObject(p0))(*)(cocos2d::CCSet*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x775080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSet::anyObject() -> decltype(anyObject()) {
	using FunctionType = decltype(anyObject())(*)(cocos2d::CCSet*);
	static auto func = wrapFunction(base::get() + 0x775250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSet::count() -> decltype(count()) {
	using FunctionType = decltype(count())(*)(cocos2d::CCSet*);
	static auto func = wrapFunction(base::get() + 0x775070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSet::mutableCopy() -> decltype(mutableCopy()) {
	using FunctionType = decltype(mutableCopy())(*)(cocos2d::CCSet*);
	static auto func = wrapFunction(base::get() + 0x775030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSet::removeObject(cocos2d::CCObject* p0) -> decltype(removeObject(p0)) {
	using FunctionType = decltype(removeObject(p0))(*)(cocos2d::CCSet*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x775130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSet::acceptVisitor(cocos2d::CCDataVisitor& p0) -> decltype(acceptVisitor(p0)) {
	throw std::runtime_error("cocos2d::CCSet::acceptVisitor not implemented");
}

void cocos2d::CCTouchDelegate::setPreviousPriority(int p0) {}

int cocos2d::CCTouchDelegate::getPreviousPriority() { return 0; }

auto cocos2d::CCTouchDispatcher::init() -> decltype(init()) {
	using FunctionType = decltype(init())(*)(cocos2d::CCTouchDispatcher*);
	static auto func = wrapFunction(base::get() + 0x4a6bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouchDispatcher::setPriority(int p0, cocos2d::CCTouchDelegate* p1) -> decltype(setPriority(p0, p1)) {
	using FunctionType = decltype(setPriority(p0, p1))(*)(cocos2d::CCTouchDispatcher*, int, cocos2d::CCTouchDelegate*);
	static auto func = wrapFunction(base::get() + 0x4a7640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTouchDispatcher::addPrioTargetedDelegate(cocos2d::CCTouchDelegate* p0, int p1, bool p2) -> decltype(addPrioTargetedDelegate(p0, p1, p2)) {
	using FunctionType = decltype(addPrioTargetedDelegate(p0, p1, p2))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCTouchDelegate*, int, bool);
	static auto func = wrapFunction(base::get() + 0x4a6ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCTouchDispatcher::addTargetedDelegate(cocos2d::CCTouchDelegate* p0, int p1, bool p2) -> decltype(addTargetedDelegate(p0, p1, p2)) {
	using FunctionType = decltype(addTargetedDelegate(p0, p1, p2))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCTouchDelegate*, int, bool);
	static auto func = wrapFunction(base::get() + 0x4a6ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCTouchDispatcher::findHandler(cocos2d::CCTouchDelegate* p0) -> decltype(findHandler(p0)) {
	using FunctionType = decltype(findHandler(p0))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCTouchDelegate*);
	static auto func = wrapFunction(base::get() + 0x4a74f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTouchDispatcher::forceRemoveDelegate(cocos2d::CCTouchDelegate* p0) -> decltype(forceRemoveDelegate(p0)) {
	using FunctionType = decltype(forceRemoveDelegate(p0))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCTouchDelegate*);
	static auto func = wrapFunction(base::get() + 0x4a7250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTouchDispatcher::isUsingForcePrio() -> decltype(isUsingForcePrio()) {
	using FunctionType = decltype(isUsingForcePrio())(*)(cocos2d::CCTouchDispatcher*);
	static auto func = wrapFunction(base::get() + 0x4a6e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTouchDispatcher::registerForcePrio(cocos2d::CCObject* p0, int p1) -> decltype(registerForcePrio(p0, p1)) {
	using FunctionType = decltype(registerForcePrio(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCObject*, int);
	static auto func = wrapFunction(base::get() + 0x4a6da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCTouchDispatcher::removeDelegate(cocos2d::CCTouchDelegate* p0) -> decltype(removeDelegate(p0)) {
	using FunctionType = decltype(removeDelegate(p0))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCTouchDelegate*);
	static auto func = wrapFunction(base::get() + 0x4a7350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTouchDispatcher::touches(cocos2d::CCSet* p0, cocos2d::CCEvent* p1, unsigned int p2) -> decltype(touches(p0, p1, p2)) {
	using FunctionType = decltype(touches(p0, p1, p2))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x4a77a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCTouchDispatcher::unregisterForcePrio(cocos2d::CCObject* p0) -> decltype(unregisterForcePrio(p0)) {
	using FunctionType = decltype(unregisterForcePrio(p0))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4a6e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTouchDispatcher::touchesBegan(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(touchesBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCTouchDispatcher::touchesBegan), this);
	using FunctionType = decltype(touchesBegan(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a7de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTouchDispatcher::touchesMoved(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(touchesMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCTouchDispatcher::touchesMoved), this);
	using FunctionType = decltype(touchesMoved(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a7e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTouchDispatcher::touchesEnded(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(touchesEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCTouchDispatcher::touchesEnded), this);
	using FunctionType = decltype(touchesEnded(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a7e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTouchDispatcher::touchesCancelled(cocos2d::CCSet* p0, cocos2d::CCEvent* p1) -> decltype(touchesCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSet*, cocos2d::CCEvent*>::func(&cocos2d::CCTouchDispatcher::touchesCancelled), this);
	using FunctionType = decltype(touchesCancelled(p0, p1))(*)(cocos2d::CCTouchDispatcher*, cocos2d::CCSet*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a7ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCEGLView::swapBuffers() -> decltype(swapBuffers()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCEGLView::swapBuffers), this);
	using FunctionType = decltype(swapBuffers())(*)(cocos2d::CCEGLView*);
	static auto func = wrapFunction(base::get() + 0x4de300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

cocos2d::CCIMEDelegate::CCIMEDelegate() {
	using FunctionType = void(*)(cocos2d::CCIMEDelegate*);
	static auto func = wrapFunction(base::get() + 0x4970a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCIMEDelegate::~CCIMEDelegate() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCIMEDelegate*);
	static auto func = wrapFunction(base::get() + 0x497410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCIMEDelegate(geode::CutoffConstructor, sizeof(cocos2d::CCIMEDelegate));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCIMEDelegate::attachWithIME() -> decltype(attachWithIME()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCIMEDelegate::attachWithIME), this);
	using FunctionType = decltype(attachWithIME())(*)(cocos2d::CCIMEDelegate*);
	static auto func = wrapFunction(base::get() + 0x497440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCIMEDelegate::detachWithIME() -> decltype(detachWithIME()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCIMEDelegate::detachWithIME), this);
	using FunctionType = decltype(detachWithIME())(*)(cocos2d::CCIMEDelegate*);
	static auto func = wrapFunction(base::get() + 0x497630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void cocos2d::CCIMEDelegate::deleteForward() {}

auto cocos2d::CCIMEDispatcher::dispatchDeleteBackward() -> decltype(dispatchDeleteBackward()) {
	using FunctionType = decltype(dispatchDeleteBackward())(*)(cocos2d::CCIMEDispatcher*);
	static auto func = wrapFunction(base::get() + 0x497940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCIMEDispatcher::dispatchInsertText(char const* p0, int p1, cocos2d::enumKeyCodes p2) -> decltype(dispatchInsertText(p0, p1, p2)) {
	using FunctionType = decltype(dispatchInsertText(p0, p1, p2))(*)(cocos2d::CCIMEDispatcher*, char const*, int, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x497910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCKeyboardDispatcher::dispatchKeyboardMSG(cocos2d::enumKeyCodes p0, bool p1, bool p2) -> decltype(dispatchKeyboardMSG(p0, p1, p2)) {
	using FunctionType = decltype(dispatchKeyboardMSG(p0, p1, p2))(*)(cocos2d::CCKeyboardDispatcher*, cocos2d::enumKeyCodes, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1e2400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCKeyboardDispatcher::keyToString(cocos2d::enumKeyCodes p0) -> decltype(keyToString(p0)) {
	using FunctionType = decltype(keyToString(p0))(*)(cocos2d::CCKeyboardDispatcher*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x1e26d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::sharedDirector() -> decltype(sharedDirector()) {
	using FunctionType = decltype(sharedDirector())(*)();
	static auto func = wrapFunction(base::get() + 0x45eba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCDirector::getWinSize() -> decltype(getWinSize()) {
	using FunctionType = decltype(getWinSize())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x45ff90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::setDefaultValues() -> decltype(setDefaultValues()) {
	using FunctionType = decltype(setDefaultValues())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x45ef70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::setDepthTest(bool p0) -> decltype(setDepthTest(p0)) {
	using FunctionType = decltype(setDepthTest(p0))(*)(cocos2d::CCDirector*, bool);
	static auto func = wrapFunction(base::get() + 0x45f2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::setGLDefaultValues() -> decltype(setGLDefaultValues()) {
	using FunctionType = decltype(setGLDefaultValues())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x45f250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::convertToGL(cocos2d::CCPoint const& p0) -> decltype(convertToGL(p0)) {
	using FunctionType = decltype(convertToGL(p0))(*)(cocos2d::CCDirector*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x4604c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::createStatsLabel() -> decltype(createStatsLabel()) {
	using FunctionType = decltype(createStatsLabel())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x45fe60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::drawScene() -> decltype(drawScene()) {
	using FunctionType = decltype(drawScene())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x45f510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::popSceneWithTransition(float p0, cocos2d::PopTransition p1) -> decltype(popSceneWithTransition(p0, p1)) {
	using FunctionType = decltype(popSceneWithTransition(p0, p1))(*)(cocos2d::CCDirector*, float, cocos2d::PopTransition);
	static auto func = wrapFunction(base::get() + 0x460b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCDirector::popToSceneStackLevel(int p0) -> decltype(popToSceneStackLevel(p0)) {
	using FunctionType = decltype(popToSceneStackLevel(p0))(*)(cocos2d::CCDirector*, int);
	static auto func = wrapFunction(base::get() + 0x460da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::purgeDirector() -> decltype(purgeDirector()) {
	using FunctionType = decltype(purgeDirector())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x460e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::pushScene(cocos2d::CCScene* p0) -> decltype(pushScene(p0)) {
	using FunctionType = decltype(pushScene(p0))(*)(cocos2d::CCDirector*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x4608a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::removeStatsLabel() -> decltype(removeStatsLabel()) {
	using FunctionType = decltype(removeStatsLabel())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x461020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::replaceScene(cocos2d::CCScene* p0) -> decltype(replaceScene(p0)) {
	using FunctionType = decltype(replaceScene(p0))(*)(cocos2d::CCDirector*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x460950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::resume() -> decltype(resume()) {
	using FunctionType = decltype(resume())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x460fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::runWithScene(cocos2d::CCScene* p0) -> decltype(runWithScene(p0)) {
	using FunctionType = decltype(runWithScene(p0))(*)(cocos2d::CCDirector*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x460800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDirector::sceneCount() -> decltype(sceneCount()) {
	using FunctionType = decltype(sceneCount())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x460d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDirector::toggleShowFPS(bool p0, gd::string p1, cocos2d::CCPoint p2) -> decltype(toggleShowFPS(p0, p1, p2)) {
	using FunctionType = decltype(toggleShowFPS(p0, p1, p2))(*)(cocos2d::CCDirector*, bool, gd::string, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x45fe70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCDirector::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCDirector::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCDirector*);
	static auto func = wrapFunction(base::get() + 0x45ecc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCDirector::getScheduler() -> decltype(getScheduler()) {
	throw std::runtime_error("cocos2d::CCDirector::getScheduler not implemented");
}

auto cocos2d::CCDirector::setScheduler(cocos2d::CCScheduler* p0) -> decltype(setScheduler(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setScheduler not implemented");
}

auto cocos2d::CCDirector::getActionManager() -> decltype(getActionManager()) {
	throw std::runtime_error("cocos2d::CCDirector::getActionManager not implemented");
}

auto cocos2d::CCDirector::setActionManager(cocos2d::CCActionManager* p0) -> decltype(setActionManager(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setActionManager not implemented");
}

auto cocos2d::CCDirector::getTouchDispatcher() -> decltype(getTouchDispatcher()) {
	throw std::runtime_error("cocos2d::CCDirector::getTouchDispatcher not implemented");
}

auto cocos2d::CCDirector::setTouchDispatcher(cocos2d::CCTouchDispatcher* p0) -> decltype(setTouchDispatcher(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setTouchDispatcher not implemented");
}

auto cocos2d::CCDirector::getKeypadDispatcher() -> decltype(getKeypadDispatcher()) {
	throw std::runtime_error("cocos2d::CCDirector::getKeypadDispatcher not implemented");
}

auto cocos2d::CCDirector::setKeypadDispatcher(cocos2d::CCKeypadDispatcher* p0) -> decltype(setKeypadDispatcher(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setKeypadDispatcher not implemented");
}

auto cocos2d::CCDirector::getKeyboardDispatcher() -> decltype(getKeyboardDispatcher()) {
	throw std::runtime_error("cocos2d::CCDirector::getKeyboardDispatcher not implemented");
}

auto cocos2d::CCDirector::setKeyboardDispatcher(cocos2d::CCKeyboardDispatcher* p0) -> decltype(setKeyboardDispatcher(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setKeyboardDispatcher not implemented");
}

auto cocos2d::CCDirector::getMouseDispatcher() -> decltype(getMouseDispatcher()) {
	throw std::runtime_error("cocos2d::CCDirector::getMouseDispatcher not implemented");
}

auto cocos2d::CCDirector::setMouseDispatcher(cocos2d::CCMouseDispatcher* p0) -> decltype(setMouseDispatcher(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setMouseDispatcher not implemented");
}

auto cocos2d::CCDirector::getAccelerometer() -> decltype(getAccelerometer()) {
	throw std::runtime_error("cocos2d::CCDirector::getAccelerometer not implemented");
}

auto cocos2d::CCDirector::setAccelerometer(cocos2d::CCAccelerometer* p0) -> decltype(setAccelerometer(p0)) {
	throw std::runtime_error("cocos2d::CCDirector::setAccelerometer not implemented");
}

auto cocos2d::CCDirector::getDeltaTime() -> decltype(getDeltaTime()) {
	throw std::runtime_error("cocos2d::CCDirector::getDeltaTime not implemented");
}

auto cocos2d::CCEGLViewProtocol::getViewPortRect() const  -> decltype(getViewPortRect()) {
	using FunctionType = decltype(getViewPortRect())(*)(cocos2d::CCEGLViewProtocol const *);
	static auto func = wrapFunction(base::get() + 0x4e8680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCEGLViewProtocol::setFrameSize(float p0, float p1) -> decltype(setFrameSize(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&cocos2d::CCEGLViewProtocol::setFrameSize), this);
	using FunctionType = decltype(setFrameSize(p0, p1))(*)(cocos2d::CCEGLViewProtocol*, float, float);
	static auto func = wrapFunction(base::get() + 0x4e7d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCEGLViewProtocol::setDesignResolutionSize(float p0, float p1, ResolutionPolicy p2) -> decltype(setDesignResolutionSize(p0, p1, p2)) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::setDesignResolutionSize not implemented");
}

auto cocos2d::CCEGLViewProtocol::setTouchDelegate(cocos2d::EGLTouchDelegate* p0) -> decltype(setTouchDelegate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::EGLTouchDelegate*>::func(&cocos2d::CCEGLViewProtocol::setTouchDelegate), this);
	using FunctionType = decltype(setTouchDelegate(p0))(*)(cocos2d::CCEGLViewProtocol*, cocos2d::EGLTouchDelegate*);
	static auto func = wrapFunction(base::get() + 0x4e7e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCEGLViewProtocol::setViewPortInPoints(float p0, float p1, float p2, float p3) -> decltype(setViewPortInPoints(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<float, float, float, float>::func(&cocos2d::CCEGLViewProtocol::setViewPortInPoints), this);
	using FunctionType = decltype(setViewPortInPoints(p0, p1, p2, p3))(*)(cocos2d::CCEGLViewProtocol*, float, float, float, float);
	static auto func = wrapFunction(base::get() + 0x4de390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto cocos2d::CCEGLViewProtocol::setScissorInPoints(float p0, float p1, float p2, float p3) -> decltype(setScissorInPoints(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<float, float, float, float>::func(&cocos2d::CCEGLViewProtocol::setScissorInPoints), this);
	using FunctionType = decltype(setScissorInPoints(p0, p1, p2, p3))(*)(cocos2d::CCEGLViewProtocol*, float, float, float, float);
	static auto func = wrapFunction(base::get() + 0x4de480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto cocos2d::CCEGLViewProtocol::isScissorEnabled() -> decltype(isScissorEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCEGLViewProtocol::isScissorEnabled), this);
	using FunctionType = decltype(isScissorEnabled())(*)(cocos2d::CCEGLViewProtocol*);
	static auto func = wrapFunction(base::get() + 0x4e7ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCEGLViewProtocol::getScissorRect() -> decltype(getScissorRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCEGLViewProtocol::getScissorRect), this);
	using FunctionType = decltype(getScissorRect())(*)(cocos2d::CCEGLViewProtocol*);
	static auto func = wrapFunction(base::get() + 0x4e7ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCEGLViewProtocol::setViewName(char const* p0) -> decltype(setViewName(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCEGLViewProtocol::setViewName), this);
	using FunctionType = decltype(setViewName(p0))(*)(cocos2d::CCEGLViewProtocol*, char const*);
	static auto func = wrapFunction(base::get() + 0x4e7f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCEGLViewProtocol::pollInputEvents() -> decltype(pollInputEvents()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCEGLViewProtocol::pollInputEvents), this);
	using FunctionType = decltype(pollInputEvents())(*)(cocos2d::CCEGLViewProtocol*);
	static auto func = wrapFunction(base::get() + 0x4e86b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCEGLViewProtocol::getDesignResolutionSize() const  -> decltype(getDesignResolutionSize()) {
	throw std::runtime_error("cocos2d::CCEGLViewProtocol::getDesignResolutionSize not implemented");
}

auto cocos2d::CCEGLViewProtocol::getFrameSize() const  -> decltype(getFrameSize()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCEGLViewProtocol::getFrameSize), this);
	using FunctionType = decltype(getFrameSize())(*)(cocos2d::CCEGLViewProtocol const *);
	static auto func = wrapFunction(base::get() + 0x4e7d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCEGLViewProtocol::getVisibleOrigin() const  -> decltype(getVisibleOrigin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCEGLViewProtocol::getVisibleOrigin), this);
	using FunctionType = decltype(getVisibleOrigin())(*)(cocos2d::CCEGLViewProtocol const *);
	static auto func = wrapFunction(base::get() + 0x4e7dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCEGLViewProtocol::getVisibleSize() const  -> decltype(getVisibleSize()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCEGLViewProtocol::getVisibleSize), this);
	using FunctionType = decltype(getVisibleSize())(*)(cocos2d::CCEGLViewProtocol const *);
	static auto func = wrapFunction(base::get() + 0x4e7d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

cocos2d::CCNodeRGBA::CCNodeRGBA() {
	using FunctionType = void(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x252ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCNodeRGBA::~CCNodeRGBA() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2530a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCNodeRGBA(geode::CutoffConstructor, sizeof(cocos2d::CCNodeRGBA));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCNodeRGBA::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2530d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCNodeRGBA::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCNodeRGBA*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x2534f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::getColor() -> decltype(getColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::getColor), this);
	using FunctionType = decltype(getColor())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2534b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::getDisplayedColor() -> decltype(getDisplayedColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::getDisplayedColor), this);
	using FunctionType = decltype(getDisplayedColor())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x2534d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::getDisplayedOpacity() -> decltype(getDisplayedOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::getDisplayedOpacity), this);
	using FunctionType = decltype(getDisplayedOpacity())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x253180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::getOpacity() -> decltype(getOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::getOpacity), this);
	using FunctionType = decltype(getOpacity())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x253160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCNodeRGBA::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCNodeRGBA*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x2531a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::isCascadeColorEnabled() -> decltype(isCascadeColorEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::isCascadeColorEnabled), this);
	using FunctionType = decltype(isCascadeColorEnabled())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x253880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::setCascadeColorEnabled(bool p0) -> decltype(setCascadeColorEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNodeRGBA::setCascadeColorEnabled), this);
	using FunctionType = decltype(setCascadeColorEnabled(p0))(*)(cocos2d::CCNodeRGBA*, bool);
	static auto func = wrapFunction(base::get() + 0x2538a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::updateDisplayedColor(cocos2d::_ccColor3B const& p0) -> decltype(updateDisplayedColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCNodeRGBA::updateDisplayedColor), this);
	using FunctionType = decltype(updateDisplayedColor(p0))(*)(cocos2d::CCNodeRGBA*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x253660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::isCascadeOpacityEnabled() -> decltype(isCascadeOpacityEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCNodeRGBA::isCascadeOpacityEnabled), this);
	using FunctionType = decltype(isCascadeOpacityEnabled())(*)(cocos2d::CCNodeRGBA*);
	static auto func = wrapFunction(base::get() + 0x253470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCNodeRGBA::setCascadeOpacityEnabled(bool p0) -> decltype(setCascadeOpacityEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCNodeRGBA::setCascadeOpacityEnabled), this);
	using FunctionType = decltype(setCascadeOpacityEnabled(p0))(*)(cocos2d::CCNodeRGBA*, bool);
	static auto func = wrapFunction(base::get() + 0x253490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCNodeRGBA::updateDisplayedOpacity(unsigned char p0) -> decltype(updateDisplayedOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCNodeRGBA::updateDisplayedOpacity), this);
	using FunctionType = decltype(updateDisplayedOpacity(p0))(*)(cocos2d::CCNodeRGBA*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x2532e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCRepeatForever::create(cocos2d::CCActionInterval* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCActionInterval*);
	static auto func = wrapFunction(base::get() + 0x394830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCRepeatForever::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCRepeatForever::copyWithZone not implemented");
}

auto cocos2d::CCRepeatForever::isDone() -> decltype(isDone()) {
	throw std::runtime_error("cocos2d::CCRepeatForever::isDone not implemented");
}

auto cocos2d::CCRepeatForever::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCRepeatForever::startWithTarget not implemented");
}

auto cocos2d::CCRepeatForever::step(float p0) -> decltype(step(p0)) {
	throw std::runtime_error("cocos2d::CCRepeatForever::step not implemented");
}

auto cocos2d::CCRepeatForever::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCRepeatForever::reverse not implemented");
}

auto cocos2d::CCRotateBy::create(float p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, float);
	static auto func = wrapFunction(base::get() + 0x395c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCRotateBy::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCRotateBy::copyWithZone not implemented");
}

auto cocos2d::CCRotateBy::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCRotateBy::update not implemented");
}

auto cocos2d::CCRotateBy::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCRotateBy::startWithTarget not implemented");
}

auto cocos2d::CCRotateBy::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCRotateBy::reverse not implemented");
}

auto cocos2d::CCScaleTo::create(float p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, float);
	static auto func = wrapFunction(base::get() + 0x397f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCScaleTo::create(float p0, float p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(float, float, float);
	static auto func = wrapFunction(base::get() + 0x398090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto cocos2d::CCScaleTo::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCScaleTo::copyWithZone not implemented");
}

auto cocos2d::CCScaleTo::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCScaleTo::update not implemented");
}

auto cocos2d::CCScaleTo::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCScaleTo::startWithTarget not implemented");
}

auto cocos2d::CCSpriteFrameCache::purgeSharedSpriteFrameCache() -> decltype(purgeSharedSpriteFrameCache()) {
	using FunctionType = decltype(purgeSharedSpriteFrameCache())(*)();
	static auto func = wrapFunction(base::get() + 0x2f8740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCSpriteFrameCache::sharedSpriteFrameCache() -> decltype(sharedSpriteFrameCache()) {
	using FunctionType = decltype(sharedSpriteFrameCache())(*)();
	static auto func = wrapFunction(base::get() + 0x2f85f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCSpriteFrameCache::addSpriteFrame(cocos2d::CCSpriteFrame* p0, char const* p1) -> decltype(addSpriteFrame(p0, p1)) {
	using FunctionType = decltype(addSpriteFrame(p0, p1))(*)(cocos2d::CCSpriteFrameCache*, cocos2d::CCSpriteFrame*, char const*);
	static auto func = wrapFunction(base::get() + 0x2f9810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCSpriteFrameCache::addSpriteFramesWithDictionary(cocos2d::CCDictionary* p0, cocos2d::CCTexture2D* p1) -> decltype(addSpriteFramesWithDictionary(p0, p1)) {
	using FunctionType = decltype(addSpriteFramesWithDictionary(p0, p1))(*)(cocos2d::CCSpriteFrameCache*, cocos2d::CCDictionary*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x2f88d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCSpriteFrameCache::addSpriteFramesWithFile(char const* p0) -> decltype(addSpriteFramesWithFile(p0)) {
	using FunctionType = decltype(addSpriteFramesWithFile(p0))(*)(cocos2d::CCSpriteFrameCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x2f9470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrameCache::addSpriteFramesWithFile(char const* p0, cocos2d::CCTexture2D* p1) -> decltype(addSpriteFramesWithFile(p0, p1)) {
	using FunctionType = decltype(addSpriteFramesWithFile(p0, p1))(*)(cocos2d::CCSpriteFrameCache*, char const*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x2f93c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCSpriteFrameCache::removeSpriteFrameByName(char const* p0) -> decltype(removeSpriteFrameByName(p0)) {
	using FunctionType = decltype(removeSpriteFrameByName(p0))(*)(cocos2d::CCSpriteFrameCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x2f99c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrameCache::removeSpriteFrames() -> decltype(removeSpriteFrames()) {
	using FunctionType = decltype(removeSpriteFrames())(*)(cocos2d::CCSpriteFrameCache*);
	static auto func = wrapFunction(base::get() + 0x2f98f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSpriteFrameCache::removeSpriteFramesFromDictionary(cocos2d::CCDictionary* p0) -> decltype(removeSpriteFramesFromDictionary(p0)) {
	using FunctionType = decltype(removeSpriteFramesFromDictionary(p0))(*)(cocos2d::CCSpriteFrameCache*, cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x2f9e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrameCache::removeSpriteFramesFromFile(char const* p0) -> decltype(removeSpriteFramesFromFile(p0)) {
	using FunctionType = decltype(removeSpriteFramesFromFile(p0))(*)(cocos2d::CCSpriteFrameCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x2f9c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrameCache::removeSpriteFramesFromTexture(cocos2d::CCTexture2D* p0) -> decltype(removeSpriteFramesFromTexture(p0)) {
	using FunctionType = decltype(removeSpriteFramesFromTexture(p0))(*)(cocos2d::CCSpriteFrameCache*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x2fa060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteFrameCache::removeUnusedSpriteFrames() -> decltype(removeUnusedSpriteFrames()) {
	using FunctionType = decltype(removeUnusedSpriteFrames())(*)(cocos2d::CCSpriteFrameCache*);
	static auto func = wrapFunction(base::get() + 0x2f9930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSpriteFrameCache::spriteFrameByName(char const* p0) -> decltype(spriteFrameByName(p0)) {
	using FunctionType = decltype(spriteFrameByName(p0))(*)(cocos2d::CCSpriteFrameCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x2fa330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteBatchNode::create(char const* p0, unsigned int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x167460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCSpriteBatchNode::initWithTexture(cocos2d::CCTexture2D* p0, unsigned int p1) -> decltype(initWithTexture(p0, p1)) {
	using FunctionType = decltype(initWithTexture(p0, p1))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCTexture2D*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x167320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCSpriteBatchNode::getAtlasCapacity() -> decltype(getAtlasCapacity()) {
	using FunctionType = decltype(getAtlasCapacity())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x168800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCSpriteBatchNode::CCSpriteBatchNode() {
	using FunctionType = void(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x1675f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCSpriteBatchNode::~CCSpriteBatchNode() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x1676a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCSpriteBatchNode(geode::CutoffConstructor, sizeof(cocos2d::CCSpriteBatchNode));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCSpriteBatchNode::appendChild(cocos2d::CCSprite* p0) -> decltype(appendChild(p0)) {
	using FunctionType = decltype(appendChild(p0))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x1678a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteBatchNode::increaseAtlasCapacity(unsigned int p0) -> decltype(increaseAtlasCapacity(p0)) {
	using FunctionType = decltype(increaseAtlasCapacity(p0))(*)(cocos2d::CCSpriteBatchNode*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x1687b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSpriteBatchNode::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x1675a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::addChild(cocos2d::CCNode* p0) -> decltype(addChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCSpriteBatchNode::addChild), this);
	using FunctionType = decltype(addChild(p0))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x167a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSpriteBatchNode::addChild(cocos2d::CCNode* p0, int p1) -> decltype(addChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCSpriteBatchNode::addChild), this);
	using FunctionType = decltype(addChild(p0, p1))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x167a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSpriteBatchNode::addChild(cocos2d::CCNode* p0, int p1, int p2) -> decltype(addChild(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int, int>::func(&cocos2d::CCSpriteBatchNode::addChild), this);
	using FunctionType = decltype(addChild(p0, p1, p2))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*, int, int);
	static auto func = wrapFunction(base::get() + 0x167810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCSpriteBatchNode::removeChild(cocos2d::CCNode* p0, bool p1) -> decltype(removeChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, bool>::func(&cocos2d::CCSpriteBatchNode::removeChild), this);
	using FunctionType = decltype(removeChild(p0, p1))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x167af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSpriteBatchNode::removeAllChildrenWithCleanup(bool p0) -> decltype(removeAllChildrenWithCleanup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSpriteBatchNode::removeAllChildrenWithCleanup), this);
	using FunctionType = decltype(removeAllChildrenWithCleanup(p0))(*)(cocos2d::CCSpriteBatchNode*, bool);
	static auto func = wrapFunction(base::get() + 0x167dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSpriteBatchNode::reorderChild(cocos2d::CCNode* p0, int p1) -> decltype(reorderChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCSpriteBatchNode::reorderChild), this);
	using FunctionType = decltype(reorderChild(p0, p1))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x167a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSpriteBatchNode::sortAllChildren() -> decltype(sortAllChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::sortAllChildren), this);
	using FunctionType = decltype(sortAllChildren())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x167e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x168670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::visit), this);
	using FunctionType = decltype(visit())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x167770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccBlendFunc>::func(&cocos2d::CCSpriteBatchNode::setBlendFunc), this);
	using FunctionType = decltype(setBlendFunc(p0))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::_ccBlendFunc);
	static auto func = wrapFunction(base::get() + 0x168ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSpriteBatchNode::getBlendFunc() -> decltype(getBlendFunc()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::getBlendFunc), this);
	using FunctionType = decltype(getBlendFunc())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x168ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::getTexture() -> decltype(getTexture()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSpriteBatchNode::getTexture), this);
	using FunctionType = decltype(getTexture())(*)(cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x168f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSpriteBatchNode::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&cocos2d::CCSpriteBatchNode::setTexture), this);
	using FunctionType = decltype(setTexture(p0))(*)(cocos2d::CCSpriteBatchNode*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x168f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x266400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x266700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCSprite::createWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(createWithSpriteFrame(p0)) {
	using FunctionType = decltype(createWithSpriteFrame(p0))(*)(cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x2665e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSprite::createWithSpriteFrameName(char const* p0) -> decltype(createWithSpriteFrameName(p0)) {
	using FunctionType = decltype(createWithSpriteFrameName(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x2666d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSprite::createWithTexture(cocos2d::CCTexture2D* p0) -> decltype(createWithTexture(p0)) {
	using FunctionType = decltype(createWithTexture(p0))(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x266310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSprite::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	using FunctionType = decltype(setFlipX(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x2683b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCSprite::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	using FunctionType = decltype(setFlipY(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x268400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCSprite::CCSprite() {
	using FunctionType = void(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x266b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCSprite::~CCSprite() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x266c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCSprite(geode::CutoffConstructor, sizeof(cocos2d::CCSprite));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x2667e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setVertexZ(float p0) -> decltype(setVertexZ(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setVertexZ), this);
	using FunctionType = decltype(setVertexZ(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x268250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x2680f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x268160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x2681d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCSprite::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(cocos2d::CCSprite*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x267e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setSkewX(float p0) -> decltype(setSkewX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setSkewX), this);
	using FunctionType = decltype(setSkewX(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x268010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setSkewY(float p0) -> decltype(setSkewY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setSkewY), this);
	using FunctionType = decltype(setSkewY(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x268080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setAnchorPoint(cocos2d::CCPoint const& p0) -> decltype(setAnchorPoint(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCSprite::setAnchorPoint), this);
	using FunctionType = decltype(setAnchorPoint(p0))(*)(cocos2d::CCSprite*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x2682c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x268340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x267ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x267f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCSprite::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(cocos2d::CCSprite*, float);
	static auto func = wrapFunction(base::get() + 0x267fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::ignoreAnchorPointForPosition(bool p0) -> decltype(ignoreAnchorPointForPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::ignoreAnchorPointForPosition), this);
	using FunctionType = decltype(ignoreAnchorPointForPosition(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x268330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::addChild(cocos2d::CCNode* p0) -> decltype(addChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCSprite::addChild), this);
	using FunctionType = decltype(addChild(p0))(*)(cocos2d::CCSprite*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x267980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::addChild(cocos2d::CCNode* p0, int p1) -> decltype(addChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCSprite::addChild), this);
	using FunctionType = decltype(addChild(p0, p1))(*)(cocos2d::CCSprite*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x267990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::addChild(cocos2d::CCNode* p0, int p1, int p2) -> decltype(addChild(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int, int>::func(&cocos2d::CCSprite::addChild), this);
	using FunctionType = decltype(addChild(p0, p1, p2))(*)(cocos2d::CCSprite*, cocos2d::CCNode*, int, int);
	static auto func = wrapFunction(base::get() + 0x2679a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCSprite::removeChild(cocos2d::CCNode* p0, bool p1) -> decltype(removeChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, bool>::func(&cocos2d::CCSprite::removeChild), this);
	using FunctionType = decltype(removeChild(p0, p1))(*)(cocos2d::CCSprite*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x267ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::removeAllChildrenWithCleanup(bool p0) -> decltype(removeAllChildrenWithCleanup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::removeAllChildrenWithCleanup), this);
	using FunctionType = decltype(removeAllChildrenWithCleanup(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x267b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::reorderChild(cocos2d::CCNode* p0, int p1) -> decltype(reorderChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCSprite::reorderChild), this);
	using FunctionType = decltype(reorderChild(p0, p1))(*)(cocos2d::CCSprite*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x267a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::sortAllChildren() -> decltype(sortAllChildren()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::sortAllChildren), this);
	using FunctionType = decltype(sortAllChildren())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x267be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x267860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::updateTransform() -> decltype(updateTransform()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::updateTransform), this);
	using FunctionType = decltype(updateTransform())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x2673a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&cocos2d::CCSprite::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(cocos2d::CCSprite*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x2669a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) -> decltype(initWithTexture(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&>::func(&cocos2d::CCSprite::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1))(*)(cocos2d::CCSprite*, cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x266980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) -> decltype(initWithTexture(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool>::func(&cocos2d::CCSprite::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1, p2))(*)(cocos2d::CCSprite*, cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool);
	static auto func = wrapFunction(base::get() + 0x266800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCSprite::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(initWithSpriteFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&cocos2d::CCSprite::initWithSpriteFrame), this);
	using FunctionType = decltype(initWithSpriteFrame(p0))(*)(cocos2d::CCSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x266b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::initWithSpriteFrameName(char const* p0) -> decltype(initWithSpriteFrameName(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCSprite::initWithSpriteFrameName), this);
	using FunctionType = decltype(initWithSpriteFrameName(p0))(*)(cocos2d::CCSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x266b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::initWithFile(char const* p0) -> decltype(initWithFile(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCSprite::initWithFile), this);
	using FunctionType = decltype(initWithFile(p0))(*)(cocos2d::CCSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x266a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::initWithFile(char const* p0, cocos2d::CCRect const& p1) -> decltype(initWithFile(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, cocos2d::CCRect const&>::func(&cocos2d::CCSprite::initWithFile), this);
	using FunctionType = decltype(initWithFile(p0, p1))(*)(cocos2d::CCSprite*, char const*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x266aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::setChildColor(cocos2d::_ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCSprite::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(cocos2d::CCSprite*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x268950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setChildOpacity(unsigned char p0) -> decltype(setChildOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCSprite::setChildOpacity), this);
	using FunctionType = decltype(setChildOpacity(p0))(*)(cocos2d::CCSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x268720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::getBatchNode() -> decltype(getBatchNode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::getBatchNode), this);
	using FunctionType = decltype(getBatchNode())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x269140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setBatchNode(cocos2d::CCSpriteBatchNode* p0) -> decltype(setBatchNode(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteBatchNode*>::func(&cocos2d::CCSprite::setBatchNode), this);
	using FunctionType = decltype(setBatchNode(p0))(*)(cocos2d::CCSprite*, cocos2d::CCSpriteBatchNode*);
	static auto func = wrapFunction(base::get() + 0x269150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::refreshTextureRect() -> decltype(refreshTextureRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::refreshTextureRect), this);
	using FunctionType = decltype(refreshTextureRect())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x266d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setTextureRect(cocos2d::CCRect const& p0) -> decltype(setTextureRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect const&>::func(&cocos2d::CCSprite::setTextureRect), this);
	using FunctionType = decltype(setTextureRect(p0))(*)(cocos2d::CCSprite*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x266de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setTextureRect(cocos2d::CCRect const& p0, bool p1, cocos2d::CCSize const& p2) -> decltype(setTextureRect(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect const&, bool, cocos2d::CCSize const&>::func(&cocos2d::CCSprite::setTextureRect), this);
	using FunctionType = decltype(setTextureRect(p0, p1, p2))(*)(cocos2d::CCSprite*, cocos2d::CCRect const&, bool, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x266e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCSprite::setVertexRect(cocos2d::CCRect const& p0) -> decltype(setVertexRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect const&>::func(&cocos2d::CCSprite::setVertexRect), this);
	using FunctionType = decltype(setVertexRect(p0))(*)(cocos2d::CCSprite*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x267140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setDisplayFrame(cocos2d::CCSpriteFrame* p0) -> decltype(setDisplayFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&cocos2d::CCSprite::setDisplayFrame), this);
	using FunctionType = decltype(setDisplayFrame(p0))(*)(cocos2d::CCSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x268e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::isFrameDisplayed(cocos2d::CCSpriteFrame* p0) -> decltype(isFrameDisplayed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&cocos2d::CCSprite::isFrameDisplayed), this);
	using FunctionType = decltype(isFrameDisplayed(p0))(*)(cocos2d::CCSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x268f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::displayFrame() -> decltype(displayFrame()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::displayFrame), this);
	using FunctionType = decltype(displayFrame())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x268f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setDisplayFrameWithAnimationName(char const* p0, int p1) -> decltype(setDisplayFrameWithAnimationName(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&cocos2d::CCSprite::setDisplayFrameWithAnimationName), this);
	using FunctionType = decltype(setDisplayFrameWithAnimationName(p0, p1))(*)(cocos2d::CCSprite*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x268eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCSprite::setTextureCoords(cocos2d::CCRect const& p0) -> decltype(setTextureCoords(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect const&>::func(&cocos2d::CCSprite::setTextureCoords), this);
	using FunctionType = decltype(setTextureCoords(p0))(*)(cocos2d::CCSprite*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x267160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::updateBlendFunc() -> decltype(updateBlendFunc()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::updateBlendFunc), this);
	using FunctionType = decltype(updateBlendFunc())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x2691c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setReorderChildDirtyRecursively() -> decltype(setReorderChildDirtyRecursively()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::setReorderChildDirtyRecursively), this);
	using FunctionType = decltype(setReorderChildDirtyRecursively())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x267d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setDirtyRecursively(bool p0) -> decltype(setDirtyRecursively(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::setDirtyRecursively), this);
	using FunctionType = decltype(setDirtyRecursively(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x267dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCSprite::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCSprite*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x2687d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x268570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::setOpacityModifyRGB(bool p0) -> decltype(setOpacityModifyRGB(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCSprite::setOpacityModifyRGB), this);
	using FunctionType = decltype(setOpacityModifyRGB(p0))(*)(cocos2d::CCSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x268a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::isOpacityModifyRGB() -> decltype(isOpacityModifyRGB()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::isOpacityModifyRGB), this);
	using FunctionType = decltype(isOpacityModifyRGB())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x268b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::updateDisplayedColor(cocos2d::_ccColor3B const& p0) -> decltype(updateDisplayedColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCSprite::updateDisplayedColor), this);
	using FunctionType = decltype(updateDisplayedColor(p0))(*)(cocos2d::CCSprite*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x268b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::updateDisplayedOpacity(unsigned char p0) -> decltype(updateDisplayedOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCSprite::updateDisplayedOpacity), this);
	using FunctionType = decltype(updateDisplayedOpacity(p0))(*)(cocos2d::CCSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x268cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSprite::getTexture() -> decltype(getTexture()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCSprite::getTexture), this);
	using FunctionType = decltype(getTexture())(*)(cocos2d::CCSprite*);
	static auto func = wrapFunction(base::get() + 0x269390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCSprite::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&cocos2d::CCSprite::setTexture), this);
	using FunctionType = decltype(setTexture(p0))(*)(cocos2d::CCSprite*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x269220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCParticleSystem::initWithDictionary(cocos2d::CCDictionary* p0, char const* p1, bool p2) -> decltype(initWithDictionary(p0, p1, p2)) {
	using FunctionType = decltype(initWithDictionary(p0, p1, p2))(*)(cocos2d::CCParticleSystem*, cocos2d::CCDictionary*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x7838d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCParticleSystem::initWithDictionary(cocos2d::CCDictionary* p0, bool p1) -> decltype(initWithDictionary(p0, p1)) {
	using FunctionType = decltype(initWithDictionary(p0, p1))(*)(cocos2d::CCParticleSystem*, cocos2d::CCDictionary*, bool);
	static auto func = wrapFunction(base::get() + 0x7850b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCParticleSystem::loadScaledDefaults(float p0) -> decltype(loadScaledDefaults(p0)) {
	using FunctionType = decltype(loadScaledDefaults(p0))(*)(cocos2d::CCParticleSystem*, float);
	static auto func = wrapFunction(base::get() + 0x787f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCParticleSystem::resetSystem() -> decltype(resetSystem()) {
	using FunctionType = decltype(resetSystem())(*)(cocos2d::CCParticleSystem*);
	static auto func = wrapFunction(base::get() + 0x7865e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCParticleSystem::resumeSystem() -> decltype(resumeSystem()) {
	using FunctionType = decltype(resumeSystem())(*)(cocos2d::CCParticleSystem*);
	static auto func = wrapFunction(base::get() + 0x7865d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCParticleSystem::stopSystem() -> decltype(stopSystem()) {
	using FunctionType = decltype(stopSystem())(*)(cocos2d::CCParticleSystem*);
	static auto func = wrapFunction(base::get() + 0x7865a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCParticleSystem::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::update not implemented");
}

auto cocos2d::CCParticleSystem::init() -> decltype(init()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::init not implemented");
}

auto cocos2d::CCParticleSystem::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setScaleX not implemented");
}

auto cocos2d::CCParticleSystem::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setScaleY not implemented");
}

auto cocos2d::CCParticleSystem::setScale(float p0) -> decltype(setScale(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setScale not implemented");
}

auto cocos2d::CCParticleSystem::setRotation(float p0) -> decltype(setRotation(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRotation not implemented");
}

auto cocos2d::CCParticleSystem::getBatchNode() -> decltype(getBatchNode()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getBatchNode not implemented");
}

auto cocos2d::CCParticleSystem::setBatchNode(cocos2d::CCParticleBatchNode* p0) -> decltype(setBatchNode(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setBatchNode not implemented");
}

auto cocos2d::CCParticleSystem::getParticleCount() -> decltype(getParticleCount()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getParticleCount not implemented");
}

auto cocos2d::CCParticleSystem::getDuration() -> decltype(getDuration()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getDuration not implemented");
}

auto cocos2d::CCParticleSystem::setDuration(float p0) -> decltype(setDuration(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setDuration not implemented");
}

auto cocos2d::CCParticleSystem::getSourcePosition() -> decltype(getSourcePosition()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getSourcePosition not implemented");
}

auto cocos2d::CCParticleSystem::setSourcePosition(cocos2d::CCPoint const& p0) -> decltype(setSourcePosition(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setSourcePosition not implemented");
}

auto cocos2d::CCParticleSystem::getPosVar() -> decltype(getPosVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getPosVar not implemented");
}

auto cocos2d::CCParticleSystem::setPosVar(cocos2d::CCPoint const& p0) -> decltype(setPosVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setPosVar not implemented");
}

auto cocos2d::CCParticleSystem::getLife() -> decltype(getLife()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getLife not implemented");
}

auto cocos2d::CCParticleSystem::setLife(float p0) -> decltype(setLife(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setLife not implemented");
}

auto cocos2d::CCParticleSystem::getLifeVar() -> decltype(getLifeVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getLifeVar not implemented");
}

auto cocos2d::CCParticleSystem::setLifeVar(float p0) -> decltype(setLifeVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setLifeVar not implemented");
}

auto cocos2d::CCParticleSystem::getAngle() -> decltype(getAngle()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getAngle not implemented");
}

auto cocos2d::CCParticleSystem::setAngle(float p0) -> decltype(setAngle(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setAngle not implemented");
}

auto cocos2d::CCParticleSystem::getAngleVar() -> decltype(getAngleVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getAngleVar not implemented");
}

auto cocos2d::CCParticleSystem::setAngleVar(float p0) -> decltype(setAngleVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setAngleVar not implemented");
}

auto cocos2d::CCParticleSystem::updateEmissionRate() -> decltype(updateEmissionRate()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::updateEmissionRate not implemented");
}

auto cocos2d::CCParticleSystem::getGravity() -> decltype(getGravity()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getGravity not implemented");
}

auto cocos2d::CCParticleSystem::setGravity(cocos2d::CCPoint const& p0) -> decltype(setGravity(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setGravity not implemented");
}

auto cocos2d::CCParticleSystem::getSpeed() -> decltype(getSpeed()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getSpeed not implemented");
}

auto cocos2d::CCParticleSystem::setSpeed(float p0) -> decltype(setSpeed(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setSpeed not implemented");
}

auto cocos2d::CCParticleSystem::getSpeedVar() -> decltype(getSpeedVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getSpeedVar not implemented");
}

auto cocos2d::CCParticleSystem::setSpeedVar(float p0) -> decltype(setSpeedVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setSpeedVar not implemented");
}

auto cocos2d::CCParticleSystem::getTangentialAccel() -> decltype(getTangentialAccel()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getTangentialAccel not implemented");
}

auto cocos2d::CCParticleSystem::setTangentialAccel(float p0) -> decltype(setTangentialAccel(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setTangentialAccel not implemented");
}

auto cocos2d::CCParticleSystem::getTangentialAccelVar() -> decltype(getTangentialAccelVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getTangentialAccelVar not implemented");
}

auto cocos2d::CCParticleSystem::setTangentialAccelVar(float p0) -> decltype(setTangentialAccelVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setTangentialAccelVar not implemented");
}

auto cocos2d::CCParticleSystem::getRadialAccel() -> decltype(getRadialAccel()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRadialAccel not implemented");
}

auto cocos2d::CCParticleSystem::setRadialAccel(float p0) -> decltype(setRadialAccel(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRadialAccel not implemented");
}

auto cocos2d::CCParticleSystem::getRadialAccelVar() -> decltype(getRadialAccelVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRadialAccelVar not implemented");
}

auto cocos2d::CCParticleSystem::setRadialAccelVar(float p0) -> decltype(setRadialAccelVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRadialAccelVar not implemented");
}

auto cocos2d::CCParticleSystem::getRotationIsDir() -> decltype(getRotationIsDir()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRotationIsDir not implemented");
}

auto cocos2d::CCParticleSystem::setRotationIsDir(bool p0) -> decltype(setRotationIsDir(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRotationIsDir not implemented");
}

auto cocos2d::CCParticleSystem::getStartRadius() -> decltype(getStartRadius()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartRadius not implemented");
}

auto cocos2d::CCParticleSystem::setStartRadius(float p0) -> decltype(setStartRadius(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartRadius not implemented");
}

auto cocos2d::CCParticleSystem::getStartRadiusVar() -> decltype(getStartRadiusVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartRadiusVar not implemented");
}

auto cocos2d::CCParticleSystem::setStartRadiusVar(float p0) -> decltype(setStartRadiusVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartRadiusVar not implemented");
}

auto cocos2d::CCParticleSystem::getEndRadius() -> decltype(getEndRadius()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndRadius not implemented");
}

auto cocos2d::CCParticleSystem::setEndRadius(float p0) -> decltype(setEndRadius(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndRadius not implemented");
}

auto cocos2d::CCParticleSystem::getEndRadiusVar() -> decltype(getEndRadiusVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndRadiusVar not implemented");
}

auto cocos2d::CCParticleSystem::setEndRadiusVar(float p0) -> decltype(setEndRadiusVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndRadiusVar not implemented");
}

auto cocos2d::CCParticleSystem::getRotatePerSecond() -> decltype(getRotatePerSecond()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRotatePerSecond not implemented");
}

auto cocos2d::CCParticleSystem::setRotatePerSecond(float p0) -> decltype(setRotatePerSecond(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRotatePerSecond not implemented");
}

auto cocos2d::CCParticleSystem::getRotatePerSecondVar() -> decltype(getRotatePerSecondVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getRotatePerSecondVar not implemented");
}

auto cocos2d::CCParticleSystem::setRotatePerSecondVar(float p0) -> decltype(setRotatePerSecondVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setRotatePerSecondVar not implemented");
}

auto cocos2d::CCParticleSystem::isActive() -> decltype(isActive()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::isActive not implemented");
}

auto cocos2d::CCParticleSystem::isBlendAdditive() -> decltype(isBlendAdditive()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::isBlendAdditive not implemented");
}

auto cocos2d::CCParticleSystem::setBlendAdditive(bool p0) -> decltype(setBlendAdditive(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setBlendAdditive not implemented");
}

auto cocos2d::CCParticleSystem::getStartSize() -> decltype(getStartSize()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartSize not implemented");
}

auto cocos2d::CCParticleSystem::setStartSize(float p0) -> decltype(setStartSize(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartSize not implemented");
}

auto cocos2d::CCParticleSystem::getStartSizeVar() -> decltype(getStartSizeVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartSizeVar not implemented");
}

auto cocos2d::CCParticleSystem::setStartSizeVar(float p0) -> decltype(setStartSizeVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartSizeVar not implemented");
}

auto cocos2d::CCParticleSystem::getEndSize() -> decltype(getEndSize()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndSize not implemented");
}

auto cocos2d::CCParticleSystem::setEndSize(float p0) -> decltype(setEndSize(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndSize not implemented");
}

auto cocos2d::CCParticleSystem::getEndSizeVar() -> decltype(getEndSizeVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndSizeVar not implemented");
}

auto cocos2d::CCParticleSystem::setEndSizeVar(float p0) -> decltype(setEndSizeVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndSizeVar not implemented");
}

auto cocos2d::CCParticleSystem::getStartColor() -> decltype(getStartColor()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartColor not implemented");
}

auto cocos2d::CCParticleSystem::setStartColor(cocos2d::_ccColor4F const& p0) -> decltype(setStartColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4F const&>::func(&cocos2d::CCParticleSystem::setStartColor), this);
	using FunctionType = decltype(setStartColor(p0))(*)(cocos2d::CCParticleSystem*, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x787b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCParticleSystem::getStartColorVar() -> decltype(getStartColorVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartColorVar not implemented");
}

auto cocos2d::CCParticleSystem::setStartColorVar(cocos2d::_ccColor4F const& p0) -> decltype(setStartColorVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartColorVar not implemented");
}

auto cocos2d::CCParticleSystem::getEndColor() -> decltype(getEndColor()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndColor not implemented");
}

auto cocos2d::CCParticleSystem::setEndColor(cocos2d::_ccColor4F const& p0) -> decltype(setEndColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor4F const&>::func(&cocos2d::CCParticleSystem::setEndColor), this);
	using FunctionType = decltype(setEndColor(p0))(*)(cocos2d::CCParticleSystem*, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x787b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCParticleSystem::getEndColorVar() -> decltype(getEndColorVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndColorVar not implemented");
}

auto cocos2d::CCParticleSystem::setEndColorVar(cocos2d::_ccColor4F const& p0) -> decltype(setEndColorVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndColorVar not implemented");
}

auto cocos2d::CCParticleSystem::getStartSpin() -> decltype(getStartSpin()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartSpin not implemented");
}

auto cocos2d::CCParticleSystem::setStartSpin(float p0) -> decltype(setStartSpin(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartSpin not implemented");
}

auto cocos2d::CCParticleSystem::getStartSpinVar() -> decltype(getStartSpinVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getStartSpinVar not implemented");
}

auto cocos2d::CCParticleSystem::setStartSpinVar(float p0) -> decltype(setStartSpinVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setStartSpinVar not implemented");
}

auto cocos2d::CCParticleSystem::getEndSpin() -> decltype(getEndSpin()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndSpin not implemented");
}

auto cocos2d::CCParticleSystem::setEndSpin(float p0) -> decltype(setEndSpin(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndSpin not implemented");
}

auto cocos2d::CCParticleSystem::getEndSpinVar() -> decltype(getEndSpinVar()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEndSpinVar not implemented");
}

auto cocos2d::CCParticleSystem::setEndSpinVar(float p0) -> decltype(setEndSpinVar(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEndSpinVar not implemented");
}

auto cocos2d::CCParticleSystem::getEmissionRate() -> decltype(getEmissionRate()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEmissionRate not implemented");
}

auto cocos2d::CCParticleSystem::setEmissionRate(float p0) -> decltype(setEmissionRate(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEmissionRate not implemented");
}

auto cocos2d::CCParticleSystem::getTotalParticles() -> decltype(getTotalParticles()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getTotalParticles not implemented");
}

auto cocos2d::CCParticleSystem::setTotalParticles(unsigned int p0) -> decltype(setTotalParticles(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setTotalParticles not implemented");
}

auto cocos2d::CCParticleSystem::getOpacityModifyRGB() -> decltype(getOpacityModifyRGB()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getOpacityModifyRGB not implemented");
}

auto cocos2d::CCParticleSystem::setOpacityModifyRGB(bool p0) -> decltype(setOpacityModifyRGB(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setOpacityModifyRGB not implemented");
}

auto cocos2d::CCParticleSystem::getPositionType() -> decltype(getPositionType()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getPositionType not implemented");
}

auto cocos2d::CCParticleSystem::setPositionType(cocos2d::tCCPositionType p0) -> decltype(setPositionType(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setPositionType not implemented");
}

auto cocos2d::CCParticleSystem::isAutoRemoveOnFinish() -> decltype(isAutoRemoveOnFinish()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::isAutoRemoveOnFinish not implemented");
}

auto cocos2d::CCParticleSystem::setAutoRemoveOnFinish(bool p0) -> decltype(setAutoRemoveOnFinish(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setAutoRemoveOnFinish not implemented");
}

auto cocos2d::CCParticleSystem::getEmitterMode() -> decltype(getEmitterMode()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getEmitterMode not implemented");
}

auto cocos2d::CCParticleSystem::setEmitterMode(int p0) -> decltype(setEmitterMode(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setEmitterMode not implemented");
}

auto cocos2d::CCParticleSystem::initWithTotalParticles(unsigned int p0, bool p1) -> decltype(initWithTotalParticles(p0, p1)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::initWithTotalParticles not implemented");
}

auto cocos2d::CCParticleSystem::updateQuadWithParticle(cocos2d::sCCParticle* p0, cocos2d::CCPoint const& p1) -> decltype(updateQuadWithParticle(p0, p1)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::updateQuadWithParticle not implemented");
}

auto cocos2d::CCParticleSystem::postStep() -> decltype(postStep()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::postStep not implemented");
}

auto cocos2d::CCParticleSystem::updateWithNoTime() -> decltype(updateWithNoTime()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::updateWithNoTime not implemented");
}

auto cocos2d::CCParticleSystem::updateBlendFunc() -> decltype(updateBlendFunc()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::updateBlendFunc not implemented");
}

auto cocos2d::CCParticleSystem::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setBlendFunc not implemented");
}

auto cocos2d::CCParticleSystem::getBlendFunc() -> decltype(getBlendFunc()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getBlendFunc not implemented");
}

auto cocos2d::CCParticleSystem::getTexture() -> decltype(getTexture()) {
	throw std::runtime_error("cocos2d::CCParticleSystem::getTexture not implemented");
}

auto cocos2d::CCParticleSystem::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystem::setTexture not implemented");
}

auto cocos2d::CCShaderCache::sharedShaderCache() -> decltype(sharedShaderCache()) {
	using FunctionType = decltype(sharedShaderCache())(*)();
	static auto func = wrapFunction(base::get() + 0x1e0f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCShaderCache::programForKey(char const* p0) -> decltype(programForKey(p0)) {
	using FunctionType = decltype(programForKey(p0))(*)(cocos2d::CCShaderCache*, char const*);
	static auto func = wrapFunction(base::get() + 0x1e1e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTexture2D::PVRImagesHavePremultipliedAlpha(bool p0) -> decltype(PVRImagesHavePremultipliedAlpha(p0)) {
	using FunctionType = decltype(PVRImagesHavePremultipliedAlpha(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x457000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCTexture2D::setDefaultAlphaPixelFormat(cocos2d::CCTexture2DPixelFormat p0) -> decltype(setDefaultAlphaPixelFormat(p0)) {
	using FunctionType = decltype(setDefaultAlphaPixelFormat(p0))(*)(cocos2d::CCTexture2DPixelFormat);
	static auto func = wrapFunction(base::get() + 0x4571c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCTexture2D::initPremultipliedATextureWithImage(cocos2d::CCImage* p0, unsigned int p1, unsigned int p2) -> decltype(initPremultipliedATextureWithImage(p0, p1, p2)) {
	using FunctionType = decltype(initPremultipliedATextureWithImage(p0, p1, p2))(*)(cocos2d::CCTexture2D*, cocos2d::CCImage*, unsigned int, unsigned int);
	static auto func = wrapFunction(base::get() + 0x456180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCTexture2D::initWithData(void const* p0, cocos2d::CCTexture2DPixelFormat p1, unsigned int p2, unsigned int p3, cocos2d::CCSize const& p4) -> decltype(initWithData(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(initWithData(p0, p1, p2, p3, p4))(*)(cocos2d::CCTexture2D*, void const*, cocos2d::CCTexture2DPixelFormat, unsigned int, unsigned int, cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x455dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCTexture2D::initWithImage(cocos2d::CCImage* p0) -> decltype(initWithImage(p0)) {
	using FunctionType = decltype(initWithImage(p0))(*)(cocos2d::CCTexture2D*, cocos2d::CCImage*);
	static auto func = wrapFunction(base::get() + 0x456120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCTexture2D::setAliasTexParameters() -> decltype(setAliasTexParameters()) {
	using FunctionType = decltype(setAliasTexParameters())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x4570f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::setTexParameters(cocos2d::_ccTexParams* p0) -> decltype(setTexParameters(p0)) {
	using FunctionType = decltype(setTexParameters(p0))(*)(cocos2d::CCTexture2D*, cocos2d::_ccTexParams*);
	static auto func = wrapFunction(base::get() + 0x457060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCTexture2D::~CCTexture2D() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCTexture2D(geode::CutoffConstructor, sizeof(cocos2d::CCTexture2D));
	CCDestructor::lock(this) = true;
}

cocos2d::CCTexture2D::CCTexture2D() {
	using FunctionType = void(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCTexture2D::getPixelFormat() -> decltype(getPixelFormat()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getPixelFormat), this);
	using FunctionType = decltype(getPixelFormat())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getPixelsWide() -> decltype(getPixelsWide()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getPixelsWide), this);
	using FunctionType = decltype(getPixelsWide())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getPixelsHigh() -> decltype(getPixelsHigh()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getPixelsHigh), this);
	using FunctionType = decltype(getPixelsHigh())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getName() -> decltype(getName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getName), this);
	using FunctionType = decltype(getName())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getMaxS() -> decltype(getMaxS()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getMaxS), this);
	using FunctionType = decltype(getMaxS())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::setMaxS(float p0) -> decltype(setMaxS(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCTexture2D::setMaxS), this);
	using FunctionType = decltype(setMaxS(p0))(*)(cocos2d::CCTexture2D*, float);
	static auto func = wrapFunction(base::get() + 0x455ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCTexture2D::getMaxT() -> decltype(getMaxT()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getMaxT), this);
	using FunctionType = decltype(getMaxT())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::setMaxT(float p0) -> decltype(setMaxT(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCTexture2D::setMaxT), this);
	using FunctionType = decltype(setMaxT(p0))(*)(cocos2d::CCTexture2D*, float);
	static auto func = wrapFunction(base::get() + 0x455d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCTexture2D::getContentSize() -> decltype(getContentSize()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getContentSize), this);
	using FunctionType = decltype(getContentSize())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::getShaderProgram() -> decltype(getShaderProgram()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTexture2D::getShaderProgram), this);
	using FunctionType = decltype(getShaderProgram())(*)(cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x455d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTexture2D::setShaderProgram(cocos2d::CCGLProgram* p0) -> decltype(setShaderProgram(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCGLProgram*>::func(&cocos2d::CCTexture2D::setShaderProgram), this);
	using FunctionType = decltype(setShaderProgram(p0))(*)(cocos2d::CCTexture2D*, cocos2d::CCGLProgram*);
	static auto func = wrapFunction(base::get() + 0x455d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCSpriteFrame::getTexture() -> decltype(getTexture()) {
	using FunctionType = decltype(getTexture())(*)(cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x337280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCSpriteFrame::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCSpriteFrame::copyWithZone not implemented");
}

cocos2d::CCLabelBMFont::~CCLabelBMFont() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59d2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCLabelBMFont(geode::CutoffConstructor, sizeof(cocos2d::CCLabelBMFont));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCLabelBMFont::create(char const* p0, char const* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x59cc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCLabelBMFont::create(char const* p0, char const* p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x59cbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto cocos2d::CCLabelBMFont::create(char const* p0, char const* p1, float p2, cocos2d::CCTextAlignment p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(char const*, char const*, float, cocos2d::CCTextAlignment);
	static auto func = wrapFunction(base::get() + 0x59ca60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto cocos2d::CCLabelBMFont::create(char const* p0, char const* p1, float p2, cocos2d::CCTextAlignment p3, cocos2d::CCPoint p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(char const*, char const*, float, cocos2d::CCTextAlignment, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x59cb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto cocos2d::CCLabelBMFont::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x59c9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCLabelBMFont::createBatched(char const* p0, char const* p1, cocos2d::CCArray* p2, int p3) -> decltype(createBatched(p0, p1, p2, p3)) {
	using FunctionType = decltype(createBatched(p0, p1, p2, p3))(*)(char const*, char const*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x59cfe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto cocos2d::CCLabelBMFont::initWithString(char const* p0, char const* p1, float p2, cocos2d::CCTextAlignment p3, cocos2d::CCPoint p4) -> decltype(initWithString(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(initWithString(p0, p1, p2, p3, p4))(*)(cocos2d::CCLabelBMFont*, char const*, char const*, float, cocos2d::CCTextAlignment, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x59cd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCLabelBMFont::setFntFile(char const* p0) -> decltype(setFntFile(p0)) {
	using FunctionType = decltype(setFntFile(p0))(*)(cocos2d::CCLabelBMFont*, char const*);
	static auto func = wrapFunction(base::get() + 0x5a0890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCLabelBMFont::createFontChars() -> decltype(createFontChars()) {
	using FunctionType = decltype(createFontChars())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59d440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCLabelBMFont::limitLabelWidth(float p0, float p1, float p2) -> decltype(limitLabelWidth(p0, p1, p2)) {
	using FunctionType = decltype(limitLabelWidth(p0, p1, p2))(*)(cocos2d::CCLabelBMFont*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x5a09b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCLabelBMFont::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59d090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCLabelBMFont::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(cocos2d::CCLabelBMFont*, float);
	static auto func = wrapFunction(base::get() + 0x5a0850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCLabelBMFont::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(cocos2d::CCLabelBMFont*, float);
	static auto func = wrapFunction(base::get() + 0x5a0870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCLabelBMFont::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(cocos2d::CCLabelBMFont*, float);
	static auto func = wrapFunction(base::get() + 0x5a0830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setAnchorPoint(cocos2d::CCPoint const& p0) -> decltype(setAnchorPoint(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&cocos2d::CCLabelBMFont::setAnchorPoint), this);
	using FunctionType = decltype(setAnchorPoint(p0))(*)(cocos2d::CCLabelBMFont*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x59e910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setString(char const* p0, bool p1) -> decltype(setString(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, bool>::func(&cocos2d::CCLabelBMFont::setString), this);
	using FunctionType = decltype(setString(p0, p1))(*)(cocos2d::CCLabelBMFont*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x59de40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLabelBMFont::setCString(char const* p0) -> decltype(setCString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCLabelBMFont::setCString), this);
	using FunctionType = decltype(setCString(p0))(*)(cocos2d::CCLabelBMFont*, char const*);
	static auto func = wrapFunction(base::get() + 0x59e0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::updateLabel() -> decltype(updateLabel()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::updateLabel), this);
	using FunctionType = decltype(updateLabel())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59e950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setAlignment(cocos2d::CCTextAlignment p0) -> decltype(setAlignment(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextAlignment>::func(&cocos2d::CCLabelBMFont::setAlignment), this);
	using FunctionType = decltype(setAlignment(p0))(*)(cocos2d::CCLabelBMFont*, cocos2d::CCTextAlignment);
	static auto func = wrapFunction(base::get() + 0x5a07d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setWidth(float p0) -> decltype(setWidth(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::CCLabelBMFont::setWidth), this);
	using FunctionType = decltype(setWidth(p0))(*)(cocos2d::CCLabelBMFont*, float);
	static auto func = wrapFunction(base::get() + 0x5a07f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setLineBreakWithoutSpace(bool p0) -> decltype(setLineBreakWithoutSpace(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLabelBMFont::setLineBreakWithoutSpace), this);
	using FunctionType = decltype(setLineBreakWithoutSpace(p0))(*)(cocos2d::CCLabelBMFont*, bool);
	static auto func = wrapFunction(base::get() + 0x5a0810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setString(unsigned short* p0, bool p1) -> decltype(setString(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned short*, bool>::func(&cocos2d::CCLabelBMFont::setString), this);
	using FunctionType = decltype(setString(p0, p1))(*)(cocos2d::CCLabelBMFont*, unsigned short*, bool);
	static auto func = wrapFunction(base::get() + 0x59dec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCLabelBMFont::setString(char const* p0) -> decltype(setString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCLabelBMFont::setString), this);
	using FunctionType = decltype(setString(p0))(*)(cocos2d::CCLabelBMFont*, char const*);
	static auto func = wrapFunction(base::get() + 0x59ddf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::getString() -> decltype(getString()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getString), this);
	using FunctionType = decltype(getString())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59e090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLabelBMFont::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(cocos2d::CCLabelBMFont*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x59e140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::getColor() -> decltype(getColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getColor), this);
	using FunctionType = decltype(getColor())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59e100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::getDisplayedColor() -> decltype(getDisplayedColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getDisplayedColor), this);
	using FunctionType = decltype(getDisplayedColor())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59e120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::getDisplayedOpacity() -> decltype(getDisplayedOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getDisplayedOpacity), this);
	using FunctionType = decltype(getDisplayedOpacity())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59e2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::getOpacity() -> decltype(getOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::getOpacity), this);
	using FunctionType = decltype(getOpacity())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59e2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLabelBMFont::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(cocos2d::CCLabelBMFont*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x59e2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::setOpacityModifyRGB(bool p0) -> decltype(setOpacityModifyRGB(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLabelBMFont::setOpacityModifyRGB), this);
	using FunctionType = decltype(setOpacityModifyRGB(p0))(*)(cocos2d::CCLabelBMFont*, bool);
	static auto func = wrapFunction(base::get() + 0x59e430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::isOpacityModifyRGB() -> decltype(isOpacityModifyRGB()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::isOpacityModifyRGB), this);
	using FunctionType = decltype(isOpacityModifyRGB())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59e5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::isCascadeColorEnabled() -> decltype(isCascadeColorEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::isCascadeColorEnabled), this);
	using FunctionType = decltype(isCascadeColorEnabled())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59e890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setCascadeColorEnabled(bool p0) -> decltype(setCascadeColorEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLabelBMFont::setCascadeColorEnabled), this);
	using FunctionType = decltype(setCascadeColorEnabled(p0))(*)(cocos2d::CCLabelBMFont*, bool);
	static auto func = wrapFunction(base::get() + 0x59e8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::updateDisplayedColor(cocos2d::_ccColor3B const& p0) -> decltype(updateDisplayedColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&cocos2d::CCLabelBMFont::updateDisplayedColor), this);
	using FunctionType = decltype(updateDisplayedColor(p0))(*)(cocos2d::CCLabelBMFont*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x59e6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::isCascadeOpacityEnabled() -> decltype(isCascadeOpacityEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCLabelBMFont::isCascadeOpacityEnabled), this);
	using FunctionType = decltype(isCascadeOpacityEnabled())(*)(cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x59e8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCLabelBMFont::setCascadeOpacityEnabled(bool p0) -> decltype(setCascadeOpacityEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCLabelBMFont::setCascadeOpacityEnabled), this);
	using FunctionType = decltype(setCascadeOpacityEnabled(p0))(*)(cocos2d::CCLabelBMFont*, bool);
	static auto func = wrapFunction(base::get() + 0x59e8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCLabelBMFont::updateDisplayedOpacity(unsigned char p0) -> decltype(updateDisplayedOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&cocos2d::CCLabelBMFont::updateDisplayedOpacity), this);
	using FunctionType = decltype(updateDisplayedOpacity(p0))(*)(cocos2d::CCLabelBMFont*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x59e5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCActionManager::addAction(cocos2d::CCAction* p0, cocos2d::CCNode* p1, bool p2) -> decltype(addAction(p0, p1, p2)) {
	using FunctionType = decltype(addAction(p0, p1, p2))(*)(cocos2d::CCActionManager*, cocos2d::CCAction*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x212f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto cocos2d::CCActionManager::pauseTarget(cocos2d::CCObject* p0) -> decltype(pauseTarget(p0)) {
	using FunctionType = decltype(pauseTarget(p0))(*)(cocos2d::CCActionManager*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x212c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCActionManager::removeActionByTag(unsigned int p0, cocos2d::CCObject* p1) -> decltype(removeActionByTag(p0, p1)) {
	using FunctionType = decltype(removeActionByTag(p0, p1))(*)(cocos2d::CCActionManager*, unsigned int, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x213640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCActionManager::resumeTarget(cocos2d::CCObject* p0) -> decltype(resumeTarget(p0)) {
	using FunctionType = decltype(resumeTarget(p0))(*)(cocos2d::CCActionManager*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x212d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCActionManager::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCActionManager::update not implemented");
}

auto cocos2d::CCApplication::sharedApplication() -> decltype(sharedApplication()) {
	using FunctionType = decltype(sharedApplication())(*)();
	static auto func = wrapFunction(base::get() + 0x3065c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCApplication::openURL(char const* p0) -> decltype(openURL(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&cocos2d::CCApplication::openURL), this);
	using FunctionType = decltype(openURL(p0))(*)(cocos2d::CCApplication*, char const*);
	static auto func = wrapFunction(base::get() + 0x307350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCArray::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x6e3140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCArray::createWithCapacity(unsigned int p0) -> decltype(createWithCapacity(p0)) {
	using FunctionType = decltype(createWithCapacity(p0))(*)(unsigned int);
	static auto func = wrapFunction(base::get() + 0x6e3450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCArray::createWithObject(cocos2d::CCObject* p0) -> decltype(createWithObject(p0)) {
	using FunctionType = decltype(createWithObject(p0))(*)(cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6e31e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCArray::init() -> decltype(init()) {
	using FunctionType = decltype(init())(*)(cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x6e2fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCArray::initWithCapacity(unsigned int p0) -> decltype(initWithCapacity(p0)) {
	using FunctionType = decltype(initWithCapacity(p0))(*)(cocos2d::CCArray*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x6e30b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCArray::addObject(cocos2d::CCObject* p0) -> decltype(addObject(p0)) {
	using FunctionType = decltype(addObject(p0))(*)(cocos2d::CCArray*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6e3420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCArray::insertObject(cocos2d::CCObject* p0, unsigned int p1) -> decltype(insertObject(p0, p1)) {
	using FunctionType = decltype(insertObject(p0, p1))(*)(cocos2d::CCArray*, cocos2d::CCObject*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x6e3930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCArray::lastObject() -> decltype(lastObject()) {
	using FunctionType = decltype(lastObject())(*)(cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x6e3810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCArray::objectAtIndex(unsigned int p0) -> decltype(objectAtIndex(p0)) {
	using FunctionType = decltype(objectAtIndex(p0))(*)(cocos2d::CCArray*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x6e37f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCArray::removeAllObjects() -> decltype(removeAllObjects()) {
	using FunctionType = decltype(removeAllObjects())(*)(cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x6e39b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCArray::removeLastObject(bool p0) -> decltype(removeLastObject(p0)) {
	using FunctionType = decltype(removeLastObject(p0))(*)(cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x6e3940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCArray::removeObject(cocos2d::CCObject* p0, bool p1) -> decltype(removeObject(p0, p1)) {
	using FunctionType = decltype(removeObject(p0, p1))(*)(cocos2d::CCArray*, cocos2d::CCObject*, bool);
	static auto func = wrapFunction(base::get() + 0x6e3960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCArray::removeObjectAtIndex(unsigned p0, bool p1) -> decltype(removeObjectAtIndex(p0, p1)) {
	using FunctionType = decltype(removeObjectAtIndex(p0, p1))(*)(cocos2d::CCArray*, unsigned, bool);
	static auto func = wrapFunction(base::get() + 0x6e3970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCArray::removeObjectAtIndexChild(unsigned p0, bool p1) -> decltype(removeObjectAtIndexChild(p0, p1)) {
	using FunctionType = decltype(removeObjectAtIndexChild(p0, p1))(*)(cocos2d::CCArray*, unsigned, bool);
	static auto func = wrapFunction(base::get() + 0x6e3980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCArray::stringAtIndex(unsigned int p0) -> decltype(stringAtIndex(p0)) {
	using FunctionType = decltype(stringAtIndex(p0))(*)(cocos2d::CCArray*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x6e37d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCArray::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCArray::copyWithZone not implemented");
}

auto cocos2d::CCArray::acceptVisitor(cocos2d::CCDataVisitor& p0) -> decltype(acceptVisitor(p0)) {
	throw std::runtime_error("cocos2d::CCArray::acceptVisitor not implemented");
}

auto cocos2d::CCBlink::create(float p0, unsigned int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, unsigned int);
	static auto func = wrapFunction(base::get() + 0x398730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCBlink::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCBlink::copyWithZone not implemented");
}

auto cocos2d::CCBlink::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCBlink::update not implemented");
}

auto cocos2d::CCBlink::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCBlink::startWithTarget not implemented");
}

auto cocos2d::CCBlink::stop() -> decltype(stop()) {
	throw std::runtime_error("cocos2d::CCBlink::stop not implemented");
}

auto cocos2d::CCBlink::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCBlink::reverse not implemented");
}

auto cocos2d::CCDictionary::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2ed090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCDictionary::createWithContentsOfFileThreadSafe(char const* p0) -> decltype(createWithContentsOfFileThreadSafe(p0)) {
	using FunctionType = decltype(createWithContentsOfFileThreadSafe(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x2ed110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCDictionary::setObject(cocos2d::CCObject* p0, gd::string const& p1) -> decltype(setObject(p0, p1)) {
	using FunctionType = decltype(setObject(p0, p1))(*)(cocos2d::CCDictionary*, cocos2d::CCObject*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x2eb7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCDictionary::setObject(cocos2d::CCObject* p0, intptr_t p1) -> decltype(setObject(p0, p1)) {
	using FunctionType = decltype(setObject(p0, p1))(*)(cocos2d::CCDictionary*, cocos2d::CCObject*, intptr_t);
	static auto func = wrapFunction(base::get() + 0x2ec120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCDictionary::allKeys() -> decltype(allKeys()) {
	using FunctionType = decltype(allKeys())(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x2eaef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDictionary::count() -> decltype(count()) {
	using FunctionType = decltype(count())(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x2eaed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDictionary::objectForKey(gd::string const& p0) -> decltype(objectForKey(p0)) {
	using FunctionType = decltype(objectForKey(p0))(*)(cocos2d::CCDictionary*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x2eb260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDictionary::objectForKey(intptr_t p0) -> decltype(objectForKey(p0)) {
	using FunctionType = decltype(objectForKey(p0))(*)(cocos2d::CCDictionary*, intptr_t);
	static auto func = wrapFunction(base::get() + 0x2eb5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDictionary::removeAllObjects() -> decltype(removeAllObjects()) {
	using FunctionType = decltype(removeAllObjects())(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x2eacf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDictionary::removeObjectForElememt(cocos2d::CCDictElement* p0) -> decltype(removeObjectForElememt(p0)) {
	using FunctionType = decltype(removeObjectForElememt(p0))(*)(cocos2d::CCDictionary*, cocos2d::CCDictElement*);
	static auto func = wrapFunction(base::get() + 0x2ec9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDictionary::removeObjectForKey(gd::string const& p0) -> decltype(removeObjectForKey(p0)) {
	using FunctionType = decltype(removeObjectForKey(p0))(*)(cocos2d::CCDictionary*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x2ec630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDictionary::removeObjectForKey(intptr_t p0) -> decltype(removeObjectForKey(p0)) {
	using FunctionType = decltype(removeObjectForKey(p0))(*)(cocos2d::CCDictionary*, intptr_t);
	static auto func = wrapFunction(base::get() + 0x2ecb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDictionary::valueForKey(gd::string const& p0) -> decltype(valueForKey(p0)) {
	using FunctionType = decltype(valueForKey(p0))(*)(cocos2d::CCDictionary*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x2eb1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCDictionary::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCDictionary::copyWithZone not implemented");
}

auto cocos2d::CCDictionary::acceptVisitor(cocos2d::CCDataVisitor& p0) -> decltype(acceptVisitor(p0)) {
	throw std::runtime_error("cocos2d::CCDictionary::acceptVisitor not implemented");
}

auto cocos2d::ZipUtils::base64URLEncode(gd::string const& p0) -> decltype(base64URLEncode(p0)) {
	using FunctionType = decltype(base64URLEncode(p0))(*)(gd::string const&);
	static auto func = wrapFunction(base::get() + 0x1e4960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::ZipUtils::ccDeflateMemory(unsigned char* p0, unsigned int p1, unsigned char** p2) -> decltype(ccDeflateMemory(p0, p1, p2)) {
	using FunctionType = decltype(ccDeflateMemory(p0, p1, p2))(*)(unsigned char*, unsigned int, unsigned char**);
	static auto func = wrapFunction(base::get() + 0x1e3e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto cocos2d::ZipUtils::compressString(gd::string const& string, bool p1, int p2) -> decltype(compressString(string, p1, p2)) {
	using FunctionType = decltype(compressString(string, p1, p2))(*)(gd::string const&, bool, int);
	static auto func = wrapFunction(base::get() + 0x1e3c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(string, p1, p2);
}

auto cocos2d::ZipUtils::decompressString(gd::string const& p0, bool p1, int p2) -> decltype(decompressString(p0, p1, p2)) {
	using FunctionType = decltype(decompressString(p0, p1, p2))(*)(gd::string const&, bool, int);
	static auto func = wrapFunction(base::get() + 0x1e4290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto cocos2d::CCDelayTime::create(float p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(float);
	static auto func = wrapFunction(base::get() + 0x395330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCDelayTime::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCDelayTime::copyWithZone not implemented");
}

auto cocos2d::CCDelayTime::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCDelayTime::update not implemented");
}

auto cocos2d::CCDelayTime::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCDelayTime::reverse not implemented");
}

auto cocos2d::CCScaleBy::create(float p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, float);
	static auto func = wrapFunction(base::get() + 0x398370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCScaleBy::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCScaleBy::copyWithZone not implemented");
}

auto cocos2d::CCScaleBy::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCScaleBy::startWithTarget not implemented");
}

auto cocos2d::CCScaleBy::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCScaleBy::reverse not implemented");
}

auto cocos2d::CCSequence::create(cocos2d::CCArray* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x393ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCSequence::createWithVariableList(cocos2d::CCFiniteTimeAction* p0, va_list p1) -> decltype(createWithVariableList(p0, p1)) {
	using FunctionType = decltype(createWithVariableList(p0, p1))(*)(cocos2d::CCFiniteTimeAction*, va_list);
	static auto func = wrapFunction(base::get() + 0x3937f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCSequence::copyWithZone(cocos2d::CCZone* p0) -> decltype(copyWithZone(p0)) {
	throw std::runtime_error("cocos2d::CCSequence::copyWithZone not implemented");
}

auto cocos2d::CCSequence::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCSequence::update not implemented");
}

auto cocos2d::CCSequence::startWithTarget(cocos2d::CCNode* p0) -> decltype(startWithTarget(p0)) {
	throw std::runtime_error("cocos2d::CCSequence::startWithTarget not implemented");
}

auto cocos2d::CCSequence::stop() -> decltype(stop()) {
	throw std::runtime_error("cocos2d::CCSequence::stop not implemented");
}

auto cocos2d::CCSequence::reverse() -> decltype(reverse()) {
	throw std::runtime_error("cocos2d::CCSequence::reverse not implemented");
}

auto cocos2d::CCMenuItemSprite::create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x39e290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto cocos2d::CCMenuItemSprite::initWithNormalSprite(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCNode* p2, cocos2d::CCObject* p3, cocos2d::SEL_MenuHandler p4) -> decltype(initWithNormalSprite(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(initWithNormalSprite(p0, p1, p2, p3, p4))(*)(cocos2d::CCMenuItemSprite*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x39e2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCMenuItemSprite::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::selected), this);
	using FunctionType = decltype(selected())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x39e3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::unselected() -> decltype(unselected()) {
	throw std::runtime_error("cocos2d::CCMenuItemSprite::unselected not implemented");
}

auto cocos2d::CCMenuItemSprite::setEnabled(bool p0) -> decltype(setEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCMenuItemSprite::setEnabled), this);
	using FunctionType = decltype(setEnabled(p0))(*)(cocos2d::CCMenuItemSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x39e4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItemSprite::getNormalImage() -> decltype(getNormalImage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::getNormalImage), this);
	using FunctionType = decltype(getNormalImage())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x39def0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::setNormalImage(cocos2d::CCNode* p0) -> decltype(setNormalImage(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCMenuItemSprite::setNormalImage), this);
	using FunctionType = decltype(setNormalImage(p0))(*)(cocos2d::CCMenuItemSprite*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x39df00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItemSprite::getSelectedImage() -> decltype(getSelectedImage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::getSelectedImage), this);
	using FunctionType = decltype(getSelectedImage())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x39dfc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::setSelectedImage(cocos2d::CCNode* p0) -> decltype(setSelectedImage(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCMenuItemSprite::setSelectedImage), this);
	using FunctionType = decltype(setSelectedImage(p0))(*)(cocos2d::CCMenuItemSprite*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x39dfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItemSprite::getDisabledImage() -> decltype(getDisabledImage()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::getDisabledImage), this);
	using FunctionType = decltype(getDisabledImage())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x39e060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItemSprite::setDisabledImage(cocos2d::CCNode* p0) -> decltype(setDisabledImage(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCMenuItemSprite::setDisabledImage), this);
	using FunctionType = decltype(setDisabledImage(p0))(*)(cocos2d::CCMenuItemSprite*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x39e070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItemSprite::updateImagesVisibility() -> decltype(updateImagesVisibility()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItemSprite::updateImagesVisibility), this);
	using FunctionType = decltype(updateImagesVisibility())(*)(cocos2d::CCMenuItemSprite*);
	static auto func = wrapFunction(base::get() + 0x39e4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

cocos2d::CCMenuItem::~CCMenuItem() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x39cc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCMenuItem(geode::CutoffConstructor, sizeof(cocos2d::CCMenuItem));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCMenuItem::initWithTarget(cocos2d::CCObject* p0, cocos2d::SEL_MenuHandler p1) -> decltype(initWithTarget(p0, p1)) {
	using FunctionType = decltype(initWithTarget(p0, p1))(*)(cocos2d::CCMenuItem*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x39cb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCMenuItem::setTarget(cocos2d::CCObject* p0, cocos2d::SEL_MenuHandler p1) -> decltype(setTarget(p0, p1)) {
	using FunctionType = decltype(setTarget(p0, p1))(*)(cocos2d::CCMenuItem*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x39ce70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto cocos2d::CCMenuItem::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::activate), this);
	using FunctionType = decltype(activate())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x39cd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::selected), this);
	using FunctionType = decltype(selected())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x39ccf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::unselected), this);
	using FunctionType = decltype(unselected())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x39cd00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::registerScriptTapHandler(int p0) -> decltype(registerScriptTapHandler(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&cocos2d::CCMenuItem::registerScriptTapHandler), this);
	using FunctionType = decltype(registerScriptTapHandler(p0))(*)(cocos2d::CCMenuItem*, int);
	static auto func = wrapFunction(base::get() + 0x39cd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItem::unregisterScriptTapHandler() -> decltype(unregisterScriptTapHandler()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::unregisterScriptTapHandler), this);
	using FunctionType = decltype(unregisterScriptTapHandler())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x39cd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::isEnabled() -> decltype(isEnabled()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::isEnabled), this);
	using FunctionType = decltype(isEnabled())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x39ce00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenuItem::setEnabled(bool p0) -> decltype(setEnabled(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::CCMenuItem::setEnabled), this);
	using FunctionType = decltype(setEnabled(p0))(*)(cocos2d::CCMenuItem*, bool);
	static auto func = wrapFunction(base::get() + 0x39cdf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenuItem::isSelected() -> decltype(isSelected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenuItem::isSelected), this);
	using FunctionType = decltype(isSelected())(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x39ce60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3d7240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::extension::CCScale9Sprite::createWithSpriteFrameName(char const* p0) -> decltype(createWithSpriteFrameName(p0)) {
	using FunctionType = decltype(createWithSpriteFrameName(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3d7120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::extension::CCScale9Sprite::createWithSpriteFrameName(char const* p0, cocos2d::CCRect p1) -> decltype(createWithSpriteFrameName(p0, p1)) {
	using FunctionType = decltype(createWithSpriteFrameName(p0, p1))(*)(char const*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d7040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::extension::CCScale9Sprite::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x3d6d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::extension::CCScale9Sprite::create(char const* p0, cocos2d::CCRect p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d6bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

cocos2d::extension::CCScale9Sprite::CCScale9Sprite() {
	using FunctionType = void(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d5160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::extension::CCScale9Sprite::~CCScale9Sprite() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d5340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::extension::CCScale9Sprite(geode::CutoffConstructor, sizeof(cocos2d::extension::CCScale9Sprite));
	CCDestructor::lock(this) = true;
}

auto cocos2d::extension::CCScale9Sprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d5370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setContentSize(const cocos2d::CCSize& size) -> decltype(setContentSize(size)) {
	auto self = addresser::thunkAdjust(Resolve<const cocos2d::CCSize&>::func(&cocos2d::extension::CCScale9Sprite::setContentSize), this);
	using FunctionType = decltype(setContentSize(size))(*)(cocos2d::extension::CCScale9Sprite*, const cocos2d::CCSize&);
	static auto func = wrapFunction(base::get() + 0x3d6500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, size);
}

auto cocos2d::extension::CCScale9Sprite::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::visit), this);
	using FunctionType = decltype(visit())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d7890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::getOpacity() -> decltype(getOpacity()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getOpacity), this);
	using FunctionType = decltype(getOpacity())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d7be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setOpacity(GLubyte opacity) -> decltype(setOpacity(opacity)) {
	auto self = addresser::thunkAdjust(Resolve<GLubyte>::func(&cocos2d::extension::CCScale9Sprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(opacity))(*)(cocos2d::extension::CCScale9Sprite*, GLubyte);
	static auto func = wrapFunction(base::get() + 0x3d7a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, opacity);
}

auto cocos2d::extension::CCScale9Sprite::updateDisplayedOpacity(GLubyte parentOpacity) -> decltype(updateDisplayedOpacity(parentOpacity)) {
	auto self = addresser::thunkAdjust(Resolve<GLubyte>::func(&cocos2d::extension::CCScale9Sprite::updateDisplayedOpacity), this);
	using FunctionType = decltype(updateDisplayedOpacity(parentOpacity))(*)(cocos2d::extension::CCScale9Sprite*, GLubyte);
	static auto func = wrapFunction(base::get() + 0x3d7660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, parentOpacity);
}

auto cocos2d::extension::CCScale9Sprite::getColor() -> decltype(getColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getColor), this);
	using FunctionType = decltype(getColor())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d7a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setColor(const cocos2d::ccColor3B& color) -> decltype(setColor(color)) {
	auto self = addresser::thunkAdjust(Resolve<const cocos2d::ccColor3B&>::func(&cocos2d::extension::CCScale9Sprite::setColor), this);
	using FunctionType = decltype(setColor(color))(*)(cocos2d::extension::CCScale9Sprite*, const cocos2d::ccColor3B&);
	static auto func = wrapFunction(base::get() + 0x3d78c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, color);
}

auto cocos2d::extension::CCScale9Sprite::updateDisplayedColor(const cocos2d::ccColor3B& parentColor) -> decltype(updateDisplayedColor(parentColor)) {
	auto self = addresser::thunkAdjust(Resolve<const cocos2d::ccColor3B&>::func(&cocos2d::extension::CCScale9Sprite::updateDisplayedColor), this);
	using FunctionType = decltype(updateDisplayedColor(parentColor))(*)(cocos2d::extension::CCScale9Sprite*, const cocos2d::ccColor3B&);
	static auto func = wrapFunction(base::get() + 0x3d76d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, parentColor);
}

auto cocos2d::extension::CCScale9Sprite::setOpacityModifyRGB(bool bValue) -> decltype(setOpacityModifyRGB(bValue)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&cocos2d::extension::CCScale9Sprite::setOpacityModifyRGB), this);
	using FunctionType = decltype(setOpacityModifyRGB(bValue))(*)(cocos2d::extension::CCScale9Sprite*, bool);
	static auto func = wrapFunction(base::get() + 0x3d74e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, bValue);
}

auto cocos2d::extension::CCScale9Sprite::isOpacityModifyRGB() -> decltype(isOpacityModifyRGB()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::isOpacityModifyRGB), this);
	using FunctionType = decltype(isOpacityModifyRGB())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d7640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::getPreferredSize() -> decltype(getPreferredSize()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getPreferredSize), this);
	using FunctionType = decltype(getPreferredSize())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d72d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setPreferredSize(cocos2d::CCSize p0) -> decltype(setPreferredSize(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSize>::func(&cocos2d::extension::CCScale9Sprite::setPreferredSize), this);
	using FunctionType = decltype(setPreferredSize(p0))(*)(cocos2d::extension::CCScale9Sprite*, cocos2d::CCSize);
	static auto func = wrapFunction(base::get() + 0x3d72a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::getCapInsets() -> decltype(getCapInsets()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getCapInsets), this);
	using FunctionType = decltype(getCapInsets())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d7390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setCapInsets(cocos2d::CCRect p0) -> decltype(setCapInsets(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect>::func(&cocos2d::extension::CCScale9Sprite::setCapInsets), this);
	using FunctionType = decltype(setCapInsets(p0))(*)(cocos2d::extension::CCScale9Sprite*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d72f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::getInsetLeft() -> decltype(getInsetLeft()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getInsetLeft), this);
	using FunctionType = decltype(getInsetLeft())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d77d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setInsetLeft(float p0) -> decltype(setInsetLeft(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::extension::CCScale9Sprite::setInsetLeft), this);
	using FunctionType = decltype(setInsetLeft(p0))(*)(cocos2d::extension::CCScale9Sprite*, float);
	static auto func = wrapFunction(base::get() + 0x3d7810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::getInsetTop() -> decltype(getInsetTop()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getInsetTop), this);
	using FunctionType = decltype(getInsetTop())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d77e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setInsetTop(float p0) -> decltype(setInsetTop(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::extension::CCScale9Sprite::setInsetTop), this);
	using FunctionType = decltype(setInsetTop(p0))(*)(cocos2d::extension::CCScale9Sprite*, float);
	static auto func = wrapFunction(base::get() + 0x3d7830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::getInsetRight() -> decltype(getInsetRight()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getInsetRight), this);
	using FunctionType = decltype(getInsetRight())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d77f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setInsetRight(float p0) -> decltype(setInsetRight(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::extension::CCScale9Sprite::setInsetRight), this);
	using FunctionType = decltype(setInsetRight(p0))(*)(cocos2d::extension::CCScale9Sprite*, float);
	static auto func = wrapFunction(base::get() + 0x3d7850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::getInsetBottom() -> decltype(getInsetBottom()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::extension::CCScale9Sprite::getInsetBottom), this);
	using FunctionType = decltype(getInsetBottom())(*)(cocos2d::extension::CCScale9Sprite*);
	static auto func = wrapFunction(base::get() + 0x3d7800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::extension::CCScale9Sprite::setInsetBottom(float p0) -> decltype(setInsetBottom(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&cocos2d::extension::CCScale9Sprite::setInsetBottom), this);
	using FunctionType = decltype(setInsetBottom(p0))(*)(cocos2d::extension::CCScale9Sprite*, float);
	static auto func = wrapFunction(base::get() + 0x3d7870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::initWithBatchNode(cocos2d::CCSpriteBatchNode* p0, cocos2d::CCRect p1, bool p2, cocos2d::CCRect p3) -> decltype(initWithBatchNode(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect>::func(&cocos2d::extension::CCScale9Sprite::initWithBatchNode), this);
	using FunctionType = decltype(initWithBatchNode(p0, p1, p2, p3))(*)(cocos2d::extension::CCScale9Sprite*, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d5430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto cocos2d::extension::CCScale9Sprite::initWithBatchNode(cocos2d::CCSpriteBatchNode* p0, cocos2d::CCRect p1, cocos2d::CCRect p2) -> decltype(initWithBatchNode(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, cocos2d::CCRect>::func(&cocos2d::extension::CCScale9Sprite::initWithBatchNode), this);
	using FunctionType = decltype(initWithBatchNode(p0, p1, p2))(*)(cocos2d::extension::CCScale9Sprite*, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d53d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::extension::CCScale9Sprite::initWithFile(const char* p0, cocos2d::CCRect p1, cocos2d::CCRect p2) -> decltype(initWithFile(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<const char*, cocos2d::CCRect, cocos2d::CCRect>::func(&cocos2d::extension::CCScale9Sprite::initWithFile), this);
	using FunctionType = decltype(initWithFile(p0, p1, p2))(*)(cocos2d::extension::CCScale9Sprite*, const char*, cocos2d::CCRect, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d6a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::extension::CCScale9Sprite::initWithFile(const char* p0, cocos2d::CCRect p1) -> decltype(initWithFile(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<const char*, cocos2d::CCRect>::func(&cocos2d::extension::CCScale9Sprite::initWithFile), this);
	using FunctionType = decltype(initWithFile(p0, p1))(*)(cocos2d::extension::CCScale9Sprite*, const char*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d6b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::extension::CCScale9Sprite::initWithFile(cocos2d::CCRect p0, const char* p1) -> decltype(initWithFile(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect, const char*>::func(&cocos2d::extension::CCScale9Sprite::initWithFile), this);
	using FunctionType = decltype(initWithFile(p0, p1))(*)(cocos2d::extension::CCScale9Sprite*, cocos2d::CCRect, const char*);
	static auto func = wrapFunction(base::get() + 0x3d6c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::extension::CCScale9Sprite::initWithFile(const char* p0) -> decltype(initWithFile(p0)) {
	auto self = addresser::thunkAdjust(Resolve<const char*>::func(&cocos2d::extension::CCScale9Sprite::initWithFile), this);
	using FunctionType = decltype(initWithFile(p0))(*)(cocos2d::extension::CCScale9Sprite*, const char*);
	static auto func = wrapFunction(base::get() + 0x3d6d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0, cocos2d::CCRect p1) -> decltype(initWithSpriteFrame(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*, cocos2d::CCRect>::func(&cocos2d::extension::CCScale9Sprite::initWithSpriteFrame), this);
	using FunctionType = decltype(initWithSpriteFrame(p0, p1))(*)(cocos2d::extension::CCScale9Sprite*, cocos2d::CCSpriteFrame*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d6e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::extension::CCScale9Sprite::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(initWithSpriteFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&cocos2d::extension::CCScale9Sprite::initWithSpriteFrame), this);
	using FunctionType = decltype(initWithSpriteFrame(p0))(*)(cocos2d::extension::CCScale9Sprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x3d6f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::initWithSpriteFrameName(const char* p0, cocos2d::CCRect p1) -> decltype(initWithSpriteFrameName(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<const char*, cocos2d::CCRect>::func(&cocos2d::extension::CCScale9Sprite::initWithSpriteFrameName), this);
	using FunctionType = decltype(initWithSpriteFrameName(p0, p1))(*)(cocos2d::extension::CCScale9Sprite*, const char*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d6fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::extension::CCScale9Sprite::initWithSpriteFrameName(const char* p0) -> decltype(initWithSpriteFrameName(p0)) {
	auto self = addresser::thunkAdjust(Resolve<const char*>::func(&cocos2d::extension::CCScale9Sprite::initWithSpriteFrameName), this);
	using FunctionType = decltype(initWithSpriteFrameName(p0))(*)(cocos2d::extension::CCScale9Sprite*, const char*);
	static auto func = wrapFunction(base::get() + 0x3d70d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCScale9Sprite::updateWithBatchNode(cocos2d::CCSpriteBatchNode* p0, cocos2d::CCRect p1, bool p2, cocos2d::CCRect p3) -> decltype(updateWithBatchNode(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect>::func(&cocos2d::extension::CCScale9Sprite::updateWithBatchNode), this);
	using FunctionType = decltype(updateWithBatchNode(p0, p1, p2, p3))(*)(cocos2d::extension::CCScale9Sprite*, cocos2d::CCSpriteBatchNode*, cocos2d::CCRect, bool, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x3d54d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto cocos2d::extension::CCScale9Sprite::setSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(setSpriteFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&cocos2d::extension::CCScale9Sprite::setSpriteFrame), this);
	using FunctionType = decltype(setSpriteFrame(p0))(*)(cocos2d::extension::CCScale9Sprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x3d7740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::extension::CCControlColourPicker::colourPicker() -> decltype(colourPicker()) {
	using FunctionType = decltype(colourPicker())(*)();
	static auto func = wrapFunction(base::get() + 0x334940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCTransitionFade::create(float p0, cocos2d::CCScene* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0xd4dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCTransitionFade::create(float p0, cocos2d::CCScene* p1, cocos2d::_ccColor3B const& p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(float, cocos2d::CCScene*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0xd4cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto cocos2d::CCTransitionFade::onEnter() -> decltype(onEnter()) {
	throw std::runtime_error("cocos2d::CCTransitionFade::onEnter not implemented");
}

auto cocos2d::CCTransitionFade::onExit() -> decltype(onExit()) {
	throw std::runtime_error("cocos2d::CCTransitionFade::onExit not implemented");
}

auto cocos2d::CCTransitionFade::initWithDuration(float p0, cocos2d::CCScene* p1) -> decltype(initWithDuration(p0, p1)) {
	throw std::runtime_error("cocos2d::CCTransitionFade::initWithDuration not implemented");
}

auto cocos2d::CCTransitionFade::initWithDuration(float p0, cocos2d::CCScene* p1, cocos2d::_ccColor3B const& p2) -> decltype(initWithDuration(p0, p1, p2)) {
	throw std::runtime_error("cocos2d::CCTransitionFade::initWithDuration not implemented");
}

auto cocos2d::CCMenu::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x754580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCMenu::createWithArray(cocos2d::CCArray* p0) -> decltype(createWithArray(p0)) {
	using FunctionType = decltype(createWithArray(p0))(*)(cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x754780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCMenu::createWithItem(cocos2d::CCMenuItem* p0) -> decltype(createWithItem(p0)) {
	using FunctionType = decltype(createWithItem(p0))(*)(cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x7549d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::CCMenu::initWithArray(cocos2d::CCArray* p0) -> decltype(initWithArray(p0)) {
	using FunctionType = decltype(initWithArray(p0))(*)(cocos2d::CCMenu*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x754850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCMenu::setHandlerPriority(int p0) -> decltype(setHandlerPriority(p0)) {
	using FunctionType = decltype(setHandlerPriority(p0))(*)(cocos2d::CCMenu*, int);
	static auto func = wrapFunction(base::get() + 0x754b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCMenu::alignItemsHorizontallyWithPadding(float p0) -> decltype(alignItemsHorizontallyWithPadding(p0)) {
	using FunctionType = decltype(alignItemsHorizontallyWithPadding(p0))(*)(cocos2d::CCMenu*, float);
	static auto func = wrapFunction(base::get() + 0x7551f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCMenu::alignItemsVerticallyWithPadding(float p0) -> decltype(alignItemsVerticallyWithPadding(p0)) {
	using FunctionType = decltype(alignItemsVerticallyWithPadding(p0))(*)(cocos2d::CCMenu*, float);
	static auto func = wrapFunction(base::get() + 0x754fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCMenu::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenu::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCMenu*);
	static auto func = wrapFunction(base::get() + 0x7549e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenu::addChild(cocos2d::CCNode* p0) -> decltype(addChild(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&cocos2d::CCMenu::addChild), this);
	using FunctionType = decltype(addChild(p0))(*)(cocos2d::CCMenu*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x7549f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto cocos2d::CCMenu::addChild(cocos2d::CCNode* p0, int p1) -> decltype(addChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int>::func(&cocos2d::CCMenu::addChild), this);
	using FunctionType = decltype(addChild(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCNode*, int);
	static auto func = wrapFunction(base::get() + 0x754a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::addChild(cocos2d::CCNode* p0, int p1, int p2) -> decltype(addChild(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, int, int>::func(&cocos2d::CCMenu::addChild), this);
	using FunctionType = decltype(addChild(p0, p1, p2))(*)(cocos2d::CCMenu*, cocos2d::CCNode*, int, int);
	static auto func = wrapFunction(base::get() + 0x754a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto cocos2d::CCMenu::removeChild(cocos2d::CCNode* p0, bool p1) -> decltype(removeChild(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*, bool>::func(&cocos2d::CCMenu::removeChild), this);
	using FunctionType = decltype(removeChild(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCNode*, bool);
	static auto func = wrapFunction(base::get() + 0x754ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenu::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCMenu*);
	static auto func = wrapFunction(base::get() + 0x754a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenu::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCMenu::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(cocos2d::CCMenu*);
	static auto func = wrapFunction(base::get() + 0x754b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCMenu::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCMenu::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x754bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCMenu::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x754e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCMenu::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x754d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCMenu::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&cocos2d::CCMenu::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(cocos2d::CCMenu*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x754e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::FNTConfigLoadFile(char const* p0) -> decltype(FNTConfigLoadFile(p0)) {
	using FunctionType = decltype(FNTConfigLoadFile(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x59a1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::__CCPointApplyAffineTransform(cocos2d::CCPoint const& p0, cocos2d::CCAffineTransform const& p1) -> decltype(__CCPointApplyAffineTransform(p0, p1)) {
	using FunctionType = decltype(__CCPointApplyAffineTransform(p0, p1))(*)(cocos2d::CCPoint const&, cocos2d::CCAffineTransform const&);
	static auto func = wrapFunction(base::get() + 0x21f1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::ccDrawColor4B(unsigned char p0, unsigned char p1, unsigned char p2, unsigned char p3) -> decltype(ccDrawColor4B(p0, p1, p2, p3)) {
	using FunctionType = decltype(ccDrawColor4B(p0, p1, p2, p3))(*)(unsigned char, unsigned char, unsigned char, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1e8870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto cocos2d::ccDrawLine(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1) -> decltype(ccDrawLine(p0, p1)) {
	using FunctionType = decltype(ccDrawLine(p0, p1))(*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x1e7020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::ccDrawSolidRect(cocos2d::CCPoint p0, cocos2d::CCPoint p1, cocos2d::_ccColor4F p2) -> decltype(ccDrawSolidRect(p0, p1, p2)) {
	using FunctionType = decltype(ccDrawSolidRect(p0, p1, p2))(*)(cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor4F);
	static auto func = wrapFunction(base::get() + 0x1e7250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto cocos2d::ccGLBindTexture2D(unsigned int p0) -> decltype(ccGLBindTexture2D(p0)) {
	using FunctionType = decltype(ccGLBindTexture2D(p0))(*)(unsigned int);
	static auto func = wrapFunction(base::get() + 0x33a420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::ccGLBlendFunc(unsigned int p0, unsigned int p1) -> decltype(ccGLBlendFunc(p0, p1)) {
	using FunctionType = decltype(ccGLBlendFunc(p0, p1))(*)(unsigned int, unsigned int);
	static auto func = wrapFunction(base::get() + 0x33a370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::ccGLDeleteTexture(unsigned int p0) -> decltype(ccGLDeleteTexture(p0)) {
	using FunctionType = decltype(ccGLDeleteTexture(p0))(*)(unsigned int);
	static auto func = wrapFunction(base::get() + 0x33a4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::ccGLEnable(cocos2d::ccGLServerState p0) -> decltype(ccGLEnable(p0)) {
	using FunctionType = decltype(ccGLEnable(p0))(*)(cocos2d::ccGLServerState);
	static auto func = wrapFunction(base::get() + 0x33a540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::ccGLEnableVertexAttribs(unsigned int p0) -> decltype(ccGLEnableVertexAttribs(p0)) {
	using FunctionType = decltype(ccGLEnableVertexAttribs(p0))(*)(unsigned int);
	static auto func = wrapFunction(base::get() + 0x33a550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::ccGLUseProgram(unsigned int p0) -> decltype(ccGLUseProgram(p0)) {
	using FunctionType = decltype(ccGLUseProgram(p0))(*)(unsigned int);
	static auto func = wrapFunction(base::get() + 0x33a350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto cocos2d::ccpDistance(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1) -> decltype(ccpDistance(p0, p1)) {
	using FunctionType = decltype(ccpDistance(p0, p1))(*)(cocos2d::CCPoint const&, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x334db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::ccpFromSize(cocos2d::CCSize const& p0) -> decltype(ccpFromSize(p0)) {
	using FunctionType = decltype(ccpFromSize(p0))(*)(cocos2d::CCSize const&);
	static auto func = wrapFunction(base::get() + 0x334fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto DS_Dictionary::getArrayForKey(char const* p0, bool p1) -> decltype(getArrayForKey(p0, p1)) {
	using FunctionType = decltype(getArrayForKey(p0, p1))(*)(DS_Dictionary*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x171b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DS_Dictionary::getBoolForKey(char const* p0) -> decltype(getBoolForKey(p0)) {
	using FunctionType = decltype(getBoolForKey(p0))(*)(DS_Dictionary*, char const*);
	static auto func = wrapFunction(base::get() + 0x16e8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DS_Dictionary::getDictForKey(char const* p0, bool p1) -> decltype(getDictForKey(p0, p1)) {
	using FunctionType = decltype(getDictForKey(p0, p1))(*)(DS_Dictionary*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x172ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DS_Dictionary::getFloatForKey(char const* p0) -> decltype(getFloatForKey(p0)) {
	using FunctionType = decltype(getFloatForKey(p0))(*)(DS_Dictionary*, char const*);
	static auto func = wrapFunction(base::get() + 0x16e9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DS_Dictionary::getIntegerForKey(char const* p0) -> decltype(getIntegerForKey(p0)) {
	using FunctionType = decltype(getIntegerForKey(p0))(*)(DS_Dictionary*, char const*);
	static auto func = wrapFunction(base::get() + 0x16e7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DS_Dictionary::getKey(unsigned int p0) -> decltype(getKey(p0)) {
	using FunctionType = decltype(getKey(p0))(*)(DS_Dictionary*, unsigned int);
	static auto func = wrapFunction(base::get() + 0x16e0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DS_Dictionary::getObjectForKey(char const* p0) -> decltype(getObjectForKey(p0)) {
	using FunctionType = decltype(getObjectForKey(p0))(*)(DS_Dictionary*, char const*);
	static auto func = wrapFunction(base::get() + 0x171d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DS_Dictionary::getStringForKey(char const* p0) -> decltype(getStringForKey(p0)) {
	using FunctionType = decltype(getStringForKey(p0))(*)(DS_Dictionary*, char const*);
	static auto func = wrapFunction(base::get() + 0x16eb30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DS_Dictionary::setBoolForKey(char const* p0, bool p1) -> decltype(setBoolForKey(p0, p1)) {
	using FunctionType = decltype(setBoolForKey(p0, p1))(*)(DS_Dictionary*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x16fc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DS_Dictionary::setDictForKey(char const* p0, cocos2d::CCDictionary* p1) -> decltype(setDictForKey(p0, p1)) {
	using FunctionType = decltype(setDictForKey(p0, p1))(*)(DS_Dictionary*, char const*, cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x1721a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DS_Dictionary::setFloatForKey(char const* p0, float p1) -> decltype(setFloatForKey(p0, p1)) {
	using FunctionType = decltype(setFloatForKey(p0, p1))(*)(DS_Dictionary*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x16feb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DS_Dictionary::setIntegerForKey(char const* p0, int p1) -> decltype(setIntegerForKey(p0, p1)) {
	using FunctionType = decltype(setIntegerForKey(p0, p1))(*)(DS_Dictionary*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x16f9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DS_Dictionary::setStringForKey(char const* p0, gd::string const& p1) -> decltype(setStringForKey(p0, p1)) {
	using FunctionType = decltype(setStringForKey(p0, p1))(*)(DS_Dictionary*, char const*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x1701a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DS_Dictionary::stepIntoSubDictWithKey(char const* p0) -> decltype(stepIntoSubDictWithKey(p0)) {
	using FunctionType = decltype(stepIntoSubDictWithKey(p0))(*)(DS_Dictionary*, char const*);
	static auto func = wrapFunction(base::get() + 0x16daa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCTransitionScene::~CCTransitionScene() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd0620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCTransitionScene(geode::CutoffConstructor, sizeof(cocos2d::CCTransitionScene));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCTransitionScene::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd0a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionScene::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::onExit), this);
	using FunctionType = decltype(onExit())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd0ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionScene::cleanup() -> decltype(cleanup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::cleanup), this);
	using FunctionType = decltype(cleanup())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd0b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionScene::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd0840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCTransitionScene::initWithDuration(float p0, cocos2d::CCScene* p1) -> decltype(initWithDuration(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, cocos2d::CCScene*>::func(&cocos2d::CCTransitionScene::initWithDuration), this);
	using FunctionType = decltype(initWithDuration(p0, p1))(*)(cocos2d::CCTransitionScene*, float, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0xd07a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto cocos2d::CCTransitionScene::sceneOrder() -> decltype(sceneOrder()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCTransitionScene::sceneOrder), this);
	using FunctionType = decltype(sceneOrder())(*)(cocos2d::CCTransitionScene*);
	static auto func = wrapFunction(base::get() + 0xd0830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCDrawNode::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x5d5130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCDrawNode::setBlendFunc(cocos2d::_ccBlendFunc const& p0) -> decltype(setBlendFunc(p0)) {
	using FunctionType = decltype(setBlendFunc(p0))(*)(cocos2d::CCDrawNode*, cocos2d::_ccBlendFunc const&);
	static auto func = wrapFunction(base::get() + 0x5d6a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCDrawNode::CCDrawNode() {
	using FunctionType = void(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x5d4f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCDrawNode::~CCDrawNode() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x5d4f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCDrawNode(geode::CutoffConstructor, sizeof(cocos2d::CCDrawNode));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCDrawNode::clear() -> decltype(clear()) {
	using FunctionType = decltype(clear())(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x5d6a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto cocos2d::CCDrawNode::drawCircle(cocos2d::CCPoint const& p0, float p1, cocos2d::_ccColor4F const& p2, float p3, cocos2d::_ccColor4F const& p4, unsigned int p5) -> decltype(drawCircle(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(drawCircle(p0, p1, p2, p3, p4, p5))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint const&, float, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&, unsigned int);
	static auto func = wrapFunction(base::get() + 0x5d6920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto cocos2d::CCDrawNode::drawCubicBezier(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, cocos2d::CCPoint const& p2, cocos2d::CCPoint const& p3, unsigned int p4, cocos2d::_ccColor4F const& p5) -> decltype(drawCubicBezier(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(drawCubicBezier(p0, p1, p2, p3, p4, p5))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint const&, cocos2d::CCPoint const&, cocos2d::CCPoint const&, cocos2d::CCPoint const&, unsigned int, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x5d5950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto cocos2d::CCDrawNode::drawPolygon(cocos2d::CCPoint* p0, unsigned int p1, cocos2d::_ccColor4F const& p2, float p3, cocos2d::_ccColor4F const& p4) -> decltype(drawPolygon(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(drawPolygon(p0, p1, p2, p3, p4))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint*, unsigned int, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x5d5b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCDrawNode::drawRect(cocos2d::CCPoint const& p0, cocos2d::CCPoint const& p1, cocos2d::_ccColor4F const& p2, float p3, cocos2d::_ccColor4F const& p4) -> decltype(drawRect(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(drawRect(p0, p1, p2, p3, p4))(*)(cocos2d::CCDrawNode*, cocos2d::CCPoint const&, cocos2d::CCPoint const&, cocos2d::_ccColor4F const&, float, cocos2d::_ccColor4F const&);
	static auto func = wrapFunction(base::get() + 0x5d6780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto cocos2d::CCDrawNode::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCDrawNode::init), this);
	using FunctionType = decltype(init())(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x5d5220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCDrawNode::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&cocos2d::CCDrawNode::draw), this);
	using FunctionType = decltype(draw())(*)(cocos2d::CCDrawNode*);
	static auto func = wrapFunction(base::get() + 0x5d5410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto cocos2d::CCImage::initWithImageData(void* p0, int p1, cocos2d::CCImage::EImageFormat p2, int p3, int p4, int p5, int p6) -> decltype(initWithImageData(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(initWithImageData(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCImage*, void*, int, cocos2d::CCImage::EImageFormat, int, int, int, int);
	static auto func = wrapFunction(base::get() + 0x466190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

cocos2d::CCImage::CCImage() {
	using FunctionType = void(*)(cocos2d::CCImage*);
	static auto func = wrapFunction(base::get() + 0x465e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

cocos2d::CCImage::~CCImage() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(cocos2d::CCImage*);
	static auto func = wrapFunction(base::get() + 0x465f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) cocos2d::CCImage(geode::CutoffConstructor, sizeof(cocos2d::CCImage));
	CCDestructor::lock(this) = true;
}

auto cocos2d::CCTime::gettimeofdayCocos2d(cocos2d::cc_timeval* p0, void* p1) -> decltype(gettimeofdayCocos2d(p0, p1)) {
	using FunctionType = decltype(gettimeofdayCocos2d(p0, p1))(*)(cocos2d::cc_timeval*, void*);
	static auto func = wrapFunction(base::get() + 0x2fead0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto cocos2d::CCMotionStreak::setStroke(float p0) -> decltype(setStroke(p0)) {
	using FunctionType = decltype(setStroke(p0))(*)(cocos2d::CCMotionStreak*, float);
	static auto func = wrapFunction(base::get() + 0x5421f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCMotionStreak::updateFade(float p0) -> decltype(updateFade(p0)) {
	using FunctionType = decltype(updateFade(p0))(*)(cocos2d::CCMotionStreak*, float);
	static auto func = wrapFunction(base::get() + 0x541b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto cocos2d::CCMotionStreak::update(float p0) -> decltype(update(p0)) {
	throw std::runtime_error("cocos2d::CCMotionStreak::update not implemented");
}

auto cocos2d::CCMotionStreak::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	throw std::runtime_error("cocos2d::CCMotionStreak::setPosition not implemented");
}

auto cocos2d::CCMotionStreak::draw() -> decltype(draw()) {
	throw std::runtime_error("cocos2d::CCMotionStreak::draw not implemented");
}

auto cocos2d::CCMotionStreak::getOpacity() -> decltype(getOpacity()) {
	throw std::runtime_error("cocos2d::CCMotionStreak::getOpacity not implemented");
}

auto cocos2d::CCMotionStreak::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	throw std::runtime_error("cocos2d::CCMotionStreak::setOpacity not implemented");
}

auto cocos2d::CCMotionStreak::setOpacityModifyRGB(bool p0) -> decltype(setOpacityModifyRGB(p0)) {
	throw std::runtime_error("cocos2d::CCMotionStreak::setOpacityModifyRGB not implemented");
}

auto cocos2d::CCMotionStreak::isOpacityModifyRGB() -> decltype(isOpacityModifyRGB()) {
	throw std::runtime_error("cocos2d::CCMotionStreak::isOpacityModifyRGB not implemented");
}

auto cocos2d::CCMotionStreak::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	throw std::runtime_error("cocos2d::CCMotionStreak::setBlendFunc not implemented");
}

auto cocos2d::CCMotionStreak::getBlendFunc() -> decltype(getBlendFunc()) {
	throw std::runtime_error("cocos2d::CCMotionStreak::getBlendFunc not implemented");
}

auto cocos2d::CCMotionStreak::getTexture() -> decltype(getTexture()) {
	throw std::runtime_error("cocos2d::CCMotionStreak::getTexture not implemented");
}

auto cocos2d::CCMotionStreak::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	throw std::runtime_error("cocos2d::CCMotionStreak::setTexture not implemented");
}

auto cocos2d::CCParticleSystemQuad::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x5c7320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto cocos2d::CCParticleSystemQuad::draw() -> decltype(draw()) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::draw not implemented");
}

auto cocos2d::CCParticleSystemQuad::setBatchNode(cocos2d::CCParticleBatchNode* p0) -> decltype(setBatchNode(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::setBatchNode not implemented");
}

auto cocos2d::CCParticleSystemQuad::setTotalParticles(unsigned int p0) -> decltype(setTotalParticles(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::setTotalParticles not implemented");
}

auto cocos2d::CCParticleSystemQuad::initWithTotalParticles(unsigned int p0, bool p1) -> decltype(initWithTotalParticles(p0, p1)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::initWithTotalParticles not implemented");
}

auto cocos2d::CCParticleSystemQuad::updateQuadWithParticle(cocos2d::sCCParticle* p0, cocos2d::CCPoint const& p1) -> decltype(updateQuadWithParticle(p0, p1)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::updateQuadWithParticle not implemented");
}

auto cocos2d::CCParticleSystemQuad::postStep() -> decltype(postStep()) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::postStep not implemented");
}

auto cocos2d::CCParticleSystemQuad::setTexture(cocos2d::CCTexture2D* p0) -> decltype(setTexture(p0)) {
	throw std::runtime_error("cocos2d::CCParticleSystemQuad::setTexture not implemented");
}

FLAlertLayer::~FLAlertLayer() {
		if (m_forcePrioRegistered) {
			cocos2d::CCTouchDispatcher::get()->unregisterForcePrio(this);
		}
	}

FLAlertLayer::FLAlertLayer() {
		m_buttonMenu = nullptr;
		m_controlConnected = -1;
		m_mainLayer = nullptr;
		m_ZOrder = 0;
		m_noElasticity = false;
		m_reverseKeyBack = false;
		m_scene = nullptr;
		m_alertProtocol = nullptr;
		m_scrollingLayer = nullptr;
		m_button2 = nullptr;
		m_button1 = nullptr;
		m_joystickConnected = -1;
		m_containsBorder = 0;
		m_forcePrioRegistered = false;
	}

FLAlertLayer* FLAlertLayer::create(char const* title, const gd::string& desc, char const* btn) {
		return FLAlertLayer::create(nullptr, title, desc, btn, nullptr, 300.0);
	}

auto FLAlertLayer::create(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x476e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto FLAlertLayer::create(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x4770a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto FLAlertLayer::create(FLAlertLayerProtocol* p0, char const* p1, gd::string p2, char const* p3, char const* p4, float p5, bool p6, float p7, float p8) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x476ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto FLAlertLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FLAlertLayer*, int);
	static auto func = wrapFunction(base::get() + 0x477b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FLAlertLayer::init(FLAlertLayerProtocol* p0, char const* title, gd::string description, char const* btn1, char const* btn2, float width, bool scrollable, float height, float textScale) -> decltype(init(p0, title, description, btn1, btn2, width, scrollable, height, textScale)) {
	using FunctionType = decltype(init(p0, title, description, btn1, btn2, width, scrollable, height, textScale))(*)(FLAlertLayer*, FLAlertLayerProtocol*, char const*, gd::string, char const*, char const*, float, bool, float, float);
	static auto func = wrapFunction(base::get() + 0x477140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, title, description, btn1, btn2, width, scrollable, height, textScale);
}

auto FLAlertLayer::onBtn1(cocos2d::CCObject* sender) -> decltype(onBtn1(sender)) {
	using FunctionType = decltype(onBtn1(sender))(*)(FLAlertLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x477c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FLAlertLayer::onBtn2(cocos2d::CCObject* sender) -> decltype(onBtn2(sender)) {
	using FunctionType = decltype(onBtn2(sender))(*)(FLAlertLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x477cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FLAlertLayer::incrementForcePrio() -> decltype(incrementForcePrio()) {
	using FunctionType = decltype(incrementForcePrio())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x477c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FLAlertLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x477ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x478120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x478000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&FLAlertLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(FLAlertLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4780a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FLAlertLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x478350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x477dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&FLAlertLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(FLAlertLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x477d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FLAlertLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FLAlertLayer::show), this);
	using FunctionType = decltype(show())(*)(FLAlertLayer*);
	static auto func = wrapFunction(base::get() + 0x4781a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FLAlertLayerProtocol::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	throw std::runtime_error("FLAlertLayerProtocol::FLAlert_Clicked not implemented");
}

ButtonSprite* ButtonSprite::create(cocos2d::CCSprite* topSprite, int width, bool absolute, float height, const char* texture, float scale) {
		return create(topSprite, width, 0, height, scale, absolute, texture, true);
	}

ButtonSprite* ButtonSprite::create(const char* caption, int width, bool absolute, const char* font, const char* texture, float height, float scale) {
		return create(caption, width, 0, scale, absolute, font, texture, height);
	}

ButtonSprite* ButtonSprite::create(char const* caption) {
		return ButtonSprite::create(caption, 0, 0, "goldFont.fnt", "GJ_button_01.png", .0f, 1.f);
	}

ButtonSprite* ButtonSprite::create(char const* caption, const char* font, const char* texture) {
		return ButtonSprite::create(caption, 0, 0, font, texture, .0f, 1.f);
	}

ButtonSprite* ButtonSprite::create(char const* caption, const char* font, const char* texture, float scale) {
		return ButtonSprite::create(caption, 0, 0, font, texture, .0f, scale);
	}

auto ButtonSprite::create(char const* p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, float);
	static auto func = wrapFunction(base::get() + 0x8c590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto ButtonSprite::create(char const* p0, int p1, int p2, float p3, bool p4, char const* p5, char const* p6, float p7) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7))(*)(char const*, int, int, float, bool, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x8c5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7);
}

auto ButtonSprite::create(cocos2d::CCSprite* p0, int p1, int p2, float p3, float p4, bool p5, char const* p6, bool p7) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7))(*)(cocos2d::CCSprite*, int, int, float, float, bool, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x8bd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7);
}

auto ButtonSprite::setColor(cocos2d::ccColor3B p0) -> decltype(setColor(p0)) {
	using FunctionType = decltype(setColor(p0))(*)(ButtonSprite*, cocos2d::ccColor3B);
	static auto func = wrapFunction(base::get() + 0x8cf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ButtonSprite::setString(char const* p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(ButtonSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x8c9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ButtonSprite::updateBGImage(char const* p0) -> decltype(updateBGImage(p0)) {
	using FunctionType = decltype(updateBGImage(p0))(*)(ButtonSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x8cdd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ButtonSprite::updateSpriteOffset(cocos2d::CCPoint p0) -> decltype(updateSpriteOffset(p0)) {
	using FunctionType = decltype(updateSpriteOffset(p0))(*)(ButtonSprite*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x8cef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ScrollingLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ScrollingLayer::draw), this);
	using FunctionType = decltype(draw())(*)(ScrollingLayer*);
	static auto func = wrapFunction(base::get() + 0x6e4030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ScrollingLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ScrollingLayer::visit), this);
	using FunctionType = decltype(visit())(*)(ScrollingLayer*);
	static auto func = wrapFunction(base::get() + 0x6e4120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ScrollingLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x6e4270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ScrollingLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x6e4410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ScrollingLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x6e4530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ScrollingLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&ScrollingLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(ScrollingLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x6e4570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DialogDelegate::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("DialogDelegate::dialogClosed not implemented");
}

auto CreatorLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2752e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CreatorLayer::onMapPacks(cocos2d::CCObject* sender) -> decltype(onMapPacks(sender)) {
	using FunctionType = decltype(onMapPacks(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2769d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onMyLevels(cocos2d::CCObject* sender) -> decltype(onMyLevels(sender)) {
	using FunctionType = decltype(onMyLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onTopLists(cocos2d::CCObject* sender) -> decltype(onTopLists(sender)) {
	using FunctionType = decltype(onTopLists(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onChallenge(cocos2d::CCObject* sender) -> decltype(onChallenge(sender)) {
	using FunctionType = decltype(onChallenge(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2766b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onGauntlets(cocos2d::CCObject* sender) -> decltype(onGauntlets(sender)) {
	using FunctionType = decltype(onGauntlets(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2768a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onDailyLevel(cocos2d::CCObject* sender) -> decltype(onDailyLevel(sender)) {
	using FunctionType = decltype(onDailyLevel(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2766e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onEventLevel(cocos2d::CCObject* sender) -> decltype(onEventLevel(sender)) {
	using FunctionType = decltype(onEventLevel(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onMultiplayer(cocos2d::CCObject* sender) -> decltype(onMultiplayer(sender)) {
	using FunctionType = decltype(onMultiplayer(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onSavedLevels(cocos2d::CCObject* sender) -> decltype(onSavedLevels(sender)) {
	using FunctionType = decltype(onSavedLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onSecretVault(cocos2d::CCObject* sender) -> decltype(onSecretVault(sender)) {
	using FunctionType = decltype(onSecretVault(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onWeeklyLevel(cocos2d::CCObject* sender) -> decltype(onWeeklyLevel(sender)) {
	using FunctionType = decltype(onWeeklyLevel(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onAdventureMap(cocos2d::CCObject* sender) -> decltype(onAdventureMap(sender)) {
	using FunctionType = decltype(onAdventureMap(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onLeaderboards(cocos2d::CCObject* sender) -> decltype(onLeaderboards(sender)) {
	using FunctionType = decltype(onLeaderboards(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2762d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onOnlineLevels(cocos2d::CCObject* sender) -> decltype(onOnlineLevels(sender)) {
	using FunctionType = decltype(onOnlineLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onTreasureRoom(cocos2d::CCObject* sender) -> decltype(onTreasureRoom(sender)) {
	using FunctionType = decltype(onTreasureRoom(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x277020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onFeaturedLevels(cocos2d::CCObject* sender) -> decltype(onFeaturedLevels(sender)) {
	using FunctionType = decltype(onFeaturedLevels(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2768f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2775e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::onPaths(cocos2d::CCObject* sender) -> decltype(onPaths(sender)) {
	using FunctionType = decltype(onPaths(sender))(*)(CreatorLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x276950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreatorLayer::checkQuestsStatus() -> decltype(checkQuestsStatus()) {
	using FunctionType = decltype(checkQuestsStatus())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x276d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CreatorLayer::scene() -> decltype(scene()) {
	using FunctionType = decltype(scene())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x2751c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CreatorLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::init), this);
	using FunctionType = decltype(init())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x2753c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x277830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::sceneWillResume() -> decltype(sceneWillResume()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreatorLayer::sceneWillResume), this);
	using FunctionType = decltype(sceneWillResume())(*)(CreatorLayer*);
	static auto func = wrapFunction(base::get() + 0x2777b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreatorLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&CreatorLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(CreatorLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x2776b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto BoomScrollLayerDelegate::scrollLayerScrollingStarted(BoomScrollLayer* p0) -> decltype(scrollLayerScrollingStarted(p0)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerScrollingStarted not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerScrolledToPage not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerMoved not implemented");
}

auto BoomScrollLayerDelegate::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	throw std::runtime_error("BoomScrollLayerDelegate::scrollLayerWillScrollToPage not implemented");
}

auto LevelSelectLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x410b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSelectLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x410c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

LevelSelectLayer::~LevelSelectLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(LevelSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x4109e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) LevelSelectLayer(geode::CutoffConstructor, sizeof(LevelSelectLayer));
	CCDestructor::lock(this) = true;
}

auto LevelSelectLayer::getColorValue(int p0, int p1, float p2) -> decltype(getColorValue(p0, p1, p2)) {
	using FunctionType = decltype(getColorValue(p0, p1, p2))(*)(LevelSelectLayer*, int, int, float);
	static auto func = wrapFunction(base::get() + 0x4133f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelSelectLayer::onDownload(cocos2d::CCObject* sender) -> decltype(onDownload(sender)) {
	using FunctionType = decltype(onDownload(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x411980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x411a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x411a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onNext(cocos2d::CCObject* sender) -> decltype(onNext(sender)) {
	using FunctionType = decltype(onNext(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x411a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::onPrev(cocos2d::CCObject* sender) -> decltype(onPrev(sender)) {
	using FunctionType = decltype(onPrev(sender))(*)(LevelSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4119d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSelectLayer::scene(int p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(LevelSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x410a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x413710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSelectLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelSelectLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelSelectLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4137b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSelectLayer::updatePageWithObject(cocos2d::CCObject* p0, cocos2d::CCObject* p1) -> decltype(updatePageWithObject(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*, cocos2d::CCObject*>::func(&LevelSelectLayer::updatePageWithObject), this);
	using FunctionType = decltype(updatePageWithObject(p0, p1))(*)(LevelSelectLayer*, cocos2d::CCObject*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x411ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSelectLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&LevelSelectLayer::scrollLayerMoved), this);
	using FunctionType = decltype(scrollLayerMoved(p0))(*)(LevelSelectLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x413280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void LevelManagerDelegate::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1) {}

void LevelManagerDelegate::loadLevelsFailed(char const* p0) {}

void LevelManagerDelegate::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) {}

void LevelManagerDelegate::loadLevelsFailed(char const* p0, int p1) {}

void LevelManagerDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto GauntletLayer::init(GauntletType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletLayer*, GauntletType);
	static auto func = wrapFunction(base::get() + 0x3708e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletLayer::onLevel(cocos2d::CCObject* sender) -> decltype(onLevel(sender)) {
	using FunctionType = decltype(onLevel(sender))(*)(GauntletLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3724b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletLayer::setupGauntlet(cocos2d::CCArray* p0) -> decltype(setupGauntlet(p0)) {
	using FunctionType = decltype(setupGauntlet(p0))(*)(GauntletLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x370fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletLayer::scene(GauntletType p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(GauntletLayer*, GauntletType);
	static auto func = wrapFunction(base::get() + 0x3706f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GauntletLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GauntletLayer*);
	static auto func = wrapFunction(base::get() + 0x372af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&GauntletLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(GauntletLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x372050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GauntletLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&GauntletLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(GauntletLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x372210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void CCMenuItemSpriteExtra::useAnimationType(MenuAnimationType type) {
		m_startPosition = this->getNormalImage()->getPosition();
		m_animationType = type;
	}

void CCMenuItemSpriteExtra::setDestination(cocos2d::CCPoint const& pos) {
		m_destPosition = pos;
	}

void CCMenuItemSpriteExtra::setOffset(cocos2d::CCPoint const& pos) {
		m_offset = pos;
	}

void CCMenuItemSpriteExtra::setScale(float scale) {
		this->CCMenuItemSprite::setScale(scale);
		m_baseScale = scale;
	}

CCMenuItemSpriteExtra* CCMenuItemSpriteExtra::create(cocos2d::CCNode* sprite, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) {
		return CCMenuItemSpriteExtra::create(sprite, nullptr, target, callback);
	}

auto CCMenuItemSpriteExtra::create(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x254900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto CCMenuItemSpriteExtra::init(cocos2d::CCNode* p0, cocos2d::CCNode* p1, cocos2d::CCObject* p2, cocos2d::SEL_MenuHandler p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(CCMenuItemSpriteExtra*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x254990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

CCMenuItemSpriteExtra::~CCMenuItemSpriteExtra() {}

CCMenuItemSpriteExtra::CCMenuItemSpriteExtra() {
		m_scaleMultiplier = 1.0f;
		m_baseScale = 1.0f;
		m_animationEnabled = true;
		m_colorEnabled = false;
		m_unknown1 = 0.0f;
		m_colorDip = 0.0f;
		m_animationType = MenuAnimationType::Scale;
		m_unknown4 = 0;
	}

void CCMenuItemSpriteExtra::setSizeMult(float mult) {
		//inlined on windows, member is in CCMenuItemSprite
		m_fSizeMult = mult;
	}

auto CCMenuItemSpriteExtra::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::activate), this);
	using FunctionType = decltype(activate())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x254b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemSpriteExtra::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::selected), this);
	using FunctionType = decltype(selected())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x254c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemSpriteExtra::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemSpriteExtra::unselected), this);
	using FunctionType = decltype(unselected())(*)(CCMenuItemSpriteExtra*);
	static auto func = wrapFunction(base::get() + 0x254f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void CCMenuItemSpriteExtra::setSprite(cocos2d::CCSprite* sprite) {
		this->setNormalImage(sprite);
		this->updateSprite();
	}

void CCMenuItemSpriteExtra::updateSprite() {
		auto sprite = this->getNormalImage();
		auto size = sprite->getScaledContentSize();
		sprite->setPosition(size / 2);
		sprite->setAnchorPoint({ .5f, .5f });
		this->setContentSize(size);
	}

CCTextInputNode::CCTextInputNode() {
		m_numberInput = false;
		m_caption = "";
		m_unknown1 = 0;
		m_selected = false;
		m_unknown2 = false;
		m_fontValue1 = -0.5f;
		m_fontValue2 = 8.0f;
		m_isChatFont = false;
		m_allowedChars = "";
		m_maxLabelWidth = 0.0f;
		m_maxLabelScale = 0.0f;
		m_placeholderScale = 0.0f;
		m_placeholderColor = cocos2d::ccc3(0, 0, 0);
		m_textColor = cocos2d::ccc3(0, 0, 0);
		m_cursor = nullptr;
		m_textField = nullptr;
		m_delegate = nullptr;
		m_maxLabelLength = 0;
		m_placeholderLabel = nullptr;
		m_filterSwearWords = false;
		m_usePasswordChar = false;
		m_forceOffset = false;
		m_textArea = nullptr;
	}

void CCTextInputNode::setDelegate(TextInputDelegate* delegate) {
		m_delegate = delegate;
	}

void CCTextInputNode::setMaxLabelWidth(float v) {
		m_maxLabelWidth = v;
		this->refreshLabel();
	}

void CCTextInputNode::setMaxLabelLength(int v) {
		m_maxLabelLength = v;
		this->refreshLabel();
	}

void CCTextInputNode::setLabelPlaceholderScale(float v) {
		m_placeholderScale = v;
		this->refreshLabel();
	}

void CCTextInputNode::setLabelPlaceholderColor(cocos2d::ccColor3B color) {
		m_placeholderColor = color;
		this->refreshLabel();
	}

auto CCTextInputNode::create(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(float, float, char const*, char const*, int, char const*);
	static auto func = wrapFunction(base::get() + 0x97e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto CCTextInputNode::init(float p0, float p1, char const* p2, char const* p3, int p4, char const* p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(CCTextInputNode*, float, float, char const*, char const*, int, char const*);
	static auto func = wrapFunction(base::get() + 0x97fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

CCTextInputNode::~CCTextInputNode() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x97d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) CCTextInputNode(geode::CutoffConstructor, sizeof(CCTextInputNode));
	CCDestructor::lock(this) = true;
}

auto CCTextInputNode::getString() -> decltype(getString()) {
	using FunctionType = decltype(getString())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x98980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCTextInputNode::setAllowedChars(gd::string p0) -> decltype(setAllowedChars(p0)) {
	using FunctionType = decltype(setAllowedChars(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x98860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::setString(gd::string p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x988e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::addTextArea(TextArea* p0) -> decltype(addTextArea(p0)) {
	using FunctionType = decltype(addTextArea(p0))(*)(CCTextInputNode*, TextArea*);
	static auto func = wrapFunction(base::get() + 0x98350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::forceOffset() -> decltype(forceOffset()) {
	using FunctionType = decltype(forceOffset())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x9a490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCTextInputNode::updateLabel(gd::string p0) -> decltype(updateLabel(p0)) {
	using FunctionType = decltype(updateLabel(p0))(*)(CCTextInputNode*, gd::string);
	static auto func = wrapFunction(base::get() + 0x98560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCTextInputNode::refreshLabel() -> decltype(refreshLabel()) {
	using FunctionType = decltype(refreshLabel())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x98a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCTextInputNode::updateCursorPosition(cocos2d::CCPoint p0, cocos2d::CCRect p1) -> decltype(updateCursorPosition(p0, p1)) {
	using FunctionType = decltype(updateCursorPosition(p0, p1))(*)(CCTextInputNode*, cocos2d::CCPoint, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x9a4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCTextInputNode::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::visit), this);
	using FunctionType = decltype(visit())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x98880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCTextInputNode::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x9a9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCTextInputNode::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCTextInputNode::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x9ac00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCTextInputNode::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCTextInputNode::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x9abc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCTextInputNode::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCTextInputNode::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CCTextInputNode*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x9abe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCTextInputNode::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x9ac20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::textChanged() -> decltype(textChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCTextInputNode::textChanged), this);
	using FunctionType = decltype(textChanged())(*)(CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x993a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCTextInputNode::onClickTrackNode(bool p0) -> decltype(onClickTrackNode(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCTextInputNode::onClickTrackNode), this);
	using FunctionType = decltype(onClickTrackNode(p0))(*)(CCTextInputNode*, bool);
	static auto func = wrapFunction(base::get() + 0x99380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::keyboardWillShow(cocos2d::CCIMEKeyboardNotificationInfo& p0) -> decltype(keyboardWillShow(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCIMEKeyboardNotificationInfo&>::func(&CCTextInputNode::keyboardWillShow), this);
	using FunctionType = decltype(keyboardWillShow(p0))(*)(CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
	static auto func = wrapFunction(base::get() + 0x99120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::keyboardWillHide(cocos2d::CCIMEKeyboardNotificationInfo& p0) -> decltype(keyboardWillHide(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCIMEKeyboardNotificationInfo&>::func(&CCTextInputNode::keyboardWillHide), this);
	using FunctionType = decltype(keyboardWillHide(p0))(*)(CCTextInputNode*, cocos2d::CCIMEKeyboardNotificationInfo&);
	static auto func = wrapFunction(base::get() + 0x99270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::onTextFieldInsertText(cocos2d::CCTextFieldTTF* p0, char const* p1, int p2, cocos2d::enumKeyCodes p3) -> decltype(onTextFieldInsertText(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*, char const*, int, cocos2d::enumKeyCodes>::func(&CCTextInputNode::onTextFieldInsertText), this);
	using FunctionType = decltype(onTextFieldInsertText(p0, p1, p2, p3))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*, char const*, int, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x994b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto CCTextInputNode::onTextFieldAttachWithIME(cocos2d::CCTextFieldTTF* p0) -> decltype(onTextFieldAttachWithIME(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*>::func(&CCTextInputNode::onTextFieldAttachWithIME), this);
	using FunctionType = decltype(onTextFieldAttachWithIME(p0))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*);
	static auto func = wrapFunction(base::get() + 0x99a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCTextInputNode::onTextFieldDetachWithIME(cocos2d::CCTextFieldTTF* p0) -> decltype(onTextFieldDetachWithIME(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTextFieldTTF*>::func(&CCTextInputNode::onTextFieldDetachWithIME), this);
	using FunctionType = decltype(onTextFieldDetachWithIME(p0))(*)(CCTextInputNode*, cocos2d::CCTextFieldTTF*);
	static auto func = wrapFunction(base::get() + 0x99d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextArea::create(gd::string p0, char const* p1, float p2, float p3, cocos2d::CCPoint p4, float p5, bool p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(gd::string, char const*, float, float, cocos2d::CCPoint, float, bool);
	static auto func = wrapFunction(base::get() + 0x2fecb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto TextArea::init(gd::string p0, char const* p1, float p2, float p3, cocos2d::CCPoint p4, float p5, bool p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(TextArea*, gd::string, char const*, float, float, cocos2d::CCPoint, float, bool);
	static auto func = wrapFunction(base::get() + 0x2fee50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto TextArea::setString(gd::string p0) -> decltype(setString(p0)) {
	using FunctionType = decltype(setString(p0))(*)(TextArea*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2fef40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TextArea::fadeInCharacters(float p0, float p1) -> decltype(fadeInCharacters(p0, p1)) {
	using FunctionType = decltype(fadeInCharacters(p0, p1))(*)(TextArea*, float, float);
	static auto func = wrapFunction(base::get() + 0x2ffae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TextArea::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&TextArea::update), this);
	using FunctionType = decltype(update(p0))(*)(TextArea*, float);
	static auto func = wrapFunction(base::get() + 0x2ff930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextArea::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TextArea::draw), this);
	using FunctionType = decltype(draw())(*)(TextArea*);
	static auto func = wrapFunction(base::get() + 0x2ff920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TextArea::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&TextArea::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(TextArea*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x2ff780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

Slider* Slider::create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler) {
		return Slider::create(target, handler, 1.f);
	}

Slider* Slider::create(cocos2d::CCNode* target, cocos2d::SEL_MenuHandler handler, float idk) {
		return Slider::create(target, handler, "sliderBar.png", "slidergroove.png", "sliderthumb.png", "sliderthumbsel.png", idk);
	}

auto Slider::create(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x2e1100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto Slider::init(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, char const* p4, char const* p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(Slider*, cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x2e1340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

SliderThumb* Slider::getThumb() {
		return m_touchLogic->m_thumb;
	}

auto Slider::setBarVisibility(bool p0) -> decltype(setBarVisibility(p0)) {
	using FunctionType = decltype(setBarVisibility(p0))(*)(Slider*, bool);
	static auto func = wrapFunction(base::get() + 0x2e1920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void Slider::setValue(float val) {
		this->getThumb()->setValue(val);
		this->updateBar();
	}

auto Slider::disableTouch() -> decltype(disableTouch()) {
	using FunctionType = decltype(disableTouch())(*)(Slider*);
	static auto func = wrapFunction(base::get() + 0x2e1830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void Slider::updateBar() {
		float local_8;
		auto thumb = this->getThumb();
		if (!thumb->m_vertical) {
			local_8 = thumb->getPositionX();
		} else {
			local_8 = thumb->getPositionY();
		}

		float local_c = thumb->getScale() * thumb->m_length * 0.5f + local_8;
		float fVar6 = m_width;
		local_c = local_c / (thumb->getScale() * thumb->m_length);
		if (fVar6 * local_c <= fVar6) {
			fVar6 = fVar6 * local_c;
		}

		this->m_sliderBar->setTextureRect(cocos2d::CCRect(0.0f, 0.0f, fVar6, m_height));
	}

auto Slider::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&Slider::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(Slider*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2e1980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto Slider::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&Slider::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(Slider*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2e1a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto Slider::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&Slider::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(Slider*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2e19c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

CCIndexPath::~CCIndexPath() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(CCIndexPath*);
	static auto func = wrapFunction(base::get() + 0x4670c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) CCIndexPath(geode::CutoffConstructor, sizeof(CCIndexPath));
	CCDestructor::lock(this) = true;
}

CCScrollLayerExt::CCScrollLayerExt(cocos2d::CCRect p0) : CCScrollLayerExt(geode::CutoffConstructor, sizeof(CCScrollLayerExt)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	CCScrollLayerExt::~CCScrollLayerExt();
	using FunctionType = void(*)(CCScrollLayerExt*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x40cf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCScrollLayerExt::scrollLayer(float p0) -> decltype(scrollLayer(p0)) {
	using FunctionType = decltype(scrollLayer(p0))(*)(CCScrollLayerExt*, float);
	static auto func = wrapFunction(base::get() + 0x40e1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCScrollLayerExt::moveToTopWithOffset(float p0) -> decltype(moveToTopWithOffset(p0)) {
	using FunctionType = decltype(moveToTopWithOffset(p0))(*)(CCScrollLayerExt*, float);
	static auto func = wrapFunction(base::get() + 0x40d580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCScrollLayerExt::moveToTop() -> decltype(moveToTop()) {
	using FunctionType = decltype(moveToTop())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x40d620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCScrollLayerExt::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::visit), this);
	using FunctionType = decltype(visit())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x40e2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExt::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x40dc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x40e060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x40dd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCScrollLayerExt::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CCScrollLayerExt*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x40e000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCScrollLayerExt::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x40dbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCScrollLayerExt::preVisitWithClippingRect(cocos2d::CCRect p0) -> decltype(preVisitWithClippingRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect>::func(&CCScrollLayerExt::preVisitWithClippingRect), this);
	using FunctionType = decltype(preVisitWithClippingRect(p0))(*)(CCScrollLayerExt*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x40e3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCScrollLayerExt::postVisit() -> decltype(postVisit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCScrollLayerExt::postVisit), this);
	using FunctionType = decltype(postVisit())(*)(CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x40e420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void CCScrollLayerExtDelegate::scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewDidEndDecelerating(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewTouchMoving(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewDidEndMoving(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewTouchBegin(CCScrollLayerExt* p0) {}

void CCScrollLayerExtDelegate::scrollViewTouchEnd(CCScrollLayerExt* p0) {}

auto TableView::create(TableViewDelegate* p0, TableViewDataSource* p1, TableViewCellDelegate* p2, cocos2d::CCRect p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(TableViewDelegate*, TableViewDataSource*, TableViewCellDelegate*, cocos2d::CCRect);
	static auto func = wrapFunction(base::get() + 0x5e4240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto TableView::reloadData() -> decltype(reloadData()) {
	using FunctionType = decltype(reloadData())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x5e5020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto TableView::deleteTableViewCell(TableViewCell* p0) -> decltype(deleteTableViewCell(p0)) {
	using FunctionType = decltype(deleteTableViewCell(p0))(*)(TableView*, TableViewCell*);
	static auto func = wrapFunction(base::get() + 0x5e4cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TableView::dequeueReusableCellWithIdentifier(char const* p0) -> decltype(dequeueReusableCellWithIdentifier(p0)) {
	using FunctionType = decltype(dequeueReusableCellWithIdentifier(p0))(*)(TableView*, char const*);
	static auto func = wrapFunction(base::get() + 0x5e4f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TableView::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TableView::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x5e55c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TableView::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TableView::onExit), this);
	using FunctionType = decltype(onExit())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x5e55d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TableView::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x5e5770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x5e62b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x5e6070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&TableView::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(TableView*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x5e61f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TableView::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(TableView*);
	static auto func = wrapFunction(base::get() + 0x5e55e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TableView::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&TableView::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(TableView*, float, float);
	static auto func = wrapFunction(base::get() + 0x5e63a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TableView::scrllViewWillBeginDecelerating(CCScrollLayerExt* p0) -> decltype(scrllViewWillBeginDecelerating(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCScrollLayerExt*>::func(&TableView::scrllViewWillBeginDecelerating), this);
	using FunctionType = decltype(scrllViewWillBeginDecelerating(p0))(*)(TableView*, CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x5e6fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TableView::scrollViewDidEndDecelerating(CCScrollLayerExt* p0) -> decltype(scrollViewDidEndDecelerating(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCScrollLayerExt*>::func(&TableView::scrollViewDidEndDecelerating), this);
	using FunctionType = decltype(scrollViewDidEndDecelerating(p0))(*)(TableView*, CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x5e6fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TableView::scrollViewTouchMoving(CCScrollLayerExt* p0) -> decltype(scrollViewTouchMoving(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCScrollLayerExt*>::func(&TableView::scrollViewTouchMoving), this);
	using FunctionType = decltype(scrollViewTouchMoving(p0))(*)(TableView*, CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x5e6fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TableView::scrollViewDidEndMoving(CCScrollLayerExt* p0) -> decltype(scrollViewDidEndMoving(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCScrollLayerExt*>::func(&TableView::scrollViewDidEndMoving), this);
	using FunctionType = decltype(scrollViewDidEndMoving(p0))(*)(TableView*, CCScrollLayerExt*);
	static auto func = wrapFunction(base::get() + 0x5e7000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

TableViewCell::TableViewCell(char const* p0, float p1, float p2) : TableViewCell(geode::CutoffConstructor, sizeof(TableViewCell)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	TableViewCell::~TableViewCell();
	using FunctionType = void(*)(TableViewCell*, char const*, float, float);
	static auto func = wrapFunction(base::get() + 0x5eb040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

TableViewCell::~TableViewCell() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(TableViewCell*);
	static auto func = wrapFunction(base::get() + 0x5eb320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) TableViewCell(geode::CutoffConstructor, sizeof(TableViewCell));
	CCDestructor::lock(this) = true;
}

auto TableViewCell::updateVisibility() -> decltype(updateVisibility()) {
	using FunctionType = decltype(updateVisibility())(*)(TableViewCell*);
	static auto func = wrapFunction(base::get() + 0x5eb5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void TableViewDelegate::willTweenToIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::didEndTweenToIndexPath(CCIndexPath& p0, TableView* p1) {}

void TableViewDelegate::TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::TableViewDidDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

void TableViewDelegate::TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

float TableViewDelegate::cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) { return 0; }

void TableViewDelegate::didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {}

void TextInputDelegate::textChanged(CCTextInputNode* p0) {}

void TextInputDelegate::textInputOpened(CCTextInputNode* p0) {}

void TextInputDelegate::textInputClosed(CCTextInputNode* p0) {}

void TextInputDelegate::textInputShouldOffset(CCTextInputNode* p0, float p1) {}

void TextInputDelegate::textInputReturn(CCTextInputNode* p0) {}

bool TextInputDelegate::allowTextInput(CCTextInputNode* p0) { return true; }

void TextInputDelegate::enterPressed(CCTextInputNode* p0) {}

int TableViewDataSource::numberOfRowsInSection(unsigned int p0, TableView* p1) { return 0; }

unsigned int TableViewDataSource::numberOfSectionsInTableView(TableView* p0) { return 0; }

void TableViewDataSource::TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) {}

TableViewCell* TableViewDataSource::cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) { return nullptr; }

auto TableViewCellDelegate::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	throw std::runtime_error("TableViewCellDelegate::cellPerformedAction not implemented");
}

auto TableViewCellDelegate::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	throw std::runtime_error("TableViewCellDelegate::getSelectedCellIdx not implemented");
}

auto TableViewCellDelegate::shouldSnapToSelected() -> decltype(shouldSnapToSelected()) {
	throw std::runtime_error("TableViewCellDelegate::shouldSnapToSelected not implemented");
}

auto BoomListView::init(cocos2d::CCArray* p0, TableViewCellDelegate* p1, float p2, float p3, int p4, BoomListType p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(BoomListView*, cocos2d::CCArray*, TableViewCellDelegate*, float, float, int, BoomListType, float);
	static auto func = wrapFunction(base::get() + 0x2e9890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

BoomListView::BoomListView() {}

BoomListView::~BoomListView() {
		CC_SAFE_RELEASE(m_entries);
	}

auto BoomListView::lockList(bool p0) -> decltype(lockList(p0)) {
	using FunctionType = decltype(lockList(p0))(*)(BoomListView*, bool);
	static auto func = wrapFunction(base::get() + 0x2e9a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void BoomListView::draw() {}

auto BoomListView::setupList(float p0) -> decltype(setupList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&BoomListView::setupList), this);
	using FunctionType = decltype(setupList(p0))(*)(BoomListView*, float);
	static auto func = wrapFunction(base::get() + 0x2e9ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

void BoomListView::TableViewWillDisplayCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

auto BoomListView::cellHeightForRowAtIndexPath(CCIndexPath& p0, TableView* p1) -> decltype(cellHeightForRowAtIndexPath(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCIndexPath&, TableView*>::func(&BoomListView::cellHeightForRowAtIndexPath), this);
	using FunctionType = decltype(cellHeightForRowAtIndexPath(p0, p1))(*)(BoomListView*, CCIndexPath&, TableView*);
	static auto func = wrapFunction(base::get() + 0x2e9ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

void BoomListView::didSelectRowAtIndexPath(CCIndexPath& p0, TableView* p1) {}

auto BoomListView::numberOfRowsInSection(unsigned int p0, TableView* p1) -> decltype(numberOfRowsInSection(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned int, TableView*>::func(&BoomListView::numberOfRowsInSection), this);
	using FunctionType = decltype(numberOfRowsInSection(p0, p1))(*)(BoomListView*, unsigned int, TableView*);
	static auto func = wrapFunction(base::get() + 0x2e9be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomListView::numberOfSectionsInTableView(TableView* p0) -> decltype(numberOfSectionsInTableView(p0)) {
	auto self = addresser::thunkAdjust(Resolve<TableView*>::func(&BoomListView::numberOfSectionsInTableView), this);
	using FunctionType = decltype(numberOfSectionsInTableView(p0))(*)(BoomListView*, TableView*);
	static auto func = wrapFunction(base::get() + 0x2e9c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto BoomListView::cellForRowAtIndexPath(CCIndexPath& p0, TableView* p1) -> decltype(cellForRowAtIndexPath(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCIndexPath&, TableView*>::func(&BoomListView::cellForRowAtIndexPath), this);
	using FunctionType = decltype(cellForRowAtIndexPath(p0, p1))(*)(BoomListView*, CCIndexPath&, TableView*);
	static auto func = wrapFunction(base::get() + 0x2e9c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath(TableView* p0, TableViewCellEditingStyle p1, CCIndexPath& p2) -> decltype(TableViewCommitCellEditingStyleForRowAtIndexPath(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<TableView*, TableViewCellEditingStyle, CCIndexPath&>::func(&BoomListView::TableViewCommitCellEditingStyleForRowAtIndexPath), this);
	using FunctionType = decltype(TableViewCommitCellEditingStyleForRowAtIndexPath(p0, p1, p2))(*)(BoomListView*, TableView*, TableViewCellEditingStyle, CCIndexPath&);
	static auto func = wrapFunction(base::get() + 0x2ea4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

void BoomListView::TableViewWillReloadCellForRowAtIndexPath(CCIndexPath& p0, TableViewCell* p1, TableView* p2) {}

auto BoomListView::getListCell(char const* p0) -> decltype(getListCell(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&BoomListView::getListCell), this);
	using FunctionType = decltype(getListCell(p0))(*)(BoomListView*, char const*);
	static auto func = wrapFunction(base::get() + 0x2e9d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto BoomListView::loadCell(TableViewCell* p0, int p1) -> decltype(loadCell(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int>::func(&BoomListView::loadCell), this);
	using FunctionType = decltype(loadCell(p0, p1))(*)(BoomListView*, TableViewCell*, int);
	static auto func = wrapFunction(base::get() + 0x2e9f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomListView::create(cocos2d::CCArray* p0, TableViewCellDelegate* p1, float p2, float p3, int p4, BoomListType p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCArray*, TableViewCellDelegate*, float, float, int, BoomListType, float);
	static auto func = wrapFunction(base::get() + 0x21f7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

CustomListView::~CustomListView() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(CustomListView*);
	static auto func = wrapFunction(base::get() + 0x21f750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) CustomListView(geode::CutoffConstructor, sizeof(CustomListView));
	CCDestructor::lock(this) = true;
}

auto CustomListView::getCellHeight(BoomListType p0) -> decltype(getCellHeight(p0)) {
	using FunctionType = decltype(getCellHeight(p0))(*)(CustomListView*, BoomListType);
	static auto func = wrapFunction(base::get() + 0x2209d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomListView::reloadAll() -> decltype(reloadAll()) {
	using FunctionType = decltype(reloadAll())(*)(CustomListView*);
	static auto func = wrapFunction(base::get() + 0x22c700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomListView::setupList(float p0) -> decltype(setupList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CustomListView::setupList), this);
	using FunctionType = decltype(setupList(p0))(*)(CustomListView*, float);
	static auto func = wrapFunction(base::get() + 0x22bed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomListView::getListCell(char const* p0) -> decltype(getListCell(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CustomListView::getListCell), this);
	using FunctionType = decltype(getListCell(p0))(*)(CustomListView*, char const*);
	static auto func = wrapFunction(base::get() + 0x21f910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomListView::loadCell(TableViewCell* p0, int p1) -> decltype(loadCell(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int>::func(&CustomListView::loadCell), this);
	using FunctionType = decltype(loadCell(p0, p1))(*)(CustomListView*, TableViewCell*, int);
	static auto func = wrapFunction(base::get() + 0x2214a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

CCMenuItemToggler* CCMenuItemToggler::createWithSize(const char* spr1, const char* spr2, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
		auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName(spr1);
		auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName(spr2);

		sprOff->setScale(scale);
		sprOn->setScale(scale);

		return create(sprOff, sprOn, target, callback);
	}

CCMenuItemToggler* CCMenuItemToggler::createWithStandardSprites(cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback, float scale) {
		auto sprOff = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOff_001.png");
		auto sprOn = cocos2d::CCSprite::createWithSpriteFrameName("GJ_checkOn_001.png");

		sprOff->setScale(scale);
		sprOn->setScale(scale);

		return create(sprOff, sprOn, target, callback);
	}

bool CCMenuItemToggler::isOn() {
		return m_toggled;
	}

bool CCMenuItemToggler::isToggled() {
		return m_toggled;
	}

void CCMenuItemToggler::setClickable(bool on) {
		m_notClickable = !on;
	}

void CCMenuItemToggler::toggleWithCallback(bool on) {
		this->activate();
		this->toggle(on);
	}

auto CCMenuItemToggler::create(cocos2d::CCNode* offSpr, cocos2d::CCNode* onSpr, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler callback) -> decltype(create(offSpr, onSpr, target, callback)) {
	using FunctionType = decltype(create(offSpr, onSpr, target, callback))(*)(cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x5c8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(offSpr, onSpr, target, callback);
}

auto CCMenuItemToggler::init(cocos2d::CCNode* off, cocos2d::CCNode* on, cocos2d::CCObject* target, cocos2d::SEL_MenuHandler handler) -> decltype(init(off, on, target, handler)) {
	using FunctionType = decltype(init(off, on, target, handler))(*)(CCMenuItemToggler*, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCObject*, cocos2d::SEL_MenuHandler);
	static auto func = wrapFunction(base::get() + 0x5c980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, off, on, target, handler);
}

auto CCMenuItemToggler::setSizeMult(float p0) -> decltype(setSizeMult(p0)) {
	using FunctionType = decltype(setSizeMult(p0))(*)(CCMenuItemToggler*, float);
	static auto func = wrapFunction(base::get() + 0x5ce30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCMenuItemToggler::toggle(bool p0) -> decltype(toggle(p0)) {
	using FunctionType = decltype(toggle(p0))(*)(CCMenuItemToggler*, bool);
	static auto func = wrapFunction(base::get() + 0x5cd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCMenuItemToggler::setEnabled(bool enabled) -> decltype(setEnabled(enabled)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCMenuItemToggler::setEnabled), this);
	using FunctionType = decltype(setEnabled(enabled))(*)(CCMenuItemToggler*, bool);
	static auto func = wrapFunction(base::get() + 0x5cfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, enabled);
}

auto CCMenuItemToggler::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::activate), this);
	using FunctionType = decltype(activate())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x5cf70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::selected() -> decltype(selected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::selected), this);
	using FunctionType = decltype(selected())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x5cf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCMenuItemToggler::unselected() -> decltype(unselected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCMenuItemToggler::unselected), this);
	using FunctionType = decltype(unselected())(*)(CCMenuItemToggler*);
	static auto func = wrapFunction(base::get() + 0x5cfa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void CCMenuItemToggler::updateSprite() {
		m_offButton->updateSprite();
		m_onButton->updateSprite();
		auto size = m_offButton->getScaledContentSize();
		m_offButton->setPosition(size / 2);
		m_offButton->setAnchorPoint({ .5f, .5f });
		m_onButton->setPosition(size / 2);
		m_onButton->setAnchorPoint({ .5f, .5f });
		this->setContentSize(size);
	}

auto CCContentLayer::create(cocos2d::_ccColor4B const& p0, float p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::_ccColor4B const&, float, float);
	static auto func = wrapFunction(base::get() + 0x77f270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto CCContentLayer::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCContentLayer::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(CCContentLayer*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x77f370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GooglePlayDelegate::googlePlaySignedIn() -> decltype(googlePlaySignedIn()) {
	throw std::runtime_error("GooglePlayDelegate::googlePlaySignedIn not implemented");
}

auto MenuLayer::scene(bool p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x36de10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto MenuLayer::onFacebook(cocos2d::CCObject* sender) -> decltype(onFacebook(sender)) {
	using FunctionType = decltype(onFacebook(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onMoreGames(cocos2d::CCObject* sender) -> decltype(onMoreGames(sender)) {
	using FunctionType = decltype(onMoreGames(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onMyProfile(cocos2d::CCObject* sender) -> decltype(onMyProfile(sender)) {
	using FunctionType = decltype(onMyProfile(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onGameCenter(cocos2d::CCObject* sender) -> decltype(onGameCenter(sender)) {
	using FunctionType = decltype(onGameCenter(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36fac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onNewgrounds(cocos2d::CCObject* sender) -> decltype(onNewgrounds(sender)) {
	using FunctionType = decltype(onNewgrounds(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onAchievements(cocos2d::CCObject* sender) -> decltype(onAchievements(sender)) {
	using FunctionType = decltype(onAchievements(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onQuit(cocos2d::CCObject* sender) -> decltype(onQuit(sender)) {
	using FunctionType = decltype(onQuit(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onDaily(cocos2d::CCObject* sender) -> decltype(onDaily(sender)) {
	using FunctionType = decltype(onDaily(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onStats(cocos2d::CCObject* sender) -> decltype(onStats(sender)) {
	using FunctionType = decltype(onStats(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onGarage(cocos2d::CCObject* sender) -> decltype(onGarage(sender)) {
	using FunctionType = decltype(onGarage(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onRobTop(cocos2d::CCObject* sender) -> decltype(onRobTop(sender)) {
	using FunctionType = decltype(onRobTop(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onTwitch(cocos2d::CCObject* sender) -> decltype(onTwitch(sender)) {
	using FunctionType = decltype(onTwitch(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onCreator(cocos2d::CCObject* sender) -> decltype(onCreator(sender)) {
	using FunctionType = decltype(onCreator(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onDiscord(cocos2d::CCObject* sender) -> decltype(onDiscord(sender)) {
	using FunctionType = decltype(onDiscord(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onOptions(cocos2d::CCObject* sender) -> decltype(onOptions(sender)) {
	using FunctionType = decltype(onOptions(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onTrailer(cocos2d::CCObject* sender) -> decltype(onTrailer(sender)) {
	using FunctionType = decltype(onTrailer(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36fea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onTwitter(cocos2d::CCObject* sender) -> decltype(onTwitter(sender)) {
	using FunctionType = decltype(onTwitter(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::onYouTube(cocos2d::CCObject* sender) -> decltype(onYouTube(sender)) {
	using FunctionType = decltype(onYouTube(sender))(*)(MenuLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36f6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MenuLayer::openOptions(bool p0) -> decltype(openOptions(p0)) {
	using FunctionType = decltype(openOptions(p0))(*)(MenuLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x75bcf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MenuLayer::showGCQuestion() -> decltype(showGCQuestion()) {
	using FunctionType = decltype(showGCQuestion())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x36fb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuLayer::firstNetworkTest() -> decltype(firstNetworkTest()) {
	using FunctionType = decltype(firstNetworkTest())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x36fa30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuLayer::showTOS() -> decltype(showTOS()) {
	using FunctionType = decltype(showTOS())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x36f9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::init), this);
	using FunctionType = decltype(init())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x36dfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x36fee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&MenuLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(MenuLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x3701a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MenuLayer::googlePlaySignedIn() -> decltype(googlePlaySignedIn()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuLayer::googlePlaySignedIn), this);
	using FunctionType = decltype(googlePlaySignedIn())(*)(MenuLayer*);
	static auto func = wrapFunction(base::get() + 0x36fc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MenuLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MenuLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x36ff10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LoadingLayer::create(bool fromReload) -> decltype(create(fromReload)) {
	using FunctionType = decltype(create(fromReload))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x380170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(fromReload);
}

auto LoadingLayer::init(bool fromReload) -> decltype(init(fromReload)) {
	using FunctionType = decltype(init(fromReload))(*)(LoadingLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x380350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, fromReload);
}

auto LoadingLayer::loadAssets() -> decltype(loadAssets()) {
	using FunctionType = decltype(loadAssets())(*)(LoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x380ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LoadingLayer::loadingFinished() -> decltype(loadingFinished()) {
	using FunctionType = decltype(loadingFinished())(*)(LoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x381310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto TextAlertPopup::create(gd::string p0, float p1, float p2, int p3, gd::string p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(gd::string, float, float, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x28b290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto TextAlertPopup::init(gd::string p0, float p1, float p2, int p3, gd::string p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(TextAlertPopup*, gd::string, float, float, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x28b3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto TextAlertPopup::setLabelColor(cocos2d::_ccColor3B p0) -> decltype(setLabelColor(p0)) {
	using FunctionType = decltype(setLabelColor(p0))(*)(TextAlertPopup*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x28b6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TextAlertPopup::setAlertPosition(cocos2d::CCPoint p0, cocos2d::CCPoint p1) -> decltype(setAlertPosition(p0, p1)) {
	using FunctionType = decltype(setAlertPosition(p0, p1))(*)(TextAlertPopup*, cocos2d::CCPoint, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x28b710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameRateDelegate::updateRate() -> decltype(updateRate()) {
	throw std::runtime_error("GameRateDelegate::updateRate not implemented");
}

auto ListButtonBarDelegate::listButtonBarSwitchedPage(ListButtonBar* p0, int p1) -> decltype(listButtonBarSwitchedPage(p0, p1)) {
	throw std::runtime_error("ListButtonBarDelegate::listButtonBarSwitchedPage not implemented");
}

auto CharacterColorDelegate::playerColorChanged() -> decltype(playerColorChanged()) {
	throw std::runtime_error("CharacterColorDelegate::playerColorChanged not implemented");
}

auto CharacterColorDelegate::showUnlockPopup(int p0, UnlockType p1) -> decltype(showUnlockPopup(p0, p1)) {
	throw std::runtime_error("CharacterColorDelegate::showUnlockPopup not implemented");
}

auto GJGarageLayer::getItems(int p0, int p1, IconType p2, int p3) -> decltype(getItems(p0, p1, p2, p3)) {
	using FunctionType = decltype(getItems(p0, p1, p2, p3))(*)(GJGarageLayer*, int, int, IconType, int);
	static auto func = wrapFunction(base::get() + 0x34c160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJGarageLayer::onSelectTab(cocos2d::CCObject* sender) -> decltype(onSelectTab(sender)) {
	using FunctionType = decltype(onSelectTab(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34b150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onToggleItem(cocos2d::CCObject* sender) -> decltype(onToggleItem(sender)) {
	using FunctionType = decltype(onToggleItem(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34cde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34a9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34ac40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onShop(cocos2d::CCObject* sender) -> decltype(onShop(sender)) {
	using FunctionType = decltype(onShop(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34ab50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onPaint(cocos2d::CCObject* sender) -> decltype(onPaint(sender)) {
	using FunctionType = decltype(onPaint(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34abe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34c580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::onShards(cocos2d::CCObject* sender) -> decltype(onShards(sender)) {
	using FunctionType = decltype(onShards(sender))(*)(GJGarageLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x34abb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJGarageLayer::setupIconSelect() -> decltype(setupIconSelect()) {
	using FunctionType = decltype(setupIconSelect())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x349ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::setupSpecialPage() -> decltype(setupSpecialPage()) {
	using FunctionType = decltype(setupSpecialPage())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x34baa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::updatePlayerColors() -> decltype(updatePlayerColors()) {
	using FunctionType = decltype(updatePlayerColors())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x3498d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGarageLayer::scene() -> decltype(scene()) {
	using FunctionType = decltype(scene())(*)();
	static auto func = wrapFunction(base::get() + 0x347bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJGarageLayer::selectTab(IconType p0) -> decltype(selectTab(p0)) {
	using FunctionType = decltype(selectTab(p0))(*)(GJGarageLayer*, IconType);
	static auto func = wrapFunction(base::get() + 0x34b2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGarageLayer::setupPage(int p0, IconType p1) -> decltype(setupPage(p0, p1)) {
	using FunctionType = decltype(setupPage(p0, p1))(*)(GJGarageLayer*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x34b420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGarageLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::init), this);
	using FunctionType = decltype(init())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x347d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x34df30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJGarageLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(GJGarageLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x34ae00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJGarageLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(GJGarageLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x34af60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJGarageLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJGarageLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x34b0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::listButtonBarSwitchedPage(ListButtonBar* p0, int p1) -> decltype(listButtonBarSwitchedPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ListButtonBar*, int>::func(&GJGarageLayer::listButtonBarSwitchedPage), this);
	using FunctionType = decltype(listButtonBarSwitchedPage(p0, p1))(*)(GJGarageLayer*, ListButtonBar*, int);
	static auto func = wrapFunction(base::get() + 0x34d510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::showUnlockPopup(int p0, UnlockType p1) -> decltype(showUnlockPopup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, UnlockType>::func(&GJGarageLayer::showUnlockPopup), this);
	using FunctionType = decltype(showUnlockPopup(p0, p1))(*)(GJGarageLayer*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x34d6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::updateRate() -> decltype(updateRate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::updateRate), this);
	using FunctionType = decltype(updateRate())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x34dce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGarageLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJGarageLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJGarageLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x34da70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJGarageLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&GJGarageLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(GJGarageLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x34db80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGarageLayer::playerColorChanged() -> decltype(playerColorChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGarageLayer::playerColorChanged), this);
	using FunctionType = decltype(playerColorChanged())(*)(GJGarageLayer*);
	static auto func = wrapFunction(base::get() + 0x34d410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJValueTween::step(float p0) -> decltype(step(p0)) {
	throw std::runtime_error("GJValueTween::step not implemented");
}

auto GJGameState::tweenValue(float p0, float p1, int p2, float p3, int p4, float p5, int p6, int p7) -> decltype(tweenValue(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(tweenValue(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJGameState*, float, float, int, float, int, float, int, int);
	static auto func = wrapFunction(base::get() + 0x1525d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GJGameState::stopTweenAction(int p0) -> decltype(stopTweenAction(p0)) {
	using FunctionType = decltype(stopTweenAction(p0))(*)(GJGameState*, int);
	static auto func = wrapFunction(base::get() + 0x152c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void TriggerEffectDelegate::toggleGroupTriggered(int p0, bool p1, gd::vector<int> const& p2, int p3, int p4) {}

void TriggerEffectDelegate::spawnGroup(int p0, bool p1, double p2, gd::vector<int> const& p3, int p4, int p5) {}

void TriggerEffectDelegate::spawnObject(GameObject* p0, double p1, gd::vector<int> const& p2) {}

GJBaseGameLayer* GJBaseGameLayer::get() {
		return GameManager::get()->m_gameLayer;
	}

auto GJBaseGameLayer::getOtherPlayer(PlayerObject* p0) -> decltype(getOtherPlayer(p0)) {
	using FunctionType = decltype(getOtherPlayer(p0))(*)(GJBaseGameLayer*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x10e1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::getModifiedDelta(float p0) -> decltype(getModifiedDelta(p0)) {
	using FunctionType = decltype(getModifiedDelta(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x13eb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::getCameraEdgeValue(int p0) -> decltype(getCameraEdgeValue(p0)) {
	using FunctionType = decltype(getCameraEdgeValue(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x13bf90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::getGroup(int p0) -> decltype(getGroup(p0)) {
	using FunctionType = decltype(getGroup(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1097a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::setGroupParent(GameObject* p0, int p1) -> decltype(setGroupParent(p0, p1)) {
	using FunctionType = decltype(setGroupParent(p0, p1))(*)(GJBaseGameLayer*, GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x129f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::bumpPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(bumpPlayer(p0, p1)) {
	using FunctionType = decltype(bumpPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x113750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::pauseAudio() -> decltype(pauseAudio()) {
	using FunctionType = decltype(pauseAudio())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x13ea60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::pickupItem(EffectGameObject* p0) -> decltype(pickupItem(p0)) {
	using FunctionType = decltype(pickupItem(p0))(*)(GJBaseGameLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x113fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::resetAudio() -> decltype(resetAudio()) {
	using FunctionType = decltype(resetAudio())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x13eac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::sortGroups() -> decltype(sortGroups()) {
	using FunctionType = decltype(sortGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x102770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::addGuideArt(GameObject* p0) -> decltype(addGuideArt(p0)) {
	using FunctionType = decltype(addGuideArt(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x14e320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::addToGroups(GameObject* p0, bool p1) -> decltype(addToGroups(p0, p1)) {
	using FunctionType = decltype(addToGroups(p0, p1))(*)(GJBaseGameLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x129840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::flipGravity(PlayerObject* p0, bool p1, bool p2) -> decltype(flipGravity(p0, p1, p2)) {
	using FunctionType = decltype(flipGravity(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x10f940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::queueButton(int p0, bool p1, bool p2) -> decltype(queueButton(p0, p1, p2)) {
	using FunctionType = decltype(queueButton(p0, p1, p2))(*)(GJBaseGameLayer*, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1375f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::resetCamera() -> decltype(resetCamera()) {
	using FunctionType = decltype(resetCamera())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x145830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::resetPlayer() -> decltype(resetPlayer()) {
	using FunctionType = decltype(resetPlayer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x10e540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::shakeCamera(float p0, float p1, float p2) -> decltype(shakeCamera(p0, p1, p2)) {
	using FunctionType = decltype(shakeCamera(p0, p1, p2))(*)(GJBaseGameLayer*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x146e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::createPlayer() -> decltype(createPlayer()) {
	using FunctionType = decltype(createPlayer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfee30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::handleButton(bool push, int button, bool player1) -> decltype(handleButton(push, button, player1)) {
	using FunctionType = decltype(handleButton(push, button, player1))(*)(GJBaseGameLayer*, bool, int, bool);
	static auto func = wrapFunction(base::get() + 0x137800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, push, button, player1);
}

auto GJBaseGameLayer::updateCamera(float p0) -> decltype(updateCamera(p0)) {
	using FunctionType = decltype(updateCamera(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x140660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::destroyObject(GameObject* p0) -> decltype(destroyObject(p0)) {
	using FunctionType = decltype(destroyObject(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x113df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::enterDualMode(GameObject* p0, bool p1) -> decltype(enterDualMode(p0, p1)) {
	using FunctionType = decltype(enterDualMode(p0, p1))(*)(GJBaseGameLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x115120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::hasUniqueCoin(EffectGameObject* p0) -> decltype(hasUniqueCoin(p0)) {
	using FunctionType = decltype(hasUniqueCoin(p0))(*)(GJBaseGameLayer*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x113ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::preResumeGame() -> decltype(preResumeGame()) {
	using FunctionType = decltype(preResumeGame())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x13ea50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::toggleFlipped(bool p0, bool p1) -> decltype(toggleFlipped(p0, p1)) {
	using FunctionType = decltype(toggleFlipped(p0, p1))(*)(GJBaseGameLayer*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x113560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::gravBumpPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(gravBumpPlayer(p0, p1)) {
	using FunctionType = decltype(gravBumpPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x113960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::lightningFlash(cocos2d::CCPoint p0, cocos2d::_ccColor3B p1) -> decltype(lightningFlash(p0, p1)) {
	using FunctionType = decltype(lightningFlash(p0, p1))(*)(GJBaseGameLayer*, cocos2d::CCPoint, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x14f370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::lightningFlash(cocos2d::CCPoint p0, cocos2d::CCPoint p1, cocos2d::_ccColor3B p2, float p3, float p4, int p5, bool p6, float p7) -> decltype(lightningFlash(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(lightningFlash(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJBaseGameLayer*, cocos2d::CCPoint, cocos2d::CCPoint, cocos2d::_ccColor3B, float, float, int, bool, float);
	static auto func = wrapFunction(base::get() + 0x10ce20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GJBaseGameLayer::removeKeyframe(KeyframeGameObject* p0) -> decltype(removeKeyframe(p0)) {
	using FunctionType = decltype(removeKeyframe(p0))(*)(GJBaseGameLayer*, KeyframeGameObject*);
	static auto func = wrapFunction(base::get() + 0x1383e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::teleportPlayer(TeleportPortalObject* p0, PlayerObject* p1) -> decltype(teleportPlayer(p0, p1)) {
	using FunctionType = decltype(teleportPlayer(p0, p1))(*)(GJBaseGameLayer*, TeleportPortalObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x10c5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::toggleDualMode(GameObject* p0, bool p1, PlayerObject* p2, bool p3) -> decltype(toggleDualMode(p0, p1, p2, p3)) {
	using FunctionType = decltype(toggleDualMode(p0, p1, p2, p3))(*)(GJBaseGameLayer*, GameObject*, bool, PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x10f070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::tryResumeAudio() -> decltype(tryResumeAudio()) {
	using FunctionType = decltype(tryResumeAudio())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x13eaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::addRemapTargets(gd::set<int>& p0) -> decltype(addRemapTargets(p0)) {
	using FunctionType = decltype(addRemapTargets(p0))(*)(GJBaseGameLayer*, gd::set<int>&);
	static auto func = wrapFunction(base::get() + 0x101730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::checkCollisions(PlayerObject* p0, float p1, bool p2) -> decltype(checkCollisions(p0, p1, p2)) {
	using FunctionType = decltype(checkCollisions(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x110890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::processCommands(float p0) -> decltype(processCommands(p0)) {
	using FunctionType = decltype(processCommands(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x140200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::setupLevelStart(LevelSettingsObject* p0) -> decltype(setupLevelStart(p0)) {
	using FunctionType = decltype(setupLevelStart(p0))(*)(GJBaseGameLayer*, LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0x10e7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::switchToFlyMode(PlayerObject* p0, GameObject* p1, bool p2, int p3) -> decltype(switchToFlyMode(p0, p1, p2, p3)) {
	using FunctionType = decltype(switchToFlyMode(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*, bool, int);
	static auto func = wrapFunction(base::get() + 0x10f3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::addObjectCounter(LabelGameObject* p0) -> decltype(addObjectCounter(p0)) {
	using FunctionType = decltype(addObjectCounter(p0))(*)(GJBaseGameLayer*, LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x138be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::createBackground(int p0) -> decltype(createBackground(p0)) {
	using FunctionType = decltype(createBackground(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0xff150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::createTextLayers() -> decltype(createTextLayers()) {
	using FunctionType = decltype(createTextLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x10b4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::removeBackground() -> decltype(removeBackground()) {
	using FunctionType = decltype(removeBackground())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xff310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::removeFromGroups(GameObject* p0) -> decltype(removeFromGroups(p0)) {
	using FunctionType = decltype(removeFromGroups(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x129a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::sortStickyGroups() -> decltype(sortStickyGroups()) {
	using FunctionType = decltype(sortStickyGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x105ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::switchToRollMode(PlayerObject* p0, GameObject* p1, bool p2) -> decltype(switchToRollMode(p0, p1, p2)) {
	using FunctionType = decltype(switchToRollMode(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x10f520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::tryGetMainObject(int p0) -> decltype(tryGetMainObject(p0)) {
	using FunctionType = decltype(tryGetMainObject(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x10e6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateBGArtSpeed(float p0, float p1) -> decltype(updateBGArtSpeed(p0, p1)) {
	using FunctionType = decltype(updateBGArtSpeed(p0, p1))(*)(GJBaseGameLayer*, float, float);
	static auto func = wrapFunction(base::get() + 0x1454f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::updateDualGround(PlayerObject* p0, int p1, bool p2, float p3) -> decltype(updateDualGround(p0, p1, p2, p3)) {
	using FunctionType = decltype(updateDualGround(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, int, bool, float);
	static auto func = wrapFunction(base::get() + 0x10f730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::addToGroupParents(GameObject* p0) -> decltype(addToGroupParents(p0)) {
	using FunctionType = decltype(addToGroupParents(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x12a190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::checkSpawnObjects() -> decltype(checkSpawnObjects()) {
	using FunctionType = decltype(checkSpawnObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x117d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::createGroundLayer(int p0, int p1) -> decltype(createGroundLayer(p0, p1)) {
	using FunctionType = decltype(createGroundLayer(p0, p1))(*)(GJBaseGameLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0xff6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::loadLevelSettings() -> decltype(loadLevelSettings()) {
	using FunctionType = decltype(loadLevelSettings())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x144400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::orderSpawnObjects() -> decltype(orderSpawnObjects()) {
	using FunctionType = decltype(orderSpawnObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x14e270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::playerTouchedRing(PlayerObject* p0, RingObject* p1) -> decltype(playerTouchedRing(p0, p1)) {
	using FunctionType = decltype(playerTouchedRing(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, RingObject*);
	static auto func = wrapFunction(base::get() + 0x113aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::positionUIObjects() -> decltype(positionUIObjects()) {
	using FunctionType = decltype(positionUIObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x107bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processSFXObjects() -> decltype(processSFXObjects()) {
	using FunctionType = decltype(processSFXObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x109360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::removeGroundLayer() -> decltype(removeGroundLayer()) {
	using FunctionType = decltype(removeGroundLayer())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xffa40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::switchToRobotMode(PlayerObject* p0, GameObject* p1, bool p2) -> decltype(switchToRobotMode(p0, p1, p2)) {
	using FunctionType = decltype(switchToRobotMode(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x10f5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::updateCameraBGArt(cocos2d::CCPoint p0, float p1) -> decltype(updateCameraBGArt(p0, p1)) {
	using FunctionType = decltype(updateCameraBGArt(p0, p1))(*)(GJBaseGameLayer*, cocos2d::CCPoint, float);
	static auto func = wrapFunction(base::get() + 0x147180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::updateLevelColors() -> decltype(updateLevelColors()) {
	using FunctionType = decltype(updateLevelColors())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xff3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateShaderLayer(float p0) -> decltype(updateShaderLayer(p0)) {
	using FunctionType = decltype(updateShaderLayer(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x127c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::activateSFXTrigger(SFXTriggerGameObject* p0) -> decltype(activateSFXTrigger(p0)) {
	using FunctionType = decltype(activateSFXTrigger(p0))(*)(GJBaseGameLayer*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x146380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::animateInGroundNew(bool p0, float p1, bool p2) -> decltype(animateInGroundNew(p0, p1, p2)) {
	using FunctionType = decltype(animateInGroundNew(p0, p1, p2))(*)(GJBaseGameLayer*, bool, float, bool);
	static auto func = wrapFunction(base::get() + 0x10fda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::applyLevelSettings(GameObject* p0) -> decltype(applyLevelSettings(p0)) {
	using FunctionType = decltype(applyLevelSettings(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x144590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::createMiddleground(int p0) -> decltype(createMiddleground(p0)) {
	using FunctionType = decltype(createMiddleground(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0xff8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::gameEventTriggered(GJGameEvent p0, int p1, int p2) -> decltype(gameEventTriggered(p0, p1, p2)) {
	using FunctionType = decltype(gameEventTriggered(p0, p1, p2))(*)(GJBaseGameLayer*, GJGameEvent, int, int);
	static auto func = wrapFunction(base::get() + 0x10d070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::generateSpawnRemap() -> decltype(generateSpawnRemap()) {
	using FunctionType = decltype(generateSpawnRemap())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1023a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::groupStickyObjects(cocos2d::CCArray* p0) -> decltype(groupStickyObjects(p0)) {
	using FunctionType = decltype(groupStickyObjects(p0))(*)(GJBaseGameLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x12a680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::optimizeMoveGroups() -> decltype(optimizeMoveGroups()) {
	using FunctionType = decltype(optimizeMoveGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x102c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::playExitDualEffect(PlayerObject* p0) -> decltype(playExitDualEffect(p0)) {
	using FunctionType = decltype(playExitDualEffect(p0))(*)(GJBaseGameLayer*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x114c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::reAddToStickyGroup(GameObject* p0) -> decltype(reAddToStickyGroup(p0)) {
	using FunctionType = decltype(reAddToStickyGroup(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x12aa00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::registerSpawnRemap(gd::vector<ChanceObject>& p0) -> decltype(registerSpawnRemap(p0)) {
	using FunctionType = decltype(registerSpawnRemap(p0))(*)(GJBaseGameLayer*, gd::vector<ChanceObject>&);
	static auto func = wrapFunction(base::get() + 0x122620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::removeMiddleground() -> decltype(removeMiddleground()) {
	using FunctionType = decltype(removeMiddleground())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xffa10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::switchToSpiderMode(PlayerObject* p0, GameObject* p1, bool p2) -> decltype(switchToSpiderMode(p0, p1, p2)) {
	using FunctionType = decltype(switchToSpiderMode(p0, p1, p2))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x10f680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJBaseGameLayer::updateMaxGameplayY() -> decltype(updateMaxGameplayY()) {
	using FunctionType = decltype(updateMaxGameplayY())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1445f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::activateSongTrigger(SongTriggerGameObject* p0) -> decltype(activateSongTrigger(p0)) {
	using FunctionType = decltype(activateSongTrigger(p0))(*)(GJBaseGameLayer*, SongTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x145d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::animateOutGroundNew(bool p0) -> decltype(animateOutGroundNew(p0)) {
	using FunctionType = decltype(animateOutGroundNew(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x110090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::resetLevelVariables() -> decltype(resetLevelVariables()) {
	using FunctionType = decltype(resetLevelVariables())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x144860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateLayerCapacity(gd::string p0) -> decltype(updateLayerCapacity(p0)) {
	using FunctionType = decltype(updateLayerCapacity(p0))(*)(GJBaseGameLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x100360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateSpecialLabels() -> decltype(updateSpecialLabels()) {
	using FunctionType = decltype(updateSpecialLabels())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x142d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::generateTargetGroups() -> decltype(generateTargetGroups()) {
	using FunctionType = decltype(generateTargetGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x105cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::playerTouchedTrigger(PlayerObject* p0, EffectGameObject* p1) -> decltype(playerTouchedTrigger(p0, p1)) {
	using FunctionType = decltype(playerTouchedTrigger(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x113b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::playerWillSwitchMode(PlayerObject* p0, GameObject* p1) -> decltype(playerWillSwitchMode(p0, p1)) {
	using FunctionType = decltype(playerWillSwitchMode(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x10fb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::processQueuedButtons() -> decltype(processQueuedButtons()) {
	using FunctionType = decltype(processQueuedButtons())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x137790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::refreshKeyframeAnims() -> decltype(refreshKeyframeAnims()) {
	using FunctionType = decltype(refreshKeyframeAnims())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x109170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::reorderObjectSection(GameObject* p0) -> decltype(reorderObjectSection(p0)) {
	using FunctionType = decltype(reorderObjectSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x1161e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::speedForShaderTarget(int p0) -> decltype(speedForShaderTarget(p0)) {
	using FunctionType = decltype(speedForShaderTarget(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x128de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::ungroupStickyObjects(cocos2d::CCArray* p0) -> decltype(ungroupStickyObjects(p0)) {
	using FunctionType = decltype(ungroupStickyObjects(p0))(*)(GJBaseGameLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x12a7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateGradientLayers() -> decltype(updateGradientLayers()) {
	using FunctionType = decltype(updateGradientLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x125fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updatePlatformerTime() -> decltype(updatePlatformerTime()) {
	using FunctionType = decltype(updatePlatformerTime())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x143350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::collisionCheckObjects(PlayerObject* p0, gd::vector<GameObject*>* p1, int p2, float p3) -> decltype(collisionCheckObjects(p0, p1, p2, p3)) {
	using FunctionType = decltype(collisionCheckObjects(p0, p1, p2, p3))(*)(GJBaseGameLayer*, PlayerObject*, gd::vector<GameObject*>*, int, float);
	static auto func = wrapFunction(base::get() + 0x111970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJBaseGameLayer::removeFromStickyGroup(GameObject* p0) -> decltype(removeFromStickyGroup(p0)) {
	using FunctionType = decltype(removeFromStickyGroup(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x12a970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::shouldExitHackedLevel() -> decltype(shouldExitHackedLevel()) {
	using FunctionType = decltype(shouldExitHackedLevel())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfec60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateExtraGameLayers() -> decltype(updateExtraGameLayers()) {
	using FunctionType = decltype(updateExtraGameLayers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x129020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateStaticCameraPos(cocos2d::CCPoint p0, bool p1, bool p2, bool p3, float p4, int p5, float p6) -> decltype(updateStaticCameraPos(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(updateStaticCameraPos(p0, p1, p2, p3, p4, p5, p6))(*)(GJBaseGameLayer*, cocos2d::CCPoint, bool, bool, bool, float, int, float);
	static auto func = wrapFunction(base::get() + 0x110240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto GJBaseGameLayer::activateSFXEditTrigger(SFXTriggerGameObject* p0) -> decltype(activateSFXEditTrigger(p0)) {
	using FunctionType = decltype(activateSFXEditTrigger(p0))(*)(GJBaseGameLayer*, SFXTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1468d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::canBeActivatedByPlayer(PlayerObject* p0, EffectGameObject* p1) -> decltype(canBeActivatedByPlayer(p0, p1)) {
	using FunctionType = decltype(canBeActivatedByPlayer(p0, p1))(*)(GJBaseGameLayer*, PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1132f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::removeFromGroupParents(GameObject* p0) -> decltype(removeFromGroupParents(p0)) {
	using FunctionType = decltype(removeFromGroupParents(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x12a0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::resetSpawnChannelIndex() -> decltype(resetSpawnChannelIndex()) {
	using FunctionType = decltype(resetSpawnChannelIndex())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x145ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::triggerGradientCommand(GradientTriggerObject* p0) -> decltype(triggerGradientCommand(p0)) {
	using FunctionType = decltype(triggerGradientCommand(p0))(*)(GJBaseGameLayer*, GradientTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x125850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::updateAllObjectSection() -> decltype(updateAllObjectSection()) {
	using FunctionType = decltype(updateAllObjectSection())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1446e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateSpecialGroupData() -> decltype(updateSpecialGroupData()) {
	using FunctionType = decltype(updateSpecialGroupData())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x102330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::activateSongEditTrigger(SongTriggerGameObject* p0) -> decltype(activateSongEditTrigger(p0)) {
	using FunctionType = decltype(activateSongEditTrigger(p0))(*)(GJBaseGameLayer*, SongTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1460d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::positionForShaderTarget(int p0) -> decltype(positionForShaderTarget(p0)) {
	using FunctionType = decltype(positionForShaderTarget(p0))(*)(GJBaseGameLayer*, int);
	static auto func = wrapFunction(base::get() + 0x128cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::removeObjectFromSection(GameObject* p0) -> decltype(removeObjectFromSection(p0)) {
	using FunctionType = decltype(removeObjectFromSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x12adc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::resetActiveEnterEffects() -> decltype(resetActiveEnterEffects()) {
	using FunctionType = decltype(resetActiveEnterEffects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x109840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::togglePlayerStreakBlend(bool p0) -> decltype(togglePlayerStreakBlend(p0)) {
	using FunctionType = decltype(togglePlayerStreakBlend(p0))(*)(GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x129760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::generateVisibilityGroups() -> decltype(generateVisibilityGroups()) {
	using FunctionType = decltype(generateVisibilityGroups())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1081b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::volumeForProximityEffect(SFXTriggerInstance& p0) -> decltype(volumeForProximityEffect(p0)) {
	using FunctionType = decltype(volumeForProximityEffect(p0))(*)(GJBaseGameLayer*, SFXTriggerInstance&);
	static auto func = wrapFunction(base::get() + 0x14a680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::generateEnterEasingBuffer(int p0, float p1) -> decltype(generateEnterEasingBuffer(p0, p1)) {
	using FunctionType = decltype(generateEnterEasingBuffer(p0, p1))(*)(GJBaseGameLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x10abb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJBaseGameLayer::increaseBatchNodeCapacity() -> decltype(increaseBatchNodeCapacity()) {
	using FunctionType = decltype(increaseBatchNodeCapacity())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1001c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::createPlayerCollisionBlock() -> decltype(createPlayerCollisionBlock()) {
	using FunctionType = decltype(createPlayerCollisionBlock())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x115d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::prepareSavePositionObjects() -> decltype(prepareSavePositionObjects()) {
	using FunctionType = decltype(prepareSavePositionObjects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x103270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processQueuedAudioTriggers() -> decltype(processQueuedAudioTriggers()) {
	using FunctionType = decltype(processQueuedAudioTriggers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x145c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::regenerateEnterEasingBuffers() -> decltype(regenerateEnterEasingBuffers()) {
	using FunctionType = decltype(regenerateEnterEasingBuffers())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1025b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::updateProximityVolumeEffects() -> decltype(updateProximityVolumeEffects()) {
	using FunctionType = decltype(updateProximityVolumeEffects())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1431d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJBaseGameLayer::processActivatedAudioTriggers(float p0) -> decltype(processActivatedAudioTriggers(p0)) {
	using FunctionType = decltype(processActivatedAudioTriggers(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x14bf80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJBaseGameLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJBaseGameLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(GJBaseGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x13ec00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBaseGameLayer::init), this);
	using FunctionType = decltype(init())(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0xfa710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBaseGameLayer::visit() -> decltype(visit()) {
	throw std::runtime_error("GJBaseGameLayer::visit not implemented");
}

auto GJBaseGameLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	throw std::runtime_error("GJBaseGameLayer::postUpdate not implemented");
}

auto GJBaseGameLayer::checkForEnd() -> decltype(checkForEnd()) {
	throw std::runtime_error("GJBaseGameLayer::checkForEnd not implemented");
}

auto GJBaseGameLayer::testTime() -> decltype(testTime()) {
	throw std::runtime_error("GJBaseGameLayer::testTime not implemented");
}

auto GJBaseGameLayer::updateVerifyDamage() -> decltype(updateVerifyDamage()) {
	throw std::runtime_error("GJBaseGameLayer::updateVerifyDamage not implemented");
}

auto GJBaseGameLayer::updateAttemptTime(float p0) -> decltype(updateAttemptTime(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateAttemptTime not implemented");
}

auto GJBaseGameLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateVisibility not implemented");
}

auto GJBaseGameLayer::playerTookDamage(PlayerObject* p0) -> decltype(playerTookDamage(p0)) {
	throw std::runtime_error("GJBaseGameLayer::playerTookDamage not implemented");
}

auto GJBaseGameLayer::opacityForObject(GameObject* p0) -> decltype(opacityForObject(p0)) {
	throw std::runtime_error("GJBaseGameLayer::opacityForObject not implemented");
}

auto GJBaseGameLayer::addToSpeedObjects(EffectGameObject* p0) -> decltype(addToSpeedObjects(p0)) {
	throw std::runtime_error("GJBaseGameLayer::addToSpeedObjects not implemented");
}

auto GJBaseGameLayer::objectsCollided(int p0, int p1) -> decltype(objectsCollided(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::objectsCollided not implemented");
}

auto GJBaseGameLayer::updateColor(cocos2d::_ccColor3B& p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue& p5, int p6, bool p7, EffectGameObject* p8, int p9, int p10) -> decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)) {
	throw std::runtime_error("GJBaseGameLayer::updateColor not implemented");
}

auto GJBaseGameLayer::toggleGroupTriggered(int p0, bool p1, gd::vector<int> const& p2, int p3, int p4) -> decltype(toggleGroupTriggered(p0, p1, p2, p3, p4)) {
	throw std::runtime_error("GJBaseGameLayer::toggleGroupTriggered not implemented");
}

auto GJBaseGameLayer::spawnGroup(int p0, bool p1, double p2, gd::vector<int> const& p3, int p4, int p5) -> decltype(spawnGroup(p0, p1, p2, p3, p4, p5)) {
	throw std::runtime_error("GJBaseGameLayer::spawnGroup not implemented");
}

auto GJBaseGameLayer::spawnObject(GameObject* p0, double p1, gd::vector<int> const& p2) -> decltype(spawnObject(p0, p1, p2)) {
	throw std::runtime_error("GJBaseGameLayer::spawnObject not implemented");
}

auto GJBaseGameLayer::activateEndTrigger(int p0, bool p1, bool p2) -> decltype(activateEndTrigger(p0, p1, p2)) {
	throw std::runtime_error("GJBaseGameLayer::activateEndTrigger not implemented");
}

auto GJBaseGameLayer::activatePlatformerEndTrigger(EndTriggerGameObject* p0, gd::vector<int> const& p1) -> decltype(activatePlatformerEndTrigger(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::activatePlatformerEndTrigger not implemented");
}

auto GJBaseGameLayer::toggleGlitter(bool p0) -> decltype(toggleGlitter(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleGlitter not implemented");
}

auto GJBaseGameLayer::destroyPlayer(PlayerObject* p0, GameObject* p1) -> decltype(destroyPlayer(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::destroyPlayer not implemented");
}

auto GJBaseGameLayer::addToSection(GameObject* p0) -> decltype(addToSection(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*>::func(&GJBaseGameLayer::addToSection), this);
	using FunctionType = decltype(addToSection(p0))(*)(GJBaseGameLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x12b1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBaseGameLayer::addToGroup(GameObject* p0, int p1, bool p2) -> decltype(addToGroup(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int, bool>::func(&GJBaseGameLayer::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0, p1, p2))(*)(GJBaseGameLayer*, GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x1298b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GJBaseGameLayer::removeFromGroup(GameObject* p0, int p1) -> decltype(removeFromGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GameObject*, int>::func(&GJBaseGameLayer::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0, p1))(*)(GJBaseGameLayer*, GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x129ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJBaseGameLayer::updateObjectSection(GameObject* p0) -> decltype(updateObjectSection(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateObjectSection not implemented");
}

auto GJBaseGameLayer::updateDisabledObjectsLastPos(cocos2d::CCArray* p0) -> decltype(updateDisabledObjectsLastPos(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateDisabledObjectsLastPos not implemented");
}

auto GJBaseGameLayer::toggleGroundVisibility(bool p0) -> decltype(toggleGroundVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleGroundVisibility not implemented");
}

auto GJBaseGameLayer::toggleMGVisibility(bool p0) -> decltype(toggleMGVisibility(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleMGVisibility not implemented");
}

auto GJBaseGameLayer::toggleHideAttempts(bool p0) -> decltype(toggleHideAttempts(p0)) {
	throw std::runtime_error("GJBaseGameLayer::toggleHideAttempts not implemented");
}

float GJBaseGameLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) { return 0.f; }

float GJBaseGameLayer::posForTime(float p0) { return 0.f; }

void GJBaseGameLayer::resetSPTriggered() {}

auto GJBaseGameLayer::updateScreenRotation(float p0, bool p1, bool p2, float p3, int p4, float p5, int p6, int p7) -> decltype(updateScreenRotation(p0, p1, p2, p3, p4, p5, p6, p7)) {
	throw std::runtime_error("GJBaseGameLayer::updateScreenRotation not implemented");
}

auto GJBaseGameLayer::reverseDirection(EffectGameObject* p0) -> decltype(reverseDirection(p0)) {
	throw std::runtime_error("GJBaseGameLayer::reverseDirection not implemented");
}

auto GJBaseGameLayer::rotateGameplay(RotateGameplayGameObject* p0) -> decltype(rotateGameplay(p0)) {
	throw std::runtime_error("GJBaseGameLayer::rotateGameplay not implemented");
}

auto GJBaseGameLayer::didRotateGameplay() -> decltype(didRotateGameplay()) {
	throw std::runtime_error("GJBaseGameLayer::didRotateGameplay not implemented");
}

auto GJBaseGameLayer::updateTimeWarp(float p0) -> decltype(updateTimeWarp(p0)) {
	throw std::runtime_error("GJBaseGameLayer::updateTimeWarp not implemented");
}

auto GJBaseGameLayer::updateTimeWarp(GameObject* p0, float p1) -> decltype(updateTimeWarp(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::updateTimeWarp not implemented");
}

auto GJBaseGameLayer::applyTimeWarp(float p0) -> decltype(applyTimeWarp(p0)) {
	throw std::runtime_error("GJBaseGameLayer::applyTimeWarp not implemented");
}

auto GJBaseGameLayer::playGravityEffect(bool p0) -> decltype(playGravityEffect(p0)) {
	throw std::runtime_error("GJBaseGameLayer::playGravityEffect not implemented");
}

auto GJBaseGameLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	throw std::runtime_error("GJBaseGameLayer::manualUpdateObjectColors not implemented");
}

auto GJBaseGameLayer::createCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, bool p3) -> decltype(createCustomParticle(p0, p1, p2, p3)) {
	throw std::runtime_error("GJBaseGameLayer::createCustomParticle not implemented");
}

auto GJBaseGameLayer::claimCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, int p3, int p4, bool p5) -> decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5)) {
	throw std::runtime_error("GJBaseGameLayer::claimCustomParticle not implemented");
}

auto GJBaseGameLayer::unclaimCustomParticle(gd::string const& p0, cocos2d::CCParticleSystemQuad* p1) -> decltype(unclaimCustomParticle(p0, p1)) {
	throw std::runtime_error("GJBaseGameLayer::unclaimCustomParticle not implemented");
}

auto GJBaseGameLayer::activatedAudioTrigger(SFXTriggerGameObject* p0) -> decltype(activatedAudioTrigger(p0)) {
	throw std::runtime_error("GJBaseGameLayer::activatedAudioTrigger not implemented");
}

auto GJBaseGameLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	throw std::runtime_error("GJBaseGameLayer::checkpointActivated not implemented");
}

auto GJBaseGameLayer::flipArt(bool p0) -> decltype(flipArt(p0)) {
	throw std::runtime_error("GJBaseGameLayer::flipArt not implemented");
}

auto GJBaseGameLayer::addKeyframe(KeyframeGameObject* p0) -> decltype(addKeyframe(p0)) {
	throw std::runtime_error("GJBaseGameLayer::addKeyframe not implemented");
}

auto GJBaseGameLayer::updateTimeLabel(int p0, int p1, bool p2) -> decltype(updateTimeLabel(p0, p1, p2)) {
	throw std::runtime_error("GJBaseGameLayer::updateTimeLabel not implemented");
}

auto GJBaseGameLayer::checkSnapshot() -> decltype(checkSnapshot()) {
	throw std::runtime_error("GJBaseGameLayer::checkSnapshot not implemented");
}

auto GJBaseGameLayer::toggleProgressbar() -> decltype(toggleProgressbar()) {
	throw std::runtime_error("GJBaseGameLayer::toggleProgressbar not implemented");
}

auto GJBaseGameLayer::toggleInfoLabel() -> decltype(toggleInfoLabel()) {
	throw std::runtime_error("GJBaseGameLayer::toggleInfoLabel not implemented");
}

auto GJBaseGameLayer::removeAllCheckpoints() -> decltype(removeAllCheckpoints()) {
	throw std::runtime_error("GJBaseGameLayer::removeAllCheckpoints not implemented");
}

auto GJBaseGameLayer::toggleMusicInPractice() -> decltype(toggleMusicInPractice()) {
	throw std::runtime_error("GJBaseGameLayer::toggleMusicInPractice not implemented");
}

auto ListButtonBar::create(cocos2d::CCArray* p0, cocos2d::CCPoint p1, int p2, int p3, float p4, float p5, float p6, float p7, int p8) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(cocos2d::CCArray*, cocos2d::CCPoint, int, int, float, float, float, float, int);
	static auto func = wrapFunction(base::get() + 0x3d12d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto ListButtonBar::init(cocos2d::CCArray* p0, cocos2d::CCPoint p1, int p2, int p3, float p4, float p5, float p6, float p7, int p8) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(ListButtonBar*, cocos2d::CCArray*, cocos2d::CCPoint, int, int, float, float, float, float, int);
	static auto func = wrapFunction(base::get() + 0x3d13a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto TextAreaDelegate::fadeInTextFinished(TextArea* p0) -> decltype(fadeInTextFinished(p0)) {
	throw std::runtime_error("TextAreaDelegate::fadeInTextFinished not implemented");
}

auto DialogLayer::create(DialogObject* p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(DialogObject*, int);
	static auto func = wrapFunction(base::get() + 0x3a5600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto DialogLayer::init(DialogObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(DialogLayer*, DialogObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x3a5770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DialogLayer::createDialogLayer(DialogObject* p0, cocos2d::CCArray* p1, int p2) -> decltype(createDialogLayer(p0, p1, p2)) {
	using FunctionType = decltype(createDialogLayer(p0, p1, p2))(*)(DialogObject*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x3a5610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto DialogLayer::createWithObjects(cocos2d::CCArray* p0, int p1) -> decltype(createWithObjects(p0, p1)) {
	using FunctionType = decltype(createWithObjects(p0, p1))(*)(DialogLayer*, cocos2d::CCArray*, int);
	static auto func = wrapFunction(base::get() + 0x3a5750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DialogLayer::displayNextObject() -> decltype(displayNextObject()) {
	using FunctionType = decltype(displayNextObject())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3a5c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DialogLayer::animateInRandomSide() -> decltype(animateInRandomSide()) {
	using FunctionType = decltype(animateInRandomSide())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3a6830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DialogLayer::displayDialogObject(DialogObject* p0) -> decltype(displayDialogObject(p0)) {
	using FunctionType = decltype(displayDialogObject(p0))(*)(DialogLayer*, DialogObject*);
	static auto func = wrapFunction(base::get() + 0x3a5d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DialogLayer::updateChatPlacement(DialogChatPlacement p0) -> decltype(updateChatPlacement(p0)) {
	using FunctionType = decltype(updateChatPlacement(p0))(*)(DialogLayer*, DialogChatPlacement);
	static auto func = wrapFunction(base::get() + 0x3a6100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DialogLayer::animateIn(DialogAnimationType p0) -> decltype(animateIn(p0)) {
	using FunctionType = decltype(animateIn(p0))(*)(DialogLayer*, DialogAnimationType);
	static auto func = wrapFunction(base::get() + 0x3a6880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DialogLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DialogLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3a6730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DialogLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3a65e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DialogLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3a6680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DialogLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3a6640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DialogLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&DialogLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(DialogLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3a66a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DialogLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DialogLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3a66f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DialogLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DialogLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x3a64b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DialogLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&DialogLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(DialogLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x3a6ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DialogLayer::fadeInTextFinished(TextArea* p0) -> decltype(fadeInTextFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<TextArea*>::func(&DialogLayer::fadeInTextFinished), this);
	using FunctionType = decltype(fadeInTextFinished(p0))(*)(DialogLayer*, TextArea*);
	static auto func = wrapFunction(base::get() + 0x3a6740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GManager::loadDataFromFile(gd::string const& p0) -> decltype(loadDataFromFile(p0)) {
	using FunctionType = decltype(loadDataFromFile(p0))(*)(GManager*, gd::string const&);
	static auto func = wrapFunction(base::get() + 0x488350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void GManager::save() {
        saveGMTo(m_fileName);
    }

auto GManager::saveData(DS_Dictionary* p0, gd::string p1) -> decltype(saveData(p0, p1)) {
	using FunctionType = decltype(saveData(p0, p1))(*)(GManager*, DS_Dictionary*, gd::string);
	static auto func = wrapFunction(base::get() + 0x488290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GManager::saveGMTo(gd::string p0) -> decltype(saveGMTo(p0)) {
	using FunctionType = decltype(saveGMTo(p0))(*)(GManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4881c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GManager::init), this);
	using FunctionType = decltype(init())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x487ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GManager::setup() -> decltype(setup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GManager::setup), this);
	using FunctionType = decltype(setup())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x487ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GManager::encodeDataTo), this);
	using FunctionType = decltype(encodeDataTo(p0))(*)(GManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x488340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GManager::dataLoaded), this);
	using FunctionType = decltype(dataLoaded(p0))(*)(GManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x488910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GManager::firstLoad() -> decltype(firstLoad()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GManager::firstLoad), this);
	using FunctionType = decltype(firstLoad())(*)(GManager*);
	static auto func = wrapFunction(base::get() + 0x488920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

GameManager* GameManager::get() {
		return GameManager::sharedState();
	}

auto GameManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x354920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

PlayLayer* GameManager::getPlayLayer() {
		return m_playLayer;
	}

LevelEditorLayer* GameManager::getEditorLayer() {
		return m_levelEditorLayer;
	}

GJBaseGameLayer* GameManager::getGameLayer() {
		return m_gameLayer;
	}

int GameManager::getPlayerFrame() {
        return m_playerFrame;
    }

int GameManager::getPlayerShip() {
        return m_playerShip;
    }

int GameManager::getPlayerBall() {
        return m_playerBall;
    }

int GameManager::getPlayerBird() {
        return m_playerBird;
    }

int GameManager::getPlayerDart() {
        return m_playerDart;
    }

int GameManager::getPlayerRobot() {
        return m_playerRobot;
    }

int GameManager::getPlayerSpider() {
        return m_playerSpider;
    }

int GameManager::getPlayerSwing() {
        return m_playerSwing;
    }

int GameManager::getPlayerGlowColor() {
        return m_playerGlowColor;
    }

int GameManager::getPlayerStreak() {
        return m_playerStreak;
    }

int GameManager::getPlayerShipFire() {
		return m_playerShipFire;
	}

int GameManager::getPlayerDeathEffect() {
        return m_playerDeathEffect;
    }

int GameManager::getPlayerJetpack() {
		return m_playerJetpack;
	}

int GameManager::getPlayerColor() {
        return m_playerColor;
    }

int GameManager::getPlayerColor2() {
        return m_playerColor2;
    }

bool GameManager::getPlayerGlow() {
        return m_playerGlow;
    }

void GameManager::setPlayerFrame(int id) {
        m_playerFrame = id;
    }

void GameManager::setPlayerShip(int id) {
        m_playerShip = id;
    }

void GameManager::setPlayerBall(int id) {
        m_playerBall = id;
    }

void GameManager::setPlayerBird(int id) {
        m_playerBird = id;
    }

void GameManager::setPlayerDart(int id) {
        m_playerDart = id;
    }

void GameManager::setPlayerRobot(int id) {
        m_playerRobot = id;
    }

void GameManager::setPlayerSpider(int id) {
        m_playerSpider = id;
    }

void GameManager::setPlayerSwing(int id) {
		m_playerSwing = id;
	}

void GameManager::setPlayerColor3(int id) {
		m_playerGlowColor = id;
	}

void GameManager::setPlayerStreak(int id) {
        m_playerStreak = id;
    }

void GameManager::setPlayerShipStreak(int id) {
        m_playerShipFire = id;
    }

void GameManager::setPlayerDeathEffect(int id) {
        m_playerDeathEffect = id;
    }

void GameManager::setPlayerJetpack(int id) {
		m_playerJetpack = id;
	}

void GameManager::setPlayerColor(int id) {
        m_playerColor = id;
    }

void GameManager::setPlayerColor2(int id) {
        m_playerColor2 = id;
    }

void GameManager::setPlayerGlow(bool v) {
        m_playerGlow = v;
    }

bool GameManager::getGameVariableDefault(const char* key, bool defaultValue) {
		//helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->boolValue();
    }

int GameManager::getIntGameVariableDefault(const char* key, int defaultValue) {
		//helper function
        auto object = static_cast<cocos2d::CCString*>(m_valueKeeper->objectForKey(std::string("gv_") + key));
        if (object == nullptr)
            return defaultValue;
        return object->intValue();
    }

auto GameManager::clearGJLog() -> decltype(clearGJLog()) {
	using FunctionType = decltype(clearGJLog())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x363780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::joinReddit() -> decltype(joinReddit()) {
	using FunctionType = decltype(joinReddit())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x35e270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

int GameManager::keyForIcon(int iconIdx, int iconEnum) {
		return m_keyStartForIcon->at(iconEnum) + iconIdx - 1;
	}

auto GameManager::loadGround(int p0) -> decltype(loadGround(p0)) {
	using FunctionType = decltype(loadGround(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x360e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::printGJLog() -> decltype(printGJLog()) {
	using FunctionType = decltype(printGJLog())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x363770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::subYouTube() -> decltype(subYouTube()) {
	using FunctionType = decltype(subYouTube())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x35e120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::unloadIcon(int p0, int p1, int p2) -> decltype(unloadIcon(p0, p1, p2)) {
	using FunctionType = decltype(unloadIcon(p0, p1, p2))(*)(GameManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x35fde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::colorForIdx(int p0) -> decltype(colorForIdx(p0)) {
	using FunctionType = decltype(colorForIdx(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x35d5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::fadeInMusic(gd::string p0) -> decltype(fadeInMusic(p0)) {
	using FunctionType = decltype(fadeInMusic(p0))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x355220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::getFontFile(int p0) -> decltype(getFontFile(p0)) {
	using FunctionType = decltype(getFontFile(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x3606f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameManager::getGTexture(int p0) -> decltype(getGTexture(p0)) {
	using FunctionType = decltype(getGTexture(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x3611f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::joinDiscord() -> decltype(joinDiscord()) {
	using FunctionType = decltype(joinDiscord())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x35e200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::startUpdate() -> decltype(startUpdate()) {
	using FunctionType = decltype(startUpdate())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x354bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::unlockColor(int p0, UnlockType p1) -> decltype(unlockColor(p0, p1)) {
	using FunctionType = decltype(unlockColor(p0, p1))(*)(GameManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x3560d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::countForType(IconType p0) -> decltype(countForType(p0)) {
	using FunctionType = decltype(countForType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x35e6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::followTwitch() -> decltype(followTwitch()) {
	using FunctionType = decltype(followTwitch())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x35e190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::getBGTexture(int p0) -> decltype(getBGTexture(p0)) {
	using FunctionType = decltype(getBGTexture(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x361150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::isIconLoaded(int p0, int p1) -> decltype(isIconLoaded(p0, p1)) {
	using FunctionType = decltype(isIconLoaded(p0, p1))(*)(GameManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x35e8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::likeFacebook() -> decltype(likeFacebook()) {
	using FunctionType = decltype(likeFacebook())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x35e040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::safePopScene() -> decltype(safePopScene()) {
	using FunctionType = decltype(safePopScene())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x368b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::followTwitter() -> decltype(followTwitter()) {
	using FunctionType = decltype(followTwitter())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x35e0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::checkUsedIcons() -> decltype(checkUsedIcons()) {
	using FunctionType = decltype(checkUsedIcons())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x35c8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::isIconUnlocked(int p0, IconType p1) -> decltype(isIconUnlocked(p0, p1)) {
	using FunctionType = decltype(isIconUnlocked(p0, p1))(*)(GameManager*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x3559c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::loadBackground(int p0) -> decltype(loadBackground(p0)) {
	using FunctionType = decltype(loadBackground(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x360930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::reloadAllStep2() -> decltype(reloadAllStep2()) {
	using FunctionType = decltype(reloadAllStep2())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x368d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::reloadAllStep3() -> decltype(reloadAllStep3()) {
	using FunctionType = decltype(reloadAllStep3())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x368e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::reloadAllStep4() -> decltype(reloadAllStep4()) {
	using FunctionType = decltype(reloadAllStep4())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x368f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::reloadAllStep5() -> decltype(reloadAllStep5()) {
	using FunctionType = decltype(reloadAllStep5())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x368f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::fadeInMenuMusic() -> decltype(fadeInMenuMusic()) {
	using FunctionType = decltype(fadeInMenuMusic())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x355150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::getGameVariable(char const* p0) -> decltype(getGameVariable(p0)) {
	using FunctionType = decltype(getGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x355010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::isColorUnlocked(int p0, UnlockType p1) -> decltype(isColorUnlocked(p0, p1)) {
	using FunctionType = decltype(isColorUnlocked(p0, p1))(*)(GameManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x356020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::loadDeathEffect(int p0) -> decltype(loadDeathEffect(p0)) {
	using FunctionType = decltype(loadDeathEffect(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x3607b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::openEditorGuide() -> decltype(openEditorGuide()) {
	using FunctionType = decltype(openEditorGuide())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x35e2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::queueReloadMenu() -> decltype(queueReloadMenu()) {
	using FunctionType = decltype(queueReloadMenu())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x368bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::setGameVariable(char const* p0, bool p1) -> decltype(setGameVariable(p0, p1)) {
	using FunctionType = decltype(setGameVariable(p0, p1))(*)(GameManager*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x361260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::updateCustomFPS() -> decltype(updateCustomFPS()) {
	using FunctionType = decltype(updateCustomFPS())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x369260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::didExitPlayscene() -> decltype(didExitPlayscene()) {
	using FunctionType = decltype(didExitPlayscene())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x3683a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::getIconRequestID() -> decltype(getIconRequestID()) {
	using FunctionType = decltype(getIconRequestID())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x360540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::loadMiddleground(int p0) -> decltype(loadMiddleground(p0)) {
	using FunctionType = decltype(loadMiddleground(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x360b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::sheetNameForIcon(int p0, int p1) -> decltype(sheetNameForIcon(p0, p1)) {
	using FunctionType = decltype(sheetNameForIcon(p0, p1))(*)(GameManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x35ec30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::activeIconForType(IconType p0) -> decltype(activeIconForType(p0)) {
	using FunctionType = decltype(activeIconForType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x35e430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::loadVideoSettings() -> decltype(loadVideoSettings()) {
	using FunctionType = decltype(loadVideoSettings())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x365ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::returnToLastScene(GJGameLevel* p0) -> decltype(returnToLastScene(p0)) {
	using FunctionType = decltype(returnToLastScene(p0))(*)(GameManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x368830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::getIntGameVariable(char const* p0) -> decltype(getIntGameVariable(p0)) {
	using FunctionType = decltype(getIntGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x361960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::toggleGameVariable(char const* p0) -> decltype(toggleGameVariable(p0)) {
	using FunctionType = decltype(toggleGameVariable(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x3614e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::prepareDPadSettings() -> decltype(prepareDPadSettings()) {
	using FunctionType = decltype(prepareDPadSettings())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x365370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::completedAchievement(gd::string p0) -> decltype(completedAchievement(p0)) {
	using FunctionType = decltype(completedAchievement(p0))(*)(GameManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x356be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::getPracticeMusicFile() -> decltype(getPracticeMusicFile()) {
	using FunctionType = decltype(getPracticeMusicFile())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x354d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::iconTypeToUnlockType(IconType p0) -> decltype(iconTypeToUnlockType(p0)) {
	using FunctionType = decltype(iconTypeToUnlockType(p0))(*)(GameManager*, IconType);
	static auto func = wrapFunction(base::get() + 0x355a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::unlockTypeToIconType(int p0) -> decltype(unlockTypeToIconType(p0)) {
	using FunctionType = decltype(unlockTypeToIconType(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x355c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::stringForCustomObject(int p0) -> decltype(stringForCustomObject(p0)) {
	using FunctionType = decltype(stringForCustomObject(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x361e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::getUnlockForAchievement(gd::string p0, int& p1, UnlockType& p2) -> decltype(getUnlockForAchievement(p0, p1, p2)) {
	using FunctionType = decltype(getUnlockForAchievement(p0, p1, p2))(*)(GameManager*, gd::string, int&, UnlockType&);
	static auto func = wrapFunction(base::get() + 0x3561c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::reportAchievementWithID(char const* p0, int p1, bool p2) -> decltype(reportAchievementWithID(p0, p1, p2)) {
	using FunctionType = decltype(reportAchievementWithID(p0, p1, p2))(*)(GameManager*, char const*, int, bool);
	static auto func = wrapFunction(base::get() + 0x357900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::reportPercentageForLevel(int p0, int p1, bool p2) -> decltype(reportPercentageForLevel(p0, p1, p2)) {
	using FunctionType = decltype(reportPercentageForLevel(p0, p1, p2))(*)(GameManager*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x356ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::getOrderedCustomObjectKeys() -> decltype(getOrderedCustomObjectKeys()) {
	using FunctionType = decltype(getOrderedCustomObjectKeys())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x361b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::applicationWillEnterForeground() -> decltype(applicationWillEnterForeground()) {
	using FunctionType = decltype(applicationWillEnterForeground())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x368490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameManager::getUGV(char const* p0) -> decltype(getUGV(p0)) {
	using FunctionType = decltype(getUGV(p0))(*)(GameManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x361700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::setUGV(char const* p0, bool p1) -> decltype(setUGV(p0, p1)) {
	using FunctionType = decltype(setUGV(p0, p1))(*)(GameManager*, char const*, bool);
	static auto func = wrapFunction(base::get() + 0x3615a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameManager::loadFont(int p0) -> decltype(loadFont(p0)) {
	using FunctionType = decltype(loadFont(p0))(*)(GameManager*, int);
	static auto func = wrapFunction(base::get() + 0x360650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameManager::loadIcon(int p0, int p1, int p2) -> decltype(loadIcon(p0, p1, p2)) {
	using FunctionType = decltype(loadIcon(p0, p1, p2))(*)(GameManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x35f7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameManager::reloadAll(bool switchingModes, bool toFullscreen, bool unused) -> decltype(reloadAll(switchingModes, toFullscreen, unused)) {
	using FunctionType = decltype(reloadAll(switchingModes, toFullscreen, unused))(*)(GameManager*, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x368ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, switchingModes, toFullscreen, unused);
}

auto GameManager::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameManager::update), this);
	using FunctionType = decltype(update(p0))(*)(GameManager*, float);
	static auto func = wrapFunction(base::get() + 0x368430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameManager::init), this);
	using FunctionType = decltype(init())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x354980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GameManager::encodeDataTo), this);
	using FunctionType = decltype(encodeDataTo(p0))(*)(GameManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x367900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GameManager::dataLoaded), this);
	using FunctionType = decltype(dataLoaded(p0))(*)(GameManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x365be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameManager::firstLoad() -> decltype(firstLoad()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameManager::firstLoad), this);
	using FunctionType = decltype(firstLoad())(*)(GameManager*);
	static auto func = wrapFunction(base::get() + 0x367010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::create(char const* p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, float);
	static auto func = wrapFunction(base::get() + 0x5acc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

bool GJDropDownLayer::init(char const* title) {
		return GJDropDownLayer::init(title, 220.f);
	}

auto GJDropDownLayer::init(const char* title, float height) -> decltype(init(title, height)) {
	using FunctionType = decltype(init(title, height))(*)(GJDropDownLayer*, const char*, float);
	static auto func = wrapFunction(base::get() + 0x5acd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, title, height);
}

GJDropDownLayer::~GJDropDownLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ac980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) GJDropDownLayer(geode::CutoffConstructor, sizeof(GJDropDownLayer));
	CCDestructor::lock(this) = true;
}

bool GJDropDownLayer::ccTouchBegan(cocos2d::CCTouch* pTouch, cocos2d::CCEvent* pEvent) {
		return true;
	}

void GJDropDownLayer::ccTouchMoved(cocos2d::CCTouch* pTouch, cocos2d::CCEvent* pEvent) {}

void GJDropDownLayer::ccTouchEnded(cocos2d::CCTouch* pTouch, cocos2d::CCEvent* pEvent) {}

void GJDropDownLayer::ccTouchCancelled(cocos2d::CCTouch* pTouch, cocos2d::CCEvent* pEvent) {}

auto GJDropDownLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::draw), this);
	using FunctionType = decltype(draw())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::enterLayer() -> decltype(enterLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::enterLayer), this);
	using FunctionType = decltype(enterLayer())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJDropDownLayer::exitLayer), this);
	using FunctionType = decltype(exitLayer(p0))(*)(GJDropDownLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ad2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJDropDownLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(GJDropDownLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5ad300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GJDropDownLayer::hideLayer), this);
	using FunctionType = decltype(hideLayer(p0))(*)(GJDropDownLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5ad3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDropDownLayer::layerVisible() -> decltype(layerVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::layerVisible), this);
	using FunctionType = decltype(layerVisible())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::enterAnimFinished), this);
	using FunctionType = decltype(enterAnimFinished())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::disableUI() -> decltype(disableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::disableUI), this);
	using FunctionType = decltype(disableUI())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJDropDownLayer::enableUI() -> decltype(enableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJDropDownLayer::enableUI), this);
	using FunctionType = decltype(enableUI())(*)(GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x5ad1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

GJGameLevel* GJGameLevel::createWithCoder(DS_Dictionary* dict) {
		//inlined on windows
		auto level = GJGameLevel::create();
		level->dataLoaded(dict);
		return level;
	}

auto GJGameLevel::create(cocos2d::CCDictionary* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(cocos2d::CCDictionary*, bool);
	static auto func = wrapFunction(base::get() + 0x503c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJGameLevel::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x501aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJGameLevel::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJGameLevel*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x52a700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::getCoinKey(int p0) -> decltype(getCoinKey(p0)) {
	using FunctionType = decltype(getCoinKey(p0))(*)(GJGameLevel*, int);
	static auto func = wrapFunction(base::get() + 0x51ad20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::getSongName() -> decltype(getSongName()) {
	using FunctionType = decltype(getSongName())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x5291e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::getLengthKey(int p0, bool p1) -> decltype(getLengthKey(p0, p1)) {
	using FunctionType = decltype(getLengthKey(p0, p1))(*)(GJGameLevel*, int, bool);
	static auto func = wrapFunction(base::get() + 0x528db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGameLevel::savePercentage(int p0, bool p1, int p2, int p3, bool p4) -> decltype(savePercentage(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(savePercentage(p0, p1, p2, p3, p4))(*)(GJGameLevel*, int, bool, int, int, bool);
	static auto func = wrapFunction(base::get() + 0x528990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GJGameLevel::levelWasAltered() -> decltype(levelWasAltered()) {
	using FunctionType = decltype(levelWasAltered())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x5287c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::getAudioFileName() -> decltype(getAudioFileName()) {
	using FunctionType = decltype(getAudioFileName())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x5290d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::getNormalPercent() -> decltype(getNormalPercent()) {
	using FunctionType = decltype(getNormalPercent())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x5022b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::lengthKeyToString(int p0) -> decltype(lengthKeyToString(p0)) {
	using FunctionType = decltype(lengthKeyToString(p0))(*)(GJGameLevel*, int);
	static auto func = wrapFunction(base::get() + 0x528df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::scoreStringToVector(gd::string& p0, gd::vector<int>& p1) -> decltype(scoreStringToVector(p0, p1)) {
	using FunctionType = decltype(scoreStringToVector(p0, p1))(*)(GJGameLevel*, gd::string&, gd::vector<int>&);
	static auto func = wrapFunction(base::get() + 0x529780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGameLevel::getAverageDifficulty() -> decltype(getAverageDifficulty()) {
	using FunctionType = decltype(getAverageDifficulty())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x528e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::demonIconForDifficulty(DemonDifficultyType p0) -> decltype(demonIconForDifficulty(p0)) {
	using FunctionType = decltype(demonIconForDifficulty(p0))(*)(GJGameLevel*, DemonDifficultyType);
	static auto func = wrapFunction(base::get() + 0x52c310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLevel::getUnpackedLevelDescription() -> decltype(getUnpackedLevelDescription()) {
	using FunctionType = decltype(getUnpackedLevelDescription())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x52c280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLevel::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJGameLevel::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJGameLevel*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x52b6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGameLevel::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLevel::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x52c210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGameLevel::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLevel::init), this);
	using FunctionType = decltype(init())(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x5285a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DialogObject::create(gd::string p0, gd::string p1, int p2, float p3, bool p4, cocos2d::_ccColor3B p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(gd::string, gd::string, int, float, bool, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x3a50f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto AchievementNotifier::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x77f4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto AchievementNotifier::willSwitchToScene(cocos2d::CCScene* p0) -> decltype(willSwitchToScene(p0)) {
	using FunctionType = decltype(willSwitchToScene(p0))(*)(AchievementNotifier*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x77f730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementNotifier::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementNotifier::init), this);
	using FunctionType = decltype(init())(*)(AchievementNotifier*);
	static auto func = wrapFunction(base::get() + 0x77f550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJListLayer::create(BoomListView* p0, char const* p1, cocos2d::_ccColor4B p2, float p3, float p4, int p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(BoomListView*, char const*, cocos2d::_ccColor4B, float, float, int);
	static auto func = wrapFunction(base::get() + 0x597b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto GJListLayer::init(BoomListView* p0, char const* p1, cocos2d::_ccColor4B p2, float p3, float p4, int p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(GJListLayer*, BoomListView*, char const*, cocos2d::_ccColor4B, float, float, int);
	static auto func = wrapFunction(base::get() + 0x597c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto LoadingCircle::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x49a640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LoadingCircle::fadeAndRemove() -> decltype(fadeAndRemove()) {
	using FunctionType = decltype(fadeAndRemove())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x49a970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LoadingCircle::show() -> decltype(show()) {
	using FunctionType = decltype(show())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x49a880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void LoadingCircle::setParentLayer(cocos2d::CCLayer* layer) {
        m_parentLayer = layer;
    }

void LoadingCircle::setFade(bool fade) {
        m_fade = fade;
    }

auto LoadingCircle::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::init), this);
	using FunctionType = decltype(init())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x49a7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LoadingCircle::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::draw), this);
	using FunctionType = decltype(draw())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x49aa00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LoadingCircle::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LoadingCircle::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(LoadingCircle*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x49ac80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LoadingCircle::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LoadingCircle::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(LoadingCircle*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x49ac90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LoadingCircle::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LoadingCircle::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(LoadingCircle*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x49aca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LoadingCircle::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LoadingCircle::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(LoadingCircle*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x49acb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LoadingCircle::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircle::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LoadingCircle*);
	static auto func = wrapFunction(base::get() + 0x49aa20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

AppDelegate* AppDelegate::get() {
        return static_cast<AppDelegate*>(cocos2d::CCApplication::sharedApplication());
    }

auto AppDelegate::loadingIsFinished() -> decltype(loadingIsFinished()) {
	using FunctionType = decltype(loadingIsFinished())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x61f6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::bgScale() -> decltype(bgScale()) {
	using FunctionType = decltype(bgScale())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x61f6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AppDelegate::setupGLView() -> decltype(setupGLView()) {
	throw std::runtime_error("AppDelegate::setupGLView not implemented");
}

auto AppDelegate::platformShutdown() -> decltype(platformShutdown()) {
	throw std::runtime_error("AppDelegate::platformShutdown not implemented");
}

auto AppDelegate::applicationDidFinishLaunching() -> decltype(applicationDidFinishLaunching()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationDidFinishLaunching), this);
	using FunctionType = decltype(applicationDidFinishLaunching())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x61f560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationDidEnterBackground() -> decltype(applicationDidEnterBackground()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationDidEnterBackground), this);
	using FunctionType = decltype(applicationDidEnterBackground())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x61f800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillEnterForeground() -> decltype(applicationWillEnterForeground()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillEnterForeground), this);
	using FunctionType = decltype(applicationWillEnterForeground())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x61f940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillBecomeActive() -> decltype(applicationWillBecomeActive()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillBecomeActive), this);
	using FunctionType = decltype(applicationWillBecomeActive())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x61f700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::applicationWillResignActive() -> decltype(applicationWillResignActive()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AppDelegate::applicationWillResignActive), this);
	using FunctionType = decltype(applicationWillResignActive())(*)(AppDelegate*);
	static auto func = wrapFunction(base::get() + 0x61f720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AppDelegate::trySaveGame(bool p0) -> decltype(trySaveGame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&AppDelegate::trySaveGame), this);
	using FunctionType = decltype(trySaveGame(p0))(*)(AppDelegate*, bool);
	static auto func = wrapFunction(base::get() + 0x61fbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AppDelegate::willSwitchToScene(cocos2d::CCScene* p0) -> decltype(willSwitchToScene(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCScene*>::func(&AppDelegate::willSwitchToScene), this);
	using FunctionType = decltype(willSwitchToScene(p0))(*)(AppDelegate*, cocos2d::CCScene*);
	static auto func = wrapFunction(base::get() + 0x61fcb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlatformToolbox::showCursor() -> decltype(showCursor()) {
	using FunctionType = decltype(showCursor())(*)();
	static auto func = wrapFunction(base::get() + 0x49f030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlatformToolbox::gameDidSave() -> decltype(gameDidSave()) {
	using FunctionType = decltype(gameDidSave())(*)();
	static auto func = wrapFunction(base::get() + 0x49fd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlatformToolbox::onNativeResume() -> decltype(onNativeResume()) {
	using FunctionType = decltype(onNativeResume())(*)();
	static auto func = wrapFunction(base::get() + 0x49ef00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlatformToolbox::onToggleKeyboard() -> decltype(onToggleKeyboard()) {
	using FunctionType = decltype(onToggleKeyboard())(*)();
	static auto func = wrapFunction(base::get() + 0x49ef10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlatformToolbox::toggleLockCursor(bool p0) -> decltype(toggleLockCursor(p0)) {
	using FunctionType = decltype(toggleLockCursor(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x49fe30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto PlatformToolbox::isNetworkAvailable() -> decltype(isNetworkAvailable()) {
	using FunctionType = decltype(isNetworkAvailable())(*)();
	static auto func = wrapFunction(base::get() + 0x49eec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto PlatformToolbox::isControllerConnected() -> decltype(isControllerConnected()) {
	using FunctionType = decltype(isControllerConnected())(*)();
	static auto func = wrapFunction(base::get() + 0x4a0010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LevelCommentDelegate::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadCommentsFinished(p0, p1)) {
	throw std::runtime_error("LevelCommentDelegate::loadCommentsFinished not implemented");
}

auto LevelCommentDelegate::loadCommentsFailed(char const* p0) -> decltype(loadCommentsFailed(p0)) {
	throw std::runtime_error("LevelCommentDelegate::loadCommentsFailed not implemented");
}

auto LevelCommentDelegate::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	throw std::runtime_error("LevelCommentDelegate::updateUserScoreFinished not implemented");
}

auto LevelCommentDelegate::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	throw std::runtime_error("LevelCommentDelegate::setupPageInfo not implemented");
}

auto CommentUploadDelegate::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	throw std::runtime_error("CommentUploadDelegate::commentUploadFinished not implemented");
}

auto CommentUploadDelegate::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	throw std::runtime_error("CommentUploadDelegate::commentUploadFailed not implemented");
}

auto CommentUploadDelegate::commentDeleteFailed(int p0, int p1) -> decltype(commentDeleteFailed(p0, p1)) {
	throw std::runtime_error("CommentUploadDelegate::commentDeleteFailed not implemented");
}

auto UserInfoDelegate::getUserInfoFinished(GJUserScore* p0) -> decltype(getUserInfoFinished(p0)) {
	throw std::runtime_error("UserInfoDelegate::getUserInfoFinished not implemented");
}

auto UserInfoDelegate::getUserInfoFailed(int p0) -> decltype(getUserInfoFailed(p0)) {
	throw std::runtime_error("UserInfoDelegate::getUserInfoFailed not implemented");
}

auto UserInfoDelegate::userInfoChanged(GJUserScore* p0) -> decltype(userInfoChanged(p0)) {
	throw std::runtime_error("UserInfoDelegate::userInfoChanged not implemented");
}

auto UploadActionDelegate::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	throw std::runtime_error("UploadActionDelegate::uploadActionFinished not implemented");
}

auto UploadActionDelegate::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	throw std::runtime_error("UploadActionDelegate::uploadActionFailed not implemented");
}

auto UploadPopupDelegate::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	throw std::runtime_error("UploadPopupDelegate::onClosePopup not implemented");
}

auto LevelDownloadDelegate::levelDownloadFinished(GJGameLevel* p0) -> decltype(levelDownloadFinished(p0)) {
	throw std::runtime_error("LevelDownloadDelegate::levelDownloadFinished not implemented");
}

auto LevelDownloadDelegate::levelDownloadFailed(int p0) -> decltype(levelDownloadFailed(p0)) {
	throw std::runtime_error("LevelDownloadDelegate::levelDownloadFailed not implemented");
}

auto LevelUploadDelegate::levelUploadFinished(GJGameLevel* p0) -> decltype(levelUploadFinished(p0)) {
	throw std::runtime_error("LevelUploadDelegate::levelUploadFinished not implemented");
}

auto LevelUploadDelegate::levelUploadFailed(GJGameLevel* p0) -> decltype(levelUploadFailed(p0)) {
	throw std::runtime_error("LevelUploadDelegate::levelUploadFailed not implemented");
}

void ListUploadDelegate::listUploadFinished(GJLevelList* p0) {}

void ListUploadDelegate::listUploadFailed(GJLevelList* p0, int p1) {}

auto LevelUpdateDelegate::levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) -> decltype(levelUpdateFinished(p0, p1)) {
	throw std::runtime_error("LevelUpdateDelegate::levelUpdateFinished not implemented");
}

auto LevelUpdateDelegate::levelUpdateFailed(int p0) -> decltype(levelUpdateFailed(p0)) {
	throw std::runtime_error("LevelUpdateDelegate::levelUpdateFailed not implemented");
}

auto RateLevelDelegate::rateLevelClosed() -> decltype(rateLevelClosed()) {
	throw std::runtime_error("RateLevelDelegate::rateLevelClosed not implemented");
}

void LikeItemDelegate::likedItem(LikeItemType p0, int p1, bool p2) {}

auto LevelDeleteDelegate::levelDeleteFinished(int p0) -> decltype(levelDeleteFinished(p0)) {
	throw std::runtime_error("LevelDeleteDelegate::levelDeleteFinished not implemented");
}

auto LevelDeleteDelegate::levelDeleteFailed(int p0) -> decltype(levelDeleteFailed(p0)) {
	throw std::runtime_error("LevelDeleteDelegate::levelDeleteFailed not implemented");
}

void LevelListDeleteDelegate::levelListDeleteFinished(int p0) {}

void LevelListDeleteDelegate::levelListDeleteFailed(int p0) {}

auto NumberInputDelegate::numberInputClosed(NumberInputLayer* p0) -> decltype(numberInputClosed(p0)) {
	throw std::runtime_error("NumberInputDelegate::numberInputClosed not implemented");
}

auto SetIDPopupDelegate::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	throw std::runtime_error("SetIDPopupDelegate::setIDPopupClosed not implemented");
}

void OnlineListDelegate::loadListFinished(cocos2d::CCArray* p0, char const* p1) {}

void OnlineListDelegate::loadListFailed(char const* p0) {}

void OnlineListDelegate::setupPageInfo(gd::string p0, char const* p1) {}

auto NumberInputLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x46e490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto NumberInputLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NumberInputLayer::init), this);
	using FunctionType = decltype(init())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x46e5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NumberInputLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NumberInputLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x46efc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NumberInputLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NumberInputLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x46ef50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::create(int p0, int p1, int p2, gd::string p3, gd::string p4, bool p5, int p6, float p7, bool p8, bool p9) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(int, int, int, gd::string, gd::string, bool, int, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2874a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto SetIDPopup::init(int p0, int p1, int p2, gd::string p3, gd::string p4, bool p5, int p6, float p7, bool p8, bool p9) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9))(*)(SetIDPopup*, int, int, int, gd::string, gd::string, bool, int, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2876f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
}

auto SetIDPopup::updateTextInputLabel() -> decltype(updateTextInputLabel()) {
	using FunctionType = decltype(updateTextInputLabel())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x288130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SetIDPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetIDPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x288440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetIDPopup::show), this);
	using FunctionType = decltype(show())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x2883c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetIDPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetIDPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetIDPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x288260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetIDPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetIDPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetIDPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2882a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetIDPopup::valueChanged() -> decltype(valueChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetIDPopup::valueChanged), this);
	using FunctionType = decltype(valueChanged())(*)(SetIDPopup*);
	static auto func = wrapFunction(base::get() + 0x2883b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadActionPopup::create(UploadPopupDelegate* p0, gd::string p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(UploadPopupDelegate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x280050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto UploadActionPopup::closePopup() -> decltype(closePopup()) {
	using FunctionType = decltype(closePopup())(*)(UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x280910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UploadActionPopup::showFailMessage(gd::string p0) -> decltype(showFailMessage(p0)) {
	using FunctionType = decltype(showFailMessage(p0))(*)(UploadActionPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2807d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UploadActionPopup::showSuccessMessage(gd::string p0) -> decltype(showSuccessMessage(p0)) {
	using FunctionType = decltype(showSuccessMessage(p0))(*)(UploadActionPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x280680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UploadActionPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadActionPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x280940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardManagerDelegate::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	throw std::runtime_error("LeaderboardManagerDelegate::updateUserScoreFinished not implemented");
}

auto LeaderboardManagerDelegate::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	throw std::runtime_error("LeaderboardManagerDelegate::updateUserScoreFailed not implemented");
}

auto LeaderboardManagerDelegate::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadLeaderboardFinished(p0, p1)) {
	throw std::runtime_error("LeaderboardManagerDelegate::loadLeaderboardFinished not implemented");
}

auto LeaderboardManagerDelegate::loadLeaderboardFailed(char const* p0) -> decltype(loadLeaderboardFailed(p0)) {
	throw std::runtime_error("LeaderboardManagerDelegate::loadLeaderboardFailed not implemented");
}

auto GJUserScore::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x5077a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJUserScore::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x52cbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJUserScore::isCurrentUser() -> decltype(isCurrentUser()) {
	using FunctionType = decltype(isCurrentUser())(*)(GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x52cda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJUserScore::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserScore::init), this);
	using FunctionType = decltype(init())(*)(GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x52cd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::create(int p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, bool);
	static auto func = wrapFunction(base::get() + 0x778c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto ProfilePage::init(int p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(ProfilePage*, int, bool);
	static auto func = wrapFunction(base::get() + 0x778e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ProfilePage::onMessages(cocos2d::CCObject* sender) -> decltype(onMessages(sender)) {
	using FunctionType = decltype(onMessages(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77d2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onMyLevels(cocos2d::CCObject* sender) -> decltype(onMyLevels(sender)) {
	using FunctionType = decltype(onMyLevels(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77cf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onRequests(cocos2d::CCObject* sender) -> decltype(onRequests(sender)) {
	using FunctionType = decltype(onRequests(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77d400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77d490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onBlockUser(cocos2d::CCObject* sender) -> decltype(onBlockUser(sender)) {
	using FunctionType = decltype(onBlockUser(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77cc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onSendMessage(cocos2d::CCObject* sender) -> decltype(onSendMessage(sender)) {
	using FunctionType = decltype(onSendMessage(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77c770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onCommentHistory(cocos2d::CCObject* sender) -> decltype(onCommentHistory(sender)) {
	using FunctionType = decltype(onCommentHistory(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77c730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x779940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onFollow(cocos2d::CCObject* sender) -> decltype(onFollow(sender)) {
	using FunctionType = decltype(onFollow(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x779bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onFriend(cocos2d::CCObject* sender) -> decltype(onFriend(sender)) {
	using FunctionType = decltype(onFriend(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77c880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onTwitch(cocos2d::CCObject* sender) -> decltype(onTwitch(sender)) {
	using FunctionType = decltype(onTwitch(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77c5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x779e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onComment(cocos2d::CCObject* sender) -> decltype(onComment(sender)) {
	using FunctionType = decltype(onComment(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77d4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onFriends(cocos2d::CCObject* sender) -> decltype(onFriends(sender)) {
	using FunctionType = decltype(onFriends(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77d370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onMyLists(cocos2d::CCObject* sender) -> decltype(onMyLists(sender)) {
	using FunctionType = decltype(onMyLists(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77d110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onTwitter(cocos2d::CCObject* sender) -> decltype(onTwitter(sender)) {
	using FunctionType = decltype(onTwitter(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77c490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::onYouTube(cocos2d::CCObject* sender) -> decltype(onYouTube(sender)) {
	using FunctionType = decltype(onYouTube(sender))(*)(ProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x77c340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ProfilePage::setupComments() -> decltype(setupComments()) {
	using FunctionType = decltype(setupComments())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x7799c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ProfilePage::loadPageFromUserInfo(GJUserScore* p0) -> decltype(loadPageFromUserInfo(p0)) {
	using FunctionType = decltype(loadPageFromUserInfo(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x77a170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(ProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x77a030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x77e370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::blockUser() -> decltype(blockUser()) {
	using FunctionType = decltype(blockUser())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x77d730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ProfilePage::isCorrect(char const* p0) -> decltype(isCorrect(p0)) {
	using FunctionType = decltype(isCorrect(p0))(*)(ProfilePage*, char const*);
	static auto func = wrapFunction(base::get() + 0x77e7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x77f1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x77dd50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::show), this);
	using FunctionType = decltype(show())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x77dfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&ProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(ProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x77d810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x77de60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ProfilePage::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(ProfilePage*);
	static auto func = wrapFunction(base::get() + 0x77df30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ProfilePage::getUserInfoFinished(GJUserScore* p0) -> decltype(getUserInfoFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserScore*>::func(&ProfilePage::getUserInfoFinished), this);
	using FunctionType = decltype(getUserInfoFinished(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x77e2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::getUserInfoFailed(int p0) -> decltype(getUserInfoFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&ProfilePage::getUserInfoFailed), this);
	using FunctionType = decltype(getUserInfoFailed(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x77e5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::userInfoChanged(GJUserScore* p0) -> decltype(userInfoChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserScore*>::func(&ProfilePage::userInfoChanged), this);
	using FunctionType = decltype(userInfoChanged(p0))(*)(ProfilePage*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x77e6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadCommentsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&ProfilePage::loadCommentsFinished), this);
	using FunctionType = decltype(loadCommentsFinished(p0, p1))(*)(ProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x77e8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::loadCommentsFailed(char const* p0) -> decltype(loadCommentsFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&ProfilePage::loadCommentsFailed), this);
	using FunctionType = decltype(loadCommentsFailed(p0))(*)(ProfilePage*, char const*);
	static auto func = wrapFunction(base::get() + 0x77e9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&ProfilePage::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(ProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x77ea90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&ProfilePage::commentUploadFinished), this);
	using FunctionType = decltype(commentUploadFinished(p0))(*)(ProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x77eec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, CommentError>::func(&ProfilePage::commentUploadFailed), this);
	using FunctionType = decltype(commentUploadFailed(p0, p1))(*)(ProfilePage*, int, CommentError);
	static auto func = wrapFunction(base::get() + 0x77ef50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::commentDeleteFailed(int p0, int p1) -> decltype(commentDeleteFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ProfilePage::commentDeleteFailed), this);
	using FunctionType = decltype(commentDeleteFailed(p0, p1))(*)(ProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x77f020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&ProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(ProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x77d9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ProfilePage::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(ProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x77da70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ProfilePage::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(ProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x77dc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

float SliderThumb::getValue() {
		return (this->getScaleX() * m_length * .5f +
				(m_vertical ?
					this->getPositionY() :
					this->getPositionX())
			) / (this->getScaleX() * m_length);
	}

auto SliderThumb::setValue(float p0) -> decltype(setValue(p0)) {
	using FunctionType = decltype(setValue(p0))(*)(SliderThumb*, float);
	static auto func = wrapFunction(base::get() + 0x2e0390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorChannelSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b1e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ColorChannelSprite::updateValues(ColorAction* p0) -> decltype(updateValues(p0)) {
	using FunctionType = decltype(updateValues(p0))(*)(ColorChannelSprite*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x2b2340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorChannelSprite::updateOpacity(float p0) -> decltype(updateOpacity(p0)) {
	using FunctionType = decltype(updateOpacity(p0))(*)(ColorChannelSprite*, float);
	static auto func = wrapFunction(base::get() + 0x2b20e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorChannelSprite::updateBlending(bool p0) -> decltype(updateBlending(p0)) {
	using FunctionType = decltype(updateBlending(p0))(*)(ColorChannelSprite*, bool);
	static auto func = wrapFunction(base::get() + 0x2b2230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorChannelSprite::updateCopyLabel(int p0, bool p1) -> decltype(updateCopyLabel(p0, p1)) {
	using FunctionType = decltype(updateCopyLabel(p0, p1))(*)(ColorChannelSprite*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2b1f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ColorChannelSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorChannelSprite::init), this);
	using FunctionType = decltype(init())(*)(ColorChannelSprite*);
	static auto func = wrapFunction(base::get() + 0x2b1f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void GJDropDownLayerDelegate::dropDownLayerWillClose(GJDropDownLayer* p0) {}

auto StatsCell::loadFromObject(StatsObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(StatsCell*, StatsObject*);
	static auto func = wrapFunction(base::get() + 0x225a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto StatsCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StatsCell::init), this);
	using FunctionType = decltype(init())(*)(StatsCell*);
	static auto func = wrapFunction(base::get() + 0x231150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StatsCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StatsCell::draw), this);
	using FunctionType = decltype(draw())(*)(StatsCell*);
	static auto func = wrapFunction(base::get() + 0x231bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SliderTouchLogic::create(cocos2d::CCNode* p0, cocos2d::SEL_MenuHandler p1, char const* p2, char const* p3, float p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(cocos2d::CCNode*, cocos2d::SEL_MenuHandler, char const*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x2e05b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto SliderTouchLogic::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SliderTouchLogic::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(SliderTouchLogic*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2e0a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SliderTouchLogic::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SliderTouchLogic::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(SliderTouchLogic*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2e0c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SliderTouchLogic::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SliderTouchLogic::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(SliderTouchLogic*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2e0bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SliderTouchLogic::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SliderTouchLogic::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(SliderTouchLogic*);
	static auto func = wrapFunction(base::get() + 0x2e0fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameToolbox::fast_srand(unsigned long p0) -> decltype(fast_srand(p0)) {
	using FunctionType = decltype(fast_srand(p0))(*)(unsigned long);
	static auto func = wrapFunction(base::get() + 0x4ccc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::getResponse(cocos2d::extension::CCHttpResponse* p0) -> decltype(getResponse(p0)) {
	using FunctionType = decltype(getResponse(p0))(*)(cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x4c9fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::intToString(int p0) -> decltype(intToString(p0)) {
	using FunctionType = decltype(intToString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x4d2190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::strongColor(cocos2d::_ccColor3B p0) -> decltype(strongColor(p0)) {
	using FunctionType = decltype(strongColor(p0))(*)(cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x4cc700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::addBackButton(cocos2d::CCLayer* p0, cocos2d::CCMenuItem* p1) -> decltype(addBackButton(p0, p1)) {
	using FunctionType = decltype(addBackButton(p0, p1))(*)(cocos2d::CCLayer*, cocos2d::CCMenuItem*);
	static auto func = wrapFunction(base::get() + 0x4cae40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::fast_rand_0_1() -> decltype(fast_rand_0_1()) {
	using FunctionType = decltype(fast_rand_0_1())(*)();
	static auto func = wrapFunction(base::get() + 0x4ccc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GameToolbox::getTimeString(int p0) -> decltype(getTimeString(p0)) {
	using FunctionType = decltype(getTimeString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x4cc860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::hsvFromString(gd::string const& p0, char const* p1) -> decltype(hsvFromString(p0, p1)) {
	using FunctionType = decltype(hsvFromString(p0, p1))(*)(gd::string const&, char const*);
	static auto func = wrapFunction(base::get() + 0x4cb5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::pointsToString(int p0) -> decltype(pointsToString(p0)) {
	using FunctionType = decltype(pointsToString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x4d2c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::transformColor(cocos2d::_ccColor3B const& p0, float p1, float p2, float p3) -> decltype(transformColor(p0, p1, p2, p3)) {
	using FunctionType = decltype(transformColor(p0, p1, p2, p3))(*)(cocos2d::_ccColor3B const&, float, float, float);
	static auto func = wrapFunction(base::get() + 0x4cb0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto GameToolbox::transformColor(cocos2d::_ccColor3B const& p0, cocos2d::_ccHSVValue p1) -> decltype(transformColor(p0, p1)) {
	using FunctionType = decltype(transformColor(p0, p1))(*)(cocos2d::_ccColor3B const&, cocos2d::_ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x4cb0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::doWeHaveInternet() -> decltype(doWeHaveInternet()) {
	using FunctionType = decltype(doWeHaveInternet())(*)();
	static auto func = wrapFunction(base::get() + 0x4c9d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GameToolbox::intToShortString(int p0) -> decltype(intToShortString(p0)) {
	using FunctionType = decltype(intToShortString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x4d2490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::stringSetupToMap(gd::string const& p0, char const* p1, gd::map<gd::string, gd::string>& p2) -> decltype(stringSetupToMap(p0, p1, p2)) {
	using FunctionType = decltype(stringSetupToMap(p0, p1, p2))(*)(gd::string const&, char const*, gd::map<gd::string, gd::string>&);
	static auto func = wrapFunction(base::get() + 0x4cbfa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GameToolbox::stringSetupToDict(gd::string const& p0, char const* p1) -> decltype(stringSetupToDict(p0, p1)) {
	using FunctionType = decltype(stringSetupToDict(p0, p1))(*)(gd::string const&, char const*);
	static auto func = wrapFunction(base::get() + 0x4cc230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, float p7, float p8, float p9, cocos2d::CCPoint p10, char const* p11, bool p12, int p13, cocos2d::CCArray* p14) -> decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14))(*)(gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, float, float, float, cocos2d::CCPoint, char const*, bool, int, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x4ca4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14);
}

auto GameToolbox::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, cocos2d::CCNode* p5, cocos2d::CCNode* p6, cocos2d::CCArray* p7) -> decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6, p7))(*)(gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, cocos2d::CCNode*, cocos2d::CCNode*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x4ca390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7);
}

auto GameToolbox::particleFromString(gd::string const& p0, cocos2d::CCParticleSystemQuad* p1, bool p2) -> decltype(particleFromString(p0, p1, p2)) {
	using FunctionType = decltype(particleFromString(p0, p1, p2))(*)(gd::string const&, cocos2d::CCParticleSystemQuad*, bool);
	static auto func = wrapFunction(base::get() + 0x4d1130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto GameToolbox::addRThumbScrollButton(cocos2d::CCLayer* p0) -> decltype(addRThumbScrollButton(p0)) {
	using FunctionType = decltype(addRThumbScrollButton(p0))(*)(cocos2d::CCLayer*);
	static auto func = wrapFunction(base::get() + 0x4caf10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameToolbox::alignItemsHorisontally(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2, bool p3) -> decltype(alignItemsHorisontally(p0, p1, p2, p3)) {
	using FunctionType = decltype(alignItemsHorisontally(p0, p1, p2, p3))(*)(cocos2d::CCArray*, float, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0x4c9860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto GameToolbox::particleStringToStruct(gd::string const& p0, cocos2d::ParticleStruct& p1) -> decltype(particleStringToStruct(p0, p1)) {
	using FunctionType = decltype(particleStringToStruct(p0, p1))(*)(gd::string const&, cocos2d::ParticleStruct&);
	static auto func = wrapFunction(base::get() + 0x4d01d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameToolbox::mergeDictsSaveLargestInt(cocos2d::CCDictionary* p0, cocos2d::CCDictionary* p1) -> decltype(mergeDictsSaveLargestInt(p0, p1)) {
	using FunctionType = decltype(mergeDictsSaveLargestInt(p0, p1))(*)(cocos2d::CCDictionary*, cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x4ca980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto BoomScrollLayer::create(cocos2d::CCArray* p0, int p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(cocos2d::CCArray*, int, bool);
	static auto func = wrapFunction(base::get() + 0x382bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto BoomScrollLayer::create(cocos2d::CCArray* p0, int p1, bool p2, cocos2d::CCArray* p3, DynamicScrollDelegate* p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(cocos2d::CCArray*, int, bool, cocos2d::CCArray*, DynamicScrollDelegate*);
	static auto func = wrapFunction(base::get() + 0x3827d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto BoomScrollLayer::init(cocos2d::CCArray* p0, int p1, bool p2, cocos2d::CCArray* p3, DynamicScrollDelegate* p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(BoomScrollLayer*, cocos2d::CCArray*, int, bool, cocos2d::CCArray*, DynamicScrollDelegate*);
	static auto func = wrapFunction(base::get() + 0x382860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto BoomScrollLayer::getTotalPages() -> decltype(getTotalPages()) {
	using FunctionType = decltype(getTotalPages())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x383740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto BoomScrollLayer::getPage(int p0) -> decltype(getPage(p0)) {
	using FunctionType = decltype(getPage(p0))(*)(BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x383ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto BoomScrollLayer::setPagesIndicatorPosition(cocos2d::CCPoint p0) -> decltype(setPagesIndicatorPosition(p0)) {
	using FunctionType = decltype(setPagesIndicatorPosition(p0))(*)(BoomScrollLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x382d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto BoomScrollLayer::updateDots(float p0) -> decltype(updateDots(p0)) {
	using FunctionType = decltype(updateDots(p0))(*)(BoomScrollLayer*, float);
	static auto func = wrapFunction(base::get() + 0x383770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto BoomScrollLayer::updatePages() -> decltype(updatePages()) {
	using FunctionType = decltype(updatePages())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x382d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto BoomScrollLayer::moveToPageEnded() -> decltype(moveToPageEnded()) {
	using FunctionType = decltype(moveToPageEnded())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x384070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto BoomScrollLayer::instantMoveToPage(int p0) -> decltype(instantMoveToPage(p0)) {
	using FunctionType = decltype(instantMoveToPage(p0))(*)(BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x384200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto BoomScrollLayer::togglePageIndicators(bool p0) -> decltype(togglePageIndicators(p0)) {
	using FunctionType = decltype(togglePageIndicators(p0))(*)(BoomScrollLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x383fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto BoomScrollLayer::repositionPagesLooped() -> decltype(repositionPagesLooped()) {
	using FunctionType = decltype(repositionPagesLooped())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x382e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto BoomScrollLayer::setupDynamicScrolling(cocos2d::CCArray* p0, DynamicScrollDelegate* p1) -> decltype(setupDynamicScrolling(p0, p1)) {
	using FunctionType = decltype(setupDynamicScrolling(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCArray*, DynamicScrollDelegate*);
	static auto func = wrapFunction(base::get() + 0x3834f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto BoomScrollLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&BoomScrollLayer::visit), this);
	using FunctionType = decltype(visit())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x384010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto BoomScrollLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x384b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x384c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x384f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&BoomScrollLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(BoomScrollLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x384980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto BoomScrollLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&BoomScrollLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(BoomScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x3847f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelInfoLayer::create(GJGameLevel* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x297220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelInfoLayer::init(GJGameLevel* level, bool challenge) -> decltype(init(level, challenge)) {
	using FunctionType = decltype(init(level, challenge))(*)(LevelInfoLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x2973f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, level, challenge);
}

auto LevelInfoLayer::onFavorite(cocos2d::CCObject* sender) -> decltype(onFavorite(sender)) {
	using FunctionType = decltype(onFavorite(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29c320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onAddToList(cocos2d::CCObject* sender) -> decltype(onAddToList(sender)) {
	using FunctionType = decltype(onAddToList(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29c620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29c030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateDemon(cocos2d::CCObject* sender) -> decltype(onRateDemon(sender)) {
	using FunctionType = decltype(onRateDemon(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29ba30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateStars(cocos2d::CCObject* sender) -> decltype(onRateStars(sender)) {
	using FunctionType = decltype(onRateStars(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29b8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onSetFolder(cocos2d::CCObject* sender) -> decltype(onSetFolder(sender)) {
	using FunctionType = decltype(onSetFolder(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29c580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x299740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onRateStarsMod(cocos2d::CCObject* sender) -> decltype(onRateStarsMod(sender)) {
	using FunctionType = decltype(onRateStarsMod(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29bc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLevelLeaderboard(cocos2d::CCObject* sender) -> decltype(onLevelLeaderboard(sender)) {
	using FunctionType = decltype(onLevelLeaderboard(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29b7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29bfb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29b7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onLike(cocos2d::CCObject* sender) -> decltype(onLike(sender)) {
	using FunctionType = decltype(onLike(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29b850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2997c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onGarage(cocos2d::CCObject* sender) -> decltype(onGarage(sender)) {
	using FunctionType = decltype(onGarage(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29c2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29b6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelInfoLayer::confirmClone(cocos2d::CCObject* p0) -> decltype(confirmClone(p0)) {
	using FunctionType = decltype(confirmClone(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29bd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmDelete(cocos2d::CCObject* p0) -> decltype(confirmDelete(p0)) {
	using FunctionType = decltype(confirmDelete(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29b5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::downloadLevel() -> decltype(downloadLevel()) {
	using FunctionType = decltype(downloadLevel())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x299f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::loadLevelStep() -> decltype(loadLevelStep()) {
	using FunctionType = decltype(loadLevelStep())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29deb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::tryCloneLevel(cocos2d::CCObject* p0) -> decltype(tryCloneLevel(p0)) {
	using FunctionType = decltype(tryCloneLevel(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29be90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::setupLevelInfo() -> decltype(setupLevelInfo()) {
	using FunctionType = decltype(setupLevelInfo())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29a030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::showSongWarning() -> decltype(showSongWarning()) {
	using FunctionType = decltype(showSongWarning())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29dc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::showUpdateAlert(UpdateResponse p0) -> decltype(showUpdateAlert(p0)) {
	using FunctionType = decltype(showUpdateAlert(p0))(*)(LevelInfoLayer*, UpdateResponse);
	static auto func = wrapFunction(base::get() + 0x29d7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmMoveToTop(cocos2d::CCObject* p0) -> decltype(confirmMoveToTop(p0)) {
	using FunctionType = decltype(confirmMoveToTop(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29c3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::setupProgressBars() -> decltype(setupProgressBars()) {
	using FunctionType = decltype(setupProgressBars())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29aec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::updateLabelValues() -> decltype(updateLabelValues()) {
	using FunctionType = decltype(updateLabelValues())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29c920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::updateSideButtons() -> decltype(updateSideButtons()) {
	using FunctionType = decltype(updateSideButtons())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29ba90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::confirmOwnerDelete(cocos2d::CCObject* p0) -> decltype(confirmOwnerDelete(p0)) {
	using FunctionType = decltype(confirmOwnerDelete(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29bc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::confirmMoveToBottom(cocos2d::CCObject* p0) -> decltype(confirmMoveToBottom(p0)) {
	using FunctionType = decltype(confirmMoveToBottom(p0))(*)(LevelInfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x29c480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelInfoLayer::setupPlatformerStats() -> decltype(setupPlatformerStats()) {
	using FunctionType = decltype(setupPlatformerStats())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29ab80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::playStep2() -> decltype(playStep2()) {
	using FunctionType = decltype(playStep2())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29dd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::playStep3() -> decltype(playStep3()) {
	using FunctionType = decltype(playStep3())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29de20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::playStep4() -> decltype(playStep4()) {
	using FunctionType = decltype(playStep4())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29df60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelInfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29e8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelInfoLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelInfoLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelInfoLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x29e920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::numberInputClosed(NumberInputLayer* p0) -> decltype(numberInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<NumberInputLayer*>::func(&LevelInfoLayer::numberInputClosed), this);
	using FunctionType = decltype(numberInputClosed(p0))(*)(LevelInfoLayer*, NumberInputLayer*);
	static auto func = wrapFunction(base::get() + 0x29e130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&LevelInfoLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(LevelInfoLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x29c680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto LevelInfoLayer::levelDownloadFinished(GJGameLevel* p0) -> decltype(levelDownloadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&LevelInfoLayer::levelDownloadFinished), this);
	using FunctionType = decltype(levelDownloadFinished(p0))(*)(LevelInfoLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x29d300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDownloadFailed(int p0) -> decltype(levelDownloadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDownloadFailed), this);
	using FunctionType = decltype(levelDownloadFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x29d690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelUpdateFinished(GJGameLevel* p0, UpdateResponse p1) -> decltype(levelUpdateFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*, UpdateResponse>::func(&LevelInfoLayer::levelUpdateFinished), this);
	using FunctionType = decltype(levelUpdateFinished(p0, p1))(*)(LevelInfoLayer*, GJGameLevel*, UpdateResponse);
	static auto func = wrapFunction(base::get() + 0x29d780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelInfoLayer::levelUpdateFailed(int p0) -> decltype(levelUpdateFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelUpdateFailed), this);
	using FunctionType = decltype(levelUpdateFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x29d970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDeleteFinished(int p0) -> decltype(levelDeleteFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDeleteFinished), this);
	using FunctionType = decltype(levelDeleteFinished(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x29da70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::levelDeleteFailed(int p0) -> decltype(levelDeleteFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelInfoLayer::levelDeleteFailed), this);
	using FunctionType = decltype(levelDeleteFailed(p0))(*)(LevelInfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x29db80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelInfoLayer::rateLevelClosed() -> decltype(rateLevelClosed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelInfoLayer::rateLevelClosed), this);
	using FunctionType = decltype(rateLevelClosed())(*)(LevelInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x29e5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelInfoLayer::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&LevelInfoLayer::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(LevelInfoLayer*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0x29e610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelInfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelInfoLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelInfoLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x29e720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelInfoLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelInfoLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelInfoLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x29c7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCSpritePlus::addFollower(cocos2d::CCNode* p0) -> decltype(addFollower(p0)) {
	using FunctionType = decltype(addFollower(p0))(*)(CCSpritePlus*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x45e810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCSpritePlus::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x45e690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x45e710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x45e790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCSpritePlus::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(CCSpritePlus*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x45e2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x45e370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x45e3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCSpritePlus::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(CCSpritePlus*, float);
	static auto func = wrapFunction(base::get() + 0x45e470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&CCSpritePlus::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(CCSpritePlus*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x45e2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::initWithSpriteFrameName(char const* p0) -> decltype(initWithSpriteFrameName(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CCSpritePlus::initWithSpriteFrameName), this);
	using FunctionType = decltype(initWithSpriteFrameName(p0))(*)(CCSpritePlus*, char const*);
	static auto func = wrapFunction(base::get() + 0x45e2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCSpritePlus::setFlipX), this);
	using FunctionType = decltype(setFlipX(p0))(*)(CCSpritePlus*, bool);
	static auto func = wrapFunction(base::get() + 0x45e4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpritePlus::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCSpritePlus::setFlipY), this);
	using FunctionType = decltype(setFlipY(p0))(*)(CCSpritePlus*, bool);
	static auto func = wrapFunction(base::get() + 0x45e5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::init(char const* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x569ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

GameObject::GameObject() : GameObject(geode::CutoffConstructor, sizeof(GameObject)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	GameObject::~GameObject();
	using FunctionType = void(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d3710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::getGroupID(int p0) -> decltype(getGroupID(p0)) {
	using FunctionType = decltype(getGroupID(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x585ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::getColorKey(bool p0, bool p1) -> decltype(getColorKey(p0, p1)) {
	using FunctionType = decltype(getColorKey(p0, p1))(*)(GameObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x586990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameObject::getLastPosition() -> decltype(getLastPosition()) {
	using FunctionType = decltype(getLastPosition())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x590f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::getObjectRadius() -> decltype(getObjectRadius()) {
	using FunctionType = decltype(getObjectRadius())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5915e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::getObjectZOrder() -> decltype(getObjectZOrder()) {
	using FunctionType = decltype(getObjectZOrder())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x585820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::getGroupDisabled() -> decltype(getGroupDisabled()) {
	using FunctionType = decltype(getGroupDisabled())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x586250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::getActiveColorForMode(int p0, bool p1) -> decltype(getActiveColorForMode(p0, p1)) {
	using FunctionType = decltype(getActiveColorForMode(p0, p1))(*)(GameObject*, int, bool);
	static auto func = wrapFunction(base::get() + 0x590d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameObject::getStartPos() -> decltype(getStartPos()) {
	using FunctionType = decltype(getStartPos())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::copyGroups(GameObject* p0) -> decltype(copyGroups(p0)) {
	using FunctionType = decltype(copyGroups(p0))(*)(GameObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x585f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::removeGlow() -> decltype(removeGlow()) {
	using FunctionType = decltype(removeGlow())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x56c6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::commonSetup() -> decltype(commonSetup()) {
	using FunctionType = decltype(commonSetup())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x569f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::createWithKey(int p0) -> decltype(createWithKey(p0)) {
	using FunctionType = decltype(createWithKey(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x565320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::disableObject() -> decltype(disableObject()) {
	using FunctionType = decltype(disableObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5849e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isSpeedObject() -> decltype(isSpeedObject()) {
	using FunctionType = decltype(isSpeedObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x591560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::assignUniqueID() -> decltype(assignUniqueID()) {
	using FunctionType = decltype(assignUniqueID())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x56a1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::deselectObject() -> decltype(deselectObject()) {
	using FunctionType = decltype(deselectObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x58f330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isColorTrigger() -> decltype(isColorTrigger()) {
	using FunctionType = decltype(isColorTrigger())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x591490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::updateStartPos() -> decltype(updateStartPos()) {
	using FunctionType = decltype(updateStartPos())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x571590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::createWithFrame(char const* p0) -> decltype(createWithFrame(p0)) {
	using FunctionType = decltype(createWithFrame(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x569e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameObject::playShineEffect() -> decltype(playShineEffect()) {
	using FunctionType = decltype(playShineEffect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x584a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::groupWasDisabled() -> decltype(groupWasDisabled()) {
	using FunctionType = decltype(groupWasDisabled())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x586280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::isSettingsObject() -> decltype(isSettingsObject()) {
	using FunctionType = decltype(isSettingsObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x591b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::objectFromVector(gd::vector<gd::string>& p0, gd::vector<void*>& p1, GJBaseGameLayer* p2, bool p3) -> decltype(objectFromVector(p0, p1, p2, p3)) {
	using FunctionType = decltype(objectFromVector(p0, p1, p2, p3))(*)(gd::vector<gd::string>&, gd::vector<void*>&, GJBaseGameLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5875c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto GameObject::updateIsOriented() -> decltype(updateIsOriented()) {
	using FunctionType = decltype(updateIsOriented())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x58fb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::hasSecondaryColor() -> decltype(hasSecondaryColor()) {
	using FunctionType = decltype(hasSecondaryColor())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5900c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::updateCustomScaleX(float p0) -> decltype(updateCustomScaleX(p0)) {
	using FunctionType = decltype(updateCustomScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x571970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::updateCustomScaleY(float p0) -> decltype(updateCustomScaleY(p0)) {
	using FunctionType = decltype(updateCustomScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5719f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::addColorSpriteToSelf() -> decltype(addColorSpriteToSelf()) {
	using FunctionType = decltype(addColorSpriteToSelf())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x585840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::createAndAddParticle(int p0, char const* p1, int p2, cocos2d::tCCPositionType p3) -> decltype(createAndAddParticle(p0, p1, p2, p3)) {
	using FunctionType = decltype(createAndAddParticle(p0, p1, p2, p3))(*)(GameObject*, int, char const*, int, cocos2d::tCCPositionType);
	static auto func = wrapFunction(base::get() + 0x57ce00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameObject::createGroupContainer(int p0) -> decltype(createGroupContainer(p0)) {
	using FunctionType = decltype(createGroupContainer(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x585d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::addColorSpriteToParent(bool p0) -> decltype(addColorSpriteToParent(p0)) {
	using FunctionType = decltype(addColorSpriteToParent(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x571da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameObject::determineSlopeDirection() -> decltype(determineSlopeDirection()) {
	using FunctionType = decltype(determineSlopeDirection())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x585940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::updateObjectEditorColor() -> decltype(updateObjectEditorColor()) {
	using FunctionType = decltype(updateObjectEditorColor())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x58f350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameObject::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::update), this);
	using FunctionType = decltype(update(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x572160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x583940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5839e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x583a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&GameObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(GameObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x5833c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x584180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x583630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x583700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5837c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x583de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&GameObject::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(GameObject*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x56a0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setChildColor(cocos2d::_ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&GameObject::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(GameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x58eec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setFlipX), this);
	using FunctionType = decltype(setFlipX(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5838a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setFlipY), this);
	using FunctionType = decltype(setFlipY(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5838f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::firstSetup() -> decltype(firstSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::firstSetup), this);
	using FunctionType = decltype(firstSetup())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1a3ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x572170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string>::func(&GameObject::setupCustomSprites), this);
	using FunctionType = decltype(setupCustomSprites(p0))(*)(GameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4220f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::addMainSpriteToParent), this);
	using FunctionType = decltype(addMainSpriteToParent(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x585650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x571620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*, int, gd::vector<int> const*>::func(&GameObject::triggerObject), this);
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(GameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1a3820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GameObject::activateObject() -> decltype(activateObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::activateObject), this);
	using FunctionType = decltype(activateObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x571c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x571fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::transferObjectRect(cocos2d::CCRect& p0) -> decltype(transferObjectRect(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCRect&>::func(&GameObject::transferObjectRect), this);
	using FunctionType = decltype(transferObjectRect(p0))(*)(GameObject*, cocos2d::CCRect&);
	static auto func = wrapFunction(base::get() + 0x582cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getObjectRect() -> decltype(getObjectRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRect), this);
	using FunctionType = decltype(getObjectRect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x582d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectRect(float p0, float p1) -> decltype(getObjectRect(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&GameObject::getObjectRect), this);
	using FunctionType = decltype(getObjectRect(p0, p1))(*)(GameObject*, float, float);
	static auto func = wrapFunction(base::get() + 0x582d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameObject::getObjectRect2(float p0, float p1) -> decltype(getObjectRect2(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&GameObject::getObjectRect2), this);
	using FunctionType = decltype(getObjectRect2(p0, p1))(*)(GameObject*, float, float);
	static auto func = wrapFunction(base::get() + 0x582f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameObject::getObjectTextureRect() -> decltype(getObjectTextureRect()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectTextureRect), this);
	using FunctionType = decltype(getObjectTextureRect())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x583060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getRealPosition() -> decltype(getRealPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getRealPosition), this);
	using FunctionType = decltype(getRealPosition())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x583300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setStartPos(cocos2d::CCPoint p0) -> decltype(setStartPos(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&GameObject::setStartPos), this);
	using FunctionType = decltype(setStartPos(p0))(*)(GameObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x571510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateStartValues() -> decltype(updateStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::updateStartValues), this);
	using FunctionType = decltype(updateStartValues())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x571a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::vector<gd::string>&, gd::vector<void*>&>::func(&GameObject::customObjectSetup), this);
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(GameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x37a860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&GameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(GameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x588f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::claimParticle() -> decltype(claimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::claimParticle), this);
	using FunctionType = decltype(claimParticle())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5842e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::unclaimParticle() -> decltype(unclaimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::unclaimParticle), this);
	using FunctionType = decltype(unclaimParticle())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5848d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::particleWasActivated() -> decltype(particleWasActivated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::particleWasActivated), this);
	using FunctionType = decltype(particleWasActivated())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x584940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::isFlipX() -> decltype(isFlipX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isFlipX), this);
	using FunctionType = decltype(isFlipX())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x583880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::isFlipY() -> decltype(isFlipY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isFlipY), this);
	using FunctionType = decltype(isFlipY())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x583890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setRScaleX(float p0) -> decltype(setRScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRScaleX), this);
	using FunctionType = decltype(setRScaleX(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x583b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRScaleY(float p0) -> decltype(setRScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRScaleY), this);
	using FunctionType = decltype(setRScaleY(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x583b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setRScale(float p0) -> decltype(setRScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRScale), this);
	using FunctionType = decltype(setRScale(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x583ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getRScaleX() -> decltype(getRScaleX()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getRScaleX), this);
	using FunctionType = decltype(getRScaleX())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x583c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getRScaleY() -> decltype(getRScaleY()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getRScaleY), this);
	using FunctionType = decltype(getRScaleY())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x583c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setRRotation(float p0) -> decltype(setRRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::setRRotation), this);
	using FunctionType = decltype(setRRotation(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5835b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GameObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(GameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1d2940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setObjectColor(cocos2d::_ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&GameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(GameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x58ebe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::setGlowColor(cocos2d::_ccColor3B const& p0) -> decltype(setGlowColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&GameObject::setGlowColor), this);
	using FunctionType = decltype(setGlowColor(p0))(*)(GameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x58ee70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::restoreObject() -> decltype(restoreObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::restoreObject), this);
	using FunctionType = decltype(restoreObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x584980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::animationTriggered() -> decltype(animationTriggered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::animationTriggered), this);
	using FunctionType = decltype(animationTriggered())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::selectObject(cocos2d::_ccColor3B p0) -> decltype(selectObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B>::func(&GameObject::selectObject), this);
	using FunctionType = decltype(selectObject(p0))(*)(GameObject*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x58ef30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::activatedByPlayer(PlayerObject* p0) -> decltype(activatedByPlayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&GameObject::activatedByPlayer), this);
	using FunctionType = decltype(activatedByPlayer(p0))(*)(GameObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x1d2960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::hasBeenActivatedByPlayer(PlayerObject* p0) -> decltype(hasBeenActivatedByPlayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&GameObject::hasBeenActivatedByPlayer), this);
	using FunctionType = decltype(hasBeenActivatedByPlayer(p0))(*)(GameObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x1d2970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::hasBeenActivated() -> decltype(hasBeenActivated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::hasBeenActivated), this);
	using FunctionType = decltype(hasBeenActivated())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getOrientedBox() -> decltype(getOrientedBox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getOrientedBox), this);
	using FunctionType = decltype(getOrientedBox())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x58f940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::updateOrientedBox() -> decltype(updateOrientedBox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::updateOrientedBox), this);
	using FunctionType = decltype(updateOrientedBox())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x58f9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectRotation() -> decltype(getObjectRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRotation), this);
	using FunctionType = decltype(getObjectRotation())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x5979f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::updateMainColor(cocos2d::_ccColor3B const& p0) -> decltype(updateMainColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&GameObject::updateMainColor), this);
	using FunctionType = decltype(updateMainColor(p0))(*)(GameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x5905c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateSecondaryColor(cocos2d::_ccColor3B const& p0) -> decltype(updateSecondaryColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&GameObject::updateSecondaryColor), this);
	using FunctionType = decltype(updateSecondaryColor(p0))(*)(GameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x590ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::addToGroup(int p0) -> decltype(addToGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x585db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::removeFromGroup(int p0) -> decltype(removeFromGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x585e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::saveActiveColors() -> decltype(saveActiveColors()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::saveActiveColors), this);
	using FunctionType = decltype(saveActiveColors())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x58ea40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::spawnXPosition() -> decltype(spawnXPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::spawnXPosition), this);
	using FunctionType = decltype(spawnXPosition())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::canAllowMultiActivate() -> decltype(canAllowMultiActivate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::canAllowMultiActivate), this);
	using FunctionType = decltype(canAllowMultiActivate())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d29b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::blendModeChanged() -> decltype(blendModeChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::blendModeChanged), this);
	using FunctionType = decltype(blendModeChanged())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d29c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::updateParticleColor(cocos2d::_ccColor3B const& p0) -> decltype(updateParticleColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&GameObject::updateParticleColor), this);
	using FunctionType = decltype(updateParticleColor(p0))(*)(GameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x58edb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateParticleOpacity(unsigned char p0) -> decltype(updateParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::updateParticleOpacity), this);
	using FunctionType = decltype(updateParticleOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x584100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateMainParticleOpacity(unsigned char p0) -> decltype(updateMainParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::updateMainParticleOpacity), this);
	using FunctionType = decltype(updateMainParticleOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1d29d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateSecondaryParticleOpacity(unsigned char p0) -> decltype(updateSecondaryParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GameObject::updateSecondaryParticleOpacity), this);
	using FunctionType = decltype(updateSecondaryParticleOpacity(p0))(*)(GameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1d29e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::canReverse() -> decltype(canReverse()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::canReverse), this);
	using FunctionType = decltype(canReverse())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d29f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::isSpecialSpawnObject() -> decltype(isSpecialSpawnObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::isSpecialSpawnObject), this);
	using FunctionType = decltype(isSpecialSpawnObject())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::canBeOrdered() -> decltype(canBeOrdered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::canBeOrdered), this);
	using FunctionType = decltype(canBeOrdered())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectLabel() -> decltype(getObjectLabel()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectLabel), this);
	using FunctionType = decltype(getObjectLabel())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setObjectLabel(cocos2d::CCLabelBMFont* p0) -> decltype(setObjectLabel(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCLabelBMFont*>::func(&GameObject::setObjectLabel), this);
	using FunctionType = decltype(setObjectLabel(p0))(*)(GameObject*, cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x1d2a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::shouldDrawEditorHitbox() -> decltype(shouldDrawEditorHitbox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::shouldDrawEditorHitbox), this);
	using FunctionType = decltype(shouldDrawEditorHitbox())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x591c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getHasSyncedAnimation() -> decltype(getHasSyncedAnimation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getHasSyncedAnimation), this);
	using FunctionType = decltype(getHasSyncedAnimation())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getHasRotateAction() -> decltype(getHasRotateAction()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getHasRotateAction), this);
	using FunctionType = decltype(getHasRotateAction())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::canMultiActivate(bool p0) -> decltype(canMultiActivate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::canMultiActivate), this);
	using FunctionType = decltype(canMultiActivate(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1d2a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameObject::updateTextKerning), this);
	using FunctionType = decltype(updateTextKerning(p0))(*)(GameObject*, int);
	static auto func = wrapFunction(base::get() + 0x1d2a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getTextKerning() -> decltype(getTextKerning()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getTextKerning), this);
	using FunctionType = decltype(getTextKerning())(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::getObjectRectDirty() const  -> decltype(getObjectRectDirty()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getObjectRectDirty), this);
	using FunctionType = decltype(getObjectRectDirty())(*)(GameObject const *);
	static auto func = wrapFunction(base::get() + 0x1d2a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setObjectRectDirty(bool p0) -> decltype(setObjectRectDirty(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setObjectRectDirty), this);
	using FunctionType = decltype(setObjectRectDirty(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1d2aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getOrientedRectDirty() const  -> decltype(getOrientedRectDirty()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getOrientedRectDirty), this);
	using FunctionType = decltype(getOrientedRectDirty())(*)(GameObject const *);
	static auto func = wrapFunction(base::get() + 0x1d2ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setOrientedRectDirty(bool p0) -> decltype(setOrientedRectDirty(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&GameObject::setOrientedRectDirty), this);
	using FunctionType = decltype(setOrientedRectDirty(p0))(*)(GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1d2ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObject::getType() const  -> decltype(getType()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameObject::getType), this);
	using FunctionType = decltype(getType())(*)(GameObject const *);
	static auto func = wrapFunction(base::get() + 0x1d2ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameObject::setType(GameObjectType p0) -> decltype(setType(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GameObjectType>::func(&GameObject::setType), this);
	using FunctionType = decltype(setType(p0))(*)(GameObject*, GameObjectType);
	static auto func = wrapFunction(base::get() + 0x1d2ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::init(char const* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EnhancedGameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x591c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EnhancedGameObject::updateUserCoin() -> decltype(updateUserCoin()) {
	using FunctionType = decltype(updateUserCoin())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x588e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EnhancedGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EnhancedGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x592260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EnhancedGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x592740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x591f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EnhancedGameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(EnhancedGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x595600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EnhancedGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EnhancedGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x595660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EnhancedGameObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(EnhancedGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x5920f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::restoreObject() -> decltype(restoreObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::restoreObject), this);
	using FunctionType = decltype(restoreObject())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x592020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::animationTriggered() -> decltype(animationTriggered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::animationTriggered), this);
	using FunctionType = decltype(animationTriggered())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5921c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::activatedByPlayer(PlayerObject* p0) -> decltype(activatedByPlayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&EnhancedGameObject::activatedByPlayer), this);
	using FunctionType = decltype(activatedByPlayer(p0))(*)(EnhancedGameObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x592100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::hasBeenActivatedByPlayer(PlayerObject* p0) -> decltype(hasBeenActivatedByPlayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*>::func(&EnhancedGameObject::hasBeenActivatedByPlayer), this);
	using FunctionType = decltype(hasBeenActivatedByPlayer(p0))(*)(EnhancedGameObject*, PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x592150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::hasBeenActivated() -> decltype(hasBeenActivated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::hasBeenActivated), this);
	using FunctionType = decltype(hasBeenActivated())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5921a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::saveActiveColors() -> decltype(saveActiveColors()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::saveActiveColors), this);
	using FunctionType = decltype(saveActiveColors())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x5921e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::canAllowMultiActivate() -> decltype(canAllowMultiActivate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::canAllowMultiActivate), this);
	using FunctionType = decltype(canAllowMultiActivate())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x591c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::getHasSyncedAnimation() -> decltype(getHasSyncedAnimation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::getHasSyncedAnimation), this);
	using FunctionType = decltype(getHasSyncedAnimation())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::getHasRotateAction() -> decltype(getHasRotateAction()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::getHasRotateAction), this);
	using FunctionType = decltype(getHasRotateAction())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::canMultiActivate(bool p0) -> decltype(canMultiActivate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EnhancedGameObject::canMultiActivate), this);
	using FunctionType = decltype(canMultiActivate(p0))(*)(EnhancedGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x5920d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::powerOnObject(int p0) -> decltype(powerOnObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&EnhancedGameObject::powerOnObject), this);
	using FunctionType = decltype(powerOnObject(p0))(*)(EnhancedGameObject*, int);
	static auto func = wrapFunction(base::get() + 0x592060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::powerOffObject() -> decltype(powerOffObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnhancedGameObject::powerOffObject), this);
	using FunctionType = decltype(powerOffObject())(*)(EnhancedGameObject*);
	static auto func = wrapFunction(base::get() + 0x592080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnhancedGameObject::stateSensitiveOff(GJBaseGameLayer* p0) -> decltype(stateSensitiveOff(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EnhancedGameObject::stateSensitiveOff), this);
	using FunctionType = decltype(stateSensitiveOff(p0))(*)(EnhancedGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a38c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&EnhancedGameObject::updateSyncedAnimation), this);
	using FunctionType = decltype(updateSyncedAnimation(p0, p1))(*)(EnhancedGameObject*, float, int);
	static auto func = wrapFunction(base::get() + 0x239c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EnhancedGameObject::updateAnimateOnTrigger(bool p0) -> decltype(updateAnimateOnTrigger(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EnhancedGameObject::updateAnimateOnTrigger), this);
	using FunctionType = decltype(updateAnimateOnTrigger(p0))(*)(EnhancedGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x23bba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x1a1820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto EffectGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(EffectGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1a1ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EffectGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EffectGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x186dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

EffectGameObject::EffectGameObject() : EffectGameObject(geode::CutoffConstructor, sizeof(EffectGameObject)) {
	// here we construct it as normal as we can, then destruct it
	// using the generated functions. this ensures no memory gets leaked
	// no crashes :pray:
	CCDestructor::lock(this) = true;
	EffectGameObject::~EffectGameObject();
	using FunctionType = void(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d33f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
}

auto EffectGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&EffectGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(EffectGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1a1c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::firstSetup() -> decltype(firstSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::firstSetup), this);
	using FunctionType = decltype(firstSetup())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a3b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x185c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EffectGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EffectGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x17b7a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::setRScaleX(float p0) -> decltype(setRScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EffectGameObject::setRScaleX), this);
	using FunctionType = decltype(setRScaleX(p0))(*)(EffectGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1a18b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::setRScaleY(float p0) -> decltype(setRScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EffectGameObject::setRScaleY), this);
	using FunctionType = decltype(setRScaleY(p0))(*)(EffectGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1a18d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EffectGameObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(EffectGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1a3b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::restoreObject() -> decltype(restoreObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::restoreObject), this);
	using FunctionType = decltype(restoreObject())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a38d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::spawnXPosition() -> decltype(spawnXPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::spawnXPosition), this);
	using FunctionType = decltype(spawnXPosition())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a3ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::canReverse() -> decltype(canReverse()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::canReverse), this);
	using FunctionType = decltype(canReverse())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a3c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::isSpecialSpawnObject() -> decltype(isSpecialSpawnObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::isSpecialSpawnObject), this);
	using FunctionType = decltype(isSpecialSpawnObject())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a3ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::canBeOrdered() -> decltype(canBeOrdered()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::canBeOrdered), this);
	using FunctionType = decltype(canBeOrdered())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a3cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::getObjectLabel() -> decltype(getObjectLabel()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EffectGameObject::getObjectLabel), this);
	using FunctionType = decltype(getObjectLabel())(*)(EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EffectGameObject::setObjectLabel(cocos2d::CCLabelBMFont* p0) -> decltype(setObjectLabel(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCLabelBMFont*>::func(&EffectGameObject::setObjectLabel), this);
	using FunctionType = decltype(setObjectLabel(p0))(*)(EffectGameObject*, cocos2d::CCLabelBMFont*);
	static auto func = wrapFunction(base::get() + 0x1d2c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EffectGameObject::stateSensitiveOff(GJBaseGameLayer* p0) -> decltype(stateSensitiveOff(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EffectGameObject::stateSensitiveOff), this);
	using FunctionType = decltype(stateSensitiveOff(p0))(*)(EffectGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a3830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextGameObject::updateTextObject(gd::string p0, bool p1) -> decltype(updateTextObject(p0, p1)) {
	using FunctionType = decltype(updateTextObject(p0, p1))(*)(TextGameObject*, gd::string, bool);
	static auto func = wrapFunction(base::get() + 0x596ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TextGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TextGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x597170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TextGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TextGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TextGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x597280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextGameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TextGameObject::updateTextKerning), this);
	using FunctionType = decltype(updateTextKerning(p0))(*)(TextGameObject*, int);
	static auto func = wrapFunction(base::get() + 0x596ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TextGameObject::getTextKerning() -> decltype(getTextKerning()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TextGameObject::getTextKerning), this);
	using FunctionType = decltype(getTextKerning())(*)(TextGameObject*);
	static auto func = wrapFunction(base::get() + 0x597b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SmartGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SmartGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x19a5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SmartGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SmartGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SmartGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19a110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::updateParticle() -> decltype(updateParticle()) {
	using FunctionType = decltype(updateParticle())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19b470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ParticleGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ParticleGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x19a850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ParticleGameObject::updateParticleAngle(float p0, cocos2d::CCParticleSystemQuad* p1) -> decltype(updateParticleAngle(p0, p1)) {
	using FunctionType = decltype(updateParticleAngle(p0, p1))(*)(ParticleGameObject*, float, cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0x19b0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ParticleGameObject::updateParticleStruct() -> decltype(updateParticleStruct()) {
	using FunctionType = decltype(updateParticleStruct())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19ac10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ParticleGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::init), this);
	using FunctionType = decltype(init())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19a820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x19b8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x19b910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x19b980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x19b7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setRotationX(float p0) -> decltype(setRotationX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setRotationX), this);
	using FunctionType = decltype(setRotationX(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x19b820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setRotationY(float p0) -> decltype(setRotationY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ParticleGameObject::setRotationY), this);
	using FunctionType = decltype(setRotationY(p0))(*)(ParticleGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x19b860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::setChildColor(cocos2d::_ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&ParticleGameObject::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(ParticleGameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19bae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19aa90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&ParticleGameObject::addMainSpriteToParent), this);
	using FunctionType = decltype(addMainSpriteToParent(p0))(*)(ParticleGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x19ab60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19bcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&ParticleGameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(ParticleGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x19bc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ParticleGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ParticleGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19bed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::claimParticle() -> decltype(claimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::claimParticle), this);
	using FunctionType = decltype(claimParticle())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19ac40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::unclaimParticle() -> decltype(unclaimParticle()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::unclaimParticle), this);
	using FunctionType = decltype(unclaimParticle())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19b1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::particleWasActivated() -> decltype(particleWasActivated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::particleWasActivated), this);
	using FunctionType = decltype(particleWasActivated())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19b270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::setObjectColor(cocos2d::_ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&ParticleGameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(ParticleGameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19b9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::blendModeChanged() -> decltype(blendModeChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticleGameObject::blendModeChanged), this);
	using FunctionType = decltype(blendModeChanged())(*)(ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19ab20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticleGameObject::updateParticleColor(cocos2d::_ccColor3B const& p0) -> decltype(updateParticleColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&ParticleGameObject::updateParticleColor), this);
	using FunctionType = decltype(updateParticleColor(p0))(*)(ParticleGameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1d2bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::updateParticleOpacity(unsigned char p0) -> decltype(updateParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&ParticleGameObject::updateParticleOpacity), this);
	using FunctionType = decltype(updateParticleOpacity(p0))(*)(ParticleGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1d2c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::updateMainParticleOpacity(unsigned char p0) -> decltype(updateMainParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&ParticleGameObject::updateMainParticleOpacity), this);
	using FunctionType = decltype(updateMainParticleOpacity(p0))(*)(ParticleGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x19bbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::updateSecondaryParticleOpacity(unsigned char p0) -> decltype(updateSecondaryParticleOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&ParticleGameObject::updateSecondaryParticleOpacity), this);
	using FunctionType = decltype(updateSecondaryParticleOpacity(p0))(*)(ParticleGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x19bc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ParticleGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&ParticleGameObject::updateSyncedAnimation), this);
	using FunctionType = decltype(updateSyncedAnimation(p0, p1))(*)(ParticleGameObject*, float, int);
	static auto func = wrapFunction(base::get() + 0x19bd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ParticleGameObject::updateAnimateOnTrigger(bool p0) -> decltype(updateAnimateOnTrigger(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&ParticleGameObject::updateAnimateOnTrigger), this);
	using FunctionType = decltype(updateAnimateOnTrigger(p0))(*)(ParticleGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x19be80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpecialAnimGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SpecialAnimGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x19c940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SpecialAnimGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SpecialAnimGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(SpecialAnimGameObject*);
	static auto func = wrapFunction(base::get() + 0x19c920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SpecialAnimGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SpecialAnimGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SpecialAnimGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19c9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpecialAnimGameObject::updateMainColor(cocos2d::_ccColor3B const& p0) -> decltype(updateMainColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&SpecialAnimGameObject::updateMainColor), this);
	using FunctionType = decltype(updateMainColor(p0))(*)(SpecialAnimGameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19c8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpecialAnimGameObject::updateSecondaryColor(cocos2d::_ccColor3B const& p0) -> decltype(updateSecondaryColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&SpecialAnimGameObject::updateSecondaryColor), this);
	using FunctionType = decltype(updateSecondaryColor(p0))(*)(SpecialAnimGameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19c900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpecialAnimGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&SpecialAnimGameObject::updateSyncedAnimation), this);
	using FunctionType = decltype(updateSyncedAnimation(p0, p1))(*)(SpecialAnimGameObject*, float, int);
	static auto func = wrapFunction(base::get() + 0x23ba50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RingObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(RingObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x19d110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto RingObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&RingObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(RingObject*, float);
	static auto func = wrapFunction(base::get() + 0x19d080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&RingObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(RingObject*, float);
	static auto func = wrapFunction(base::get() + 0x19d0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RingObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(RingObject*);
	static auto func = wrapFunction(base::get() + 0x19d060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RingObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&RingObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(RingObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19d260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::setRScale(float p0) -> decltype(setRScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&RingObject::setRScale), this);
	using FunctionType = decltype(setRScale(p0))(*)(RingObject*, float);
	static auto func = wrapFunction(base::get() + 0x19d0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&RingObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(RingObject*, float);
	static auto func = wrapFunction(base::get() + 0x19cf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RingObject::shouldDrawEditorHitbox() -> decltype(shouldDrawEditorHitbox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RingObject::shouldDrawEditorHitbox), this);
	using FunctionType = decltype(shouldDrawEditorHitbox())(*)(RingObject*);
	static auto func = wrapFunction(base::get() + 0x19d0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RingObject::powerOnObject(int p0) -> decltype(powerOnObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&RingObject::powerOnObject), this);
	using FunctionType = decltype(powerOnObject(p0))(*)(RingObject*, int);
	static auto func = wrapFunction(base::get() + 0x19cf10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto StartPosObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(StartPosObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1a59d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto StartPosObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StartPosObject::init), this);
	using FunctionType = decltype(init())(*)(StartPosObject*);
	static auto func = wrapFunction(base::get() + 0x1a5880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StartPosObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&StartPosObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(StartPosObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a59e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::updateLabel(gd::string p0) -> decltype(updateLabel(p0)) {
	using FunctionType = decltype(updateLabel(p0))(*)(LabelGameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1a8d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LabelGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(LabelGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1a8eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LabelGameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	using FunctionType = decltype(setupCustomSprites(p0))(*)(LabelGameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1a8490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LabelGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LabelGameObject::init), this);
	using FunctionType = decltype(init())(*)(LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a8460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LabelGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&LabelGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(LabelGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1a8840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::addMainSpriteToParent(bool p0) -> decltype(addMainSpriteToParent(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&LabelGameObject::addMainSpriteToParent), this);
	using FunctionType = decltype(addMainSpriteToParent(p0))(*)(LabelGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x1a9120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LabelGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a9d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LabelGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&LabelGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(LabelGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a9180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::setObjectColor(cocos2d::_ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&LabelGameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(LabelGameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1a90d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::updateTextKerning(int p0) -> decltype(updateTextKerning(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LabelGameObject::updateTextKerning), this);
	using FunctionType = decltype(updateTextKerning(p0))(*)(LabelGameObject*, int);
	static auto func = wrapFunction(base::get() + 0x1a88c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LabelGameObject::getTextKerning() -> decltype(getTextKerning()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LabelGameObject::getTextKerning), this);
	using FunctionType = decltype(getTextKerning())(*)(LabelGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SearchButton::create(char const* texture, char const* text, float size, char const* icon) -> decltype(create(texture, text, size, icon)) {
	using FunctionType = decltype(create(texture, text, size, icon))(*)(char const*, char const*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x5ee970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(texture, text, size, icon);
}

auto SearchButton::init(char const* p0, char const* p1, float p2, char const* p3) -> decltype(init(p0, p1, p2, p3)) {
	using FunctionType = decltype(init(p0, p1, p2, p3))(*)(SearchButton*, char const*, char const*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x5f0c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x4f3030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GameLevelManager::getDailyID(GJTimedLevelType p0) -> decltype(getDailyID(p0)) {
	using FunctionType = decltype(getDailyID(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x527160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getMapPacks(GJSearchObject* p0) -> decltype(getMapPacks(p0)) {
	using FunctionType = decltype(getMapPacks(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x511a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getPageInfo(char const* p0) -> decltype(getPageInfo(p0)) {
	using FunctionType = decltype(getPageInfo(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x50a2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getTimeLeft(char const* p0, float p1) -> decltype(getTimeLeft(p0, p1)) {
	using FunctionType = decltype(getTimeLeft(p0, p1))(*)(GameLevelManager*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x50a700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getUserList(UserListType p0) -> decltype(getUserList(p0)) {
	using FunctionType = decltype(getUserList(p0))(*)(GameLevelManager*, UserListType);
	static auto func = wrapFunction(base::get() + 0x524400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGauntlets() -> decltype(getGauntlets()) {
	using FunctionType = decltype(getGauntlets())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x513af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getGJRewards(int p0) -> decltype(getGJRewards(p0)) {
	using FunctionType = decltype(getGJRewards(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x525ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getIntForKey(char const* p0) -> decltype(getIntForKey(p0)) {
	using FunctionType = decltype(getIntForKey(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x527ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getLengthStr(bool p0, bool p1, bool p2, bool p3, bool p4, bool p5) -> decltype(getLengthStr(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(getLengthStr(p0, p1, p2, p3, p4, p5))(*)(GameLevelManager*, bool, bool, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x50fcf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto GameLevelManager::getMainLevel(int p0, bool p1) -> decltype(getMainLevel(p0, p1)) {
	using FunctionType = decltype(getMainLevel(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x5011a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getBoolForKey(char const* p0) -> decltype(getBoolForKey(p0)) {
	using FunctionType = decltype(getBoolForKey(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x5280b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getCommentKey(int p0, int p1, int p2, CommentKeyType p3) -> decltype(getCommentKey(p0, p1, p2, p3)) {
	using FunctionType = decltype(getCommentKey(p0, p1, p2, p3))(*)(GameLevelManager*, int, int, int, CommentKeyType);
	static auto func = wrapFunction(base::get() + 0x51e1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::getDailyTimer(GJTimedLevelType p0) -> decltype(getDailyTimer(p0)) {
	using FunctionType = decltype(getDailyTimer(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x5271c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getFolderName(int p0, bool p1) -> decltype(getFolderName(p0, p1)) {
	using FunctionType = decltype(getFolderName(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x50bf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getGJUserInfo(int p0) -> decltype(getGJUserInfo(p0)) {
	using FunctionType = decltype(getGJUserInfo(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x51b4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getLevelLists(GJSearchObject* p0) -> decltype(getLevelLists(p0)) {
	using FunctionType = decltype(getLevelLists(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x512dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedLevel(int p0) -> decltype(getSavedLevel(p0)) {
	using FunctionType = decltype(getSavedLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x509370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getMessagesKey(bool p0, int p1) -> decltype(getMessagesKey(p0, p1)) {
	using FunctionType = decltype(getMessagesKey(p0, p1))(*)(GameLevelManager*, bool, int);
	static auto func = wrapFunction(base::get() + 0x51c0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getSavedLevels(bool p0, int p1) -> decltype(getSavedLevels(p0, p1)) {
	using FunctionType = decltype(getSavedLevels(p0, p1))(*)(GameLevelManager*, bool, int);
	static auto func = wrapFunction(base::get() + 0x5089a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getSearchScene(char const* p0) -> decltype(getSearchScene(p0)) {
	using FunctionType = decltype(getSearchScene(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x50aa00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGJChallenges() -> decltype(getGJChallenges()) {
	using FunctionType = decltype(getGJChallenges())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x5267e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getOnlineLevels(GJSearchObject* p0) -> decltype(getOnlineLevels(p0)) {
	using FunctionType = decltype(getOnlineLevels(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x5108d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedMapPack(int p0) -> decltype(getSavedMapPack(p0)) {
	using FunctionType = decltype(getSavedMapPack(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x511d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getUserMessages(bool p0, int p1, int p2) -> decltype(getUserMessages(p0, p1, p2)) {
	using FunctionType = decltype(getUserMessages(p0, p1, p2))(*)(GameLevelManager*, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x51bd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::getActiveDailyID(GJTimedLevelType p0) -> decltype(getActiveDailyID(p0)) {
	using FunctionType = decltype(getActiveDailyID(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x527190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getLevelComments(int p0, int p1, int p2, int p3, CommentKeyType p4) -> decltype(getLevelComments(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(getLevelComments(p0, p1, p2, p3, p4))(*)(GameLevelManager*, int, int, int, int, CommentKeyType);
	static auto func = wrapFunction(base::get() + 0x51dcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GameLevelManager::getBasePostString() -> decltype(getBasePostString()) {
	using FunctionType = decltype(getBasePostString())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x50e2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getFriendRequests(bool p0, int p1, int p2) -> decltype(getFriendRequests(p0, p1, p2)) {
	using FunctionType = decltype(getFriendRequests(p0, p1, p2))(*)(GameLevelManager*, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x5219a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::getGauntletLevels(int p0) -> decltype(getGauntletLevels(p0)) {
	using FunctionType = decltype(getGauntletLevels(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x513e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getStoredUserList(UserListType p0) -> decltype(getStoredUserList(p0)) {
	using FunctionType = decltype(getStoredUserList(p0))(*)(GameLevelManager*, UserListType);
	static auto func = wrapFunction(base::get() + 0x5239b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getAccountComments(int p0, int p1, int p2) -> decltype(getAccountComments(p0, p1, p2)) {
	using FunctionType = decltype(getAccountComments(p0, p1, p2))(*)(GameLevelManager*, int, int, int);
	static auto func = wrapFunction(base::get() + 0x51e3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::getCompletedLevels(bool p0) -> decltype(getCompletedLevels(p0)) {
	using FunctionType = decltype(getCompletedLevels(p0))(*)(GameLevelManager*, bool);
	static auto func = wrapFunction(base::get() + 0x508ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedDailyLevel(int p0) -> decltype(getSavedDailyLevel(p0)) {
	using FunctionType = decltype(getSavedDailyLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5091b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedLevelLists(int p0) -> decltype(getSavedLevelLists(p0)) {
	using FunctionType = decltype(getSavedLevelLists(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x508b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getFriendRequestKey(bool p0, int p1) -> decltype(getFriendRequestKey(p0, p1)) {
	using FunctionType = decltype(getFriendRequestKey(p0, p1))(*)(GameLevelManager*, bool, int);
	static auto func = wrapFunction(base::get() + 0x51f6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getLevelLeaderboard(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(getLevelLeaderboard(p0, p1, p2)) {
	using FunctionType = decltype(getLevelLeaderboard(p0, p1, p2))(*)(GameLevelManager*, GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x519f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::getLowestLevelOrder() -> decltype(getLowestLevelOrder()) {
	using FunctionType = decltype(getLowestLevelOrder())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x508cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getAccountCommentKey(int p0, int p1) -> decltype(getAccountCommentKey(p0, p1)) {
	using FunctionType = decltype(getAccountCommentKey(p0, p1))(*)(GameLevelManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x51e710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::getAllSmartTemplates() -> decltype(getAllSmartTemplates()) {
	using FunctionType = decltype(getAllSmartTemplates())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x50c310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getGauntletsearchKey(int p0) -> decltype(getGauntletsearchKey(p0)) {
	using FunctionType = decltype(getGauntletsearchKey(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x513a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getGJDailyLevelState(GJTimedLevelType p0) -> decltype(getGJDailyLevelState(p0)) {
	using FunctionType = decltype(getGJDailyLevelState(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x526c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getHighestLevelOrder() -> decltype(getHighestLevelOrder()) {
	using FunctionType = decltype(getHighestLevelOrder())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x508c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::getLeaderboardScores(char const* p0) -> decltype(getLeaderboardScores(p0)) {
	using FunctionType = decltype(getLeaderboardScores(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x5196a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedGauntletLevel(int p0) -> decltype(getSavedGauntletLevel(p0)) {
	using FunctionType = decltype(getSavedGauntletLevel(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x509290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getStoredOnlineLevels(char const* p0) -> decltype(getStoredOnlineLevels(p0)) {
	using FunctionType = decltype(getStoredOnlineLevels(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x50a0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getLevelLeaderboardKey(int p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(getLevelLeaderboardKey(p0, p1, p2)) {
	using FunctionType = decltype(getLevelLeaderboardKey(p0, p1, p2))(*)(GameLevelManager*, int, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x51acf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::getStoredLevelComments(char const* p0) -> decltype(getStoredLevelComments(p0)) {
	using FunctionType = decltype(getStoredLevelComments(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x51fa70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getStoredUserMessageReply(int p0) -> decltype(getStoredUserMessageReply(p0)) {
	using FunctionType = decltype(getStoredUserMessageReply(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x51bd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getSavedDailyLevelFromLevelID(int p0) -> decltype(getSavedDailyLevelFromLevelID(p0)) {
	using FunctionType = decltype(getSavedDailyLevelFromLevelID(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x509450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::getUsers(GJSearchObject* p0) -> decltype(getUsers(p0)) {
	using FunctionType = decltype(getUsers(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x51b140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::setDiffVal(int p0, bool p1) -> decltype(setDiffVal(p0, p1)) {
	using FunctionType = decltype(setDiffVal(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x527ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::setLenVal(int p0, bool p1) -> decltype(setLenVal(p0, p1)) {
	using FunctionType = decltype(setLenVal(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x527ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onLikeItemCompleted(gd::string p0, gd::string p1) -> decltype(onLikeItemCompleted(p0, p1)) {
	using FunctionType = decltype(onLikeItemCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f9860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onRateStarsCompleted(gd::string p0, gd::string p1) -> decltype(onRateStarsCompleted(p0, p1)) {
	using FunctionType = decltype(onRateStarsCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f7180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onGetMapPacksCompleted(gd::string p0, gd::string p1) -> decltype(onGetMapPacksCompleted(p0, p1)) {
	using FunctionType = decltype(onGetMapPacksCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f65f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onReportLevelCompleted(gd::string p0, gd::string p1) -> decltype(onReportLevelCompleted(p0, p1)) {
	using FunctionType = decltype(onReportLevelCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f9bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onUpdateLevelCompleted(gd::string p0, gd::string p1) -> decltype(onUpdateLevelCompleted(p0, p1)) {
	using FunctionType = decltype(onUpdateLevelCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f70d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onUploadLevelCompleted(gd::string p0, gd::string p1) -> decltype(onUploadLevelCompleted(p0, p1)) {
	using FunctionType = decltype(onUploadLevelCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f5670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onRestoreItemsCompleted(gd::string p0, gd::string p1) -> decltype(onRestoreItemsCompleted(p0, p1)) {
	using FunctionType = decltype(onRestoreItemsCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f9a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onDeleteCommentCompleted(gd::string p0, gd::string p1) -> decltype(onDeleteCommentCompleted(p0, p1)) {
	using FunctionType = decltype(onDeleteCommentCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f96b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onDownloadLevelCompleted(gd::string p0, gd::string p1) -> decltype(onDownloadLevelCompleted(p0, p1)) {
	using FunctionType = decltype(onDownloadLevelCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f7020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onGetGJUserInfoCompleted(gd::string p0, gd::string p1) -> decltype(onGetGJUserInfoCompleted(p0, p1)) {
	using FunctionType = decltype(onGetGJUserInfoCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f9fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onSetLevelStarsCompleted(gd::string p0, gd::string p1) -> decltype(onSetLevelStarsCompleted(p0, p1)) {
	using FunctionType = decltype(onSetLevelStarsCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f7490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onUploadCommentCompleted(gd::string p0, gd::string p1) -> decltype(onUploadCommentCompleted(p0, p1)) {
	using FunctionType = decltype(onUploadCommentCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f8670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onGetGJChallengesCompleted(gd::string p0, gd::string p1) -> decltype(onGetGJChallengesCompleted(p0, p1)) {
	using FunctionType = decltype(onGetGJChallengesCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4fe0c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onGetOnlineLevelsCompleted(gd::string p0, gd::string p1) -> decltype(onGetOnlineLevelsCompleted(p0, p1)) {
	using FunctionType = decltype(onGetOnlineLevelsCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f5930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onUpdateUserScoreCompleted(gd::string p0, gd::string p1) -> decltype(onUpdateUserScoreCompleted(p0, p1)) {
	using FunctionType = decltype(onUpdateUserScoreCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f7640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onGetLevelCommentsCompleted(gd::string p0, gd::string p1) -> decltype(onGetLevelCommentsCompleted(p0, p1)) {
	using FunctionType = decltype(onGetLevelCommentsCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f7d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onDeleteServerLevelCompleted(gd::string p0, gd::string p1) -> decltype(onDeleteServerLevelCompleted(p0, p1)) {
	using FunctionType = decltype(onDeleteServerLevelCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f7300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onUpdateDescriptionCompleted(gd::string p0, gd::string p1) -> decltype(onUpdateDescriptionCompleted(p0, p1)) {
	using FunctionType = decltype(onUpdateDescriptionCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f9d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onGetAccountCommentsCompleted(gd::string p0, gd::string p1) -> decltype(onGetAccountCommentsCompleted(p0, p1)) {
	using FunctionType = decltype(onGetAccountCommentsCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f8200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onProcessHttpRequestCompleted(cocos2d::extension::CCHttpClient* p0, cocos2d::extension::CCHttpResponse* p1) -> decltype(onProcessHttpRequestCompleted(p0, p1)) {
	using FunctionType = decltype(onProcessHttpRequestCompleted(p0, p1))(*)(GameLevelManager*, cocos2d::extension::CCHttpClient*, cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x4f3380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::onGetLeaderboardScoresCompleted(gd::string p0, gd::string p1) -> decltype(onGetLeaderboardScoresCompleted(p0, p1)) {
	using FunctionType = decltype(onGetLeaderboardScoresCompleted(p0, p1))(*)(GameLevelManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x4f79a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GameLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x50c8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::followUser(int p0) -> decltype(followUser(p0)) {
	using FunctionType = decltype(followUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x50bc10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::isDLActive(char const* p0) -> decltype(isDLActive(p0)) {
	using FunctionType = decltype(isDLActive(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x50a480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::isTimeValid(char const* p0, float p1) -> decltype(isTimeValid(p0, p1)) {
	using FunctionType = decltype(isTimeValid(p0, p1))(*)(GameLevelManager*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x50a1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::updateLevel(GJGameLevel* p0) -> decltype(updateLevel(p0)) {
	using FunctionType = decltype(updateLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x515ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	using FunctionType = decltype(encodeDataTo(p0))(*)(GameLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x50c700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::removeFriend(int p0) -> decltype(removeFriend(p0)) {
	using FunctionType = decltype(removeFriend(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x523530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::unfollowUser(int p0) -> decltype(unfollowUser(p0)) {
	using FunctionType = decltype(unfollowUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x50bac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::addDLToActive(char const* p0) -> decltype(addDLToActive(p0)) {
	using FunctionType = decltype(addDLToActive(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x50a550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::deleteComment(int p0, CommentType p1, int p2) -> decltype(deleteComment(p0, p1, p2)) {
	using FunctionType = decltype(deleteComment(p0, p1, p2))(*)(GameLevelManager*, int, CommentType, int);
	static auto func = wrapFunction(base::get() + 0x521210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::downloadLevel(int p0, bool p1) -> decltype(downloadLevel(p0, p1)) {
	using FunctionType = decltype(downloadLevel(p0, p1))(*)(GameLevelManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x5144c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::hasRatedDemon(int p0) -> decltype(hasRatedDemon(p0)) {
	using FunctionType = decltype(hasRatedDemon(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x516e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::isUpdateValid(int p0) -> decltype(isUpdateValid(p0)) {
	using FunctionType = decltype(isUpdateValid(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x515e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::makeTimeStamp(char const* p0) -> decltype(makeTimeStamp(p0)) {
	using FunctionType = decltype(makeTimeStamp(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x509fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::storeUserName(int p0, int p1, gd::string p2) -> decltype(storeUserName(p0, p1, p2)) {
	using FunctionType = decltype(storeUserName(p0, p1, p2))(*)(GameLevelManager*, int, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x502f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::uploadComment(gd::string p0, CommentType p1, int p2, int p3) -> decltype(uploadComment(p0, p1, p2, p3)) {
	using FunctionType = decltype(uploadComment(p0, p1, p2, p3))(*)(GameLevelManager*, gd::string, CommentType, int, int);
	static auto func = wrapFunction(base::get() + 0x51fbd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::createNewLevel() -> decltype(createNewLevel()) {
	using FunctionType = decltype(createNewLevel())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x5017f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::resetGauntlets() -> decltype(resetGauntlets()) {
	using FunctionType = decltype(resetGauntlets())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x514480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::responseToDict(gd::string p0, bool p1) -> decltype(responseToDict(p0, p1)) {
	using FunctionType = decltype(responseToDict(p0, p1))(*)(gd::string, bool);
	static auto func = wrapFunction(base::get() + 0x505b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameLevelManager::tryGetUsername(int p0) -> decltype(tryGetUsername(p0)) {
	using FunctionType = decltype(tryGetUsername(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5032f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::isFollowingUser(int p0) -> decltype(isFollowingUser(p0)) {
	using FunctionType = decltype(isFollowingUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x50b9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::updateUserScore() -> decltype(updateUserScore()) {
	using FunctionType = decltype(updateUserScore())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x517ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::limitSavedLevels() -> decltype(limitSavedLevels()) {
	using FunctionType = decltype(limitSavedLevels())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x50b1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::resetTimerForKey(char const* p0) -> decltype(resetTimerForKey(p0)) {
	using FunctionType = decltype(resetTimerForKey(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x50a910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::saveFetchedLevels(cocos2d::CCArray* p0) -> decltype(saveFetchedLevels(p0)) {
	using FunctionType = decltype(saveFetchedLevels(p0))(*)(GameLevelManager*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x505dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::storeSearchResult(cocos2d::CCArray* p0, gd::string p1, char const* p2) -> decltype(storeSearchResult(p0, p1, p2)) {
	using FunctionType = decltype(storeSearchResult(p0, p1, p2))(*)(GameLevelManager*, cocos2d::CCArray*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x509d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::uploadUserMessage(int p0, gd::string p1, gd::string p2) -> decltype(uploadUserMessage(p0, p1, p2)) {
	using FunctionType = decltype(uploadUserMessage(p0, p1, p2))(*)(GameLevelManager*, int, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x51ce90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::userNameForUserID(int p0) -> decltype(userNameForUserID(p0)) {
	using FunctionType = decltype(userNameForUserID(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x503170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::accountIDForUserID(int p0) -> decltype(accountIDForUserID(p0)) {
	using FunctionType = decltype(accountIDForUserID(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5037f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::areGauntletsLoaded() -> decltype(areGauntletsLoaded()) {
	using FunctionType = decltype(areGauntletsLoaded())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x514460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::createAndGetScores(gd::string p0, GJScoreType p1) -> decltype(createAndGetScores(p0, p1)) {
	using FunctionType = decltype(createAndGetScores(p0, p1))(*)(GameLevelManager*, gd::string, GJScoreType);
	static auto func = wrapFunction(base::get() + 0x507520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::createNewLevelList() -> decltype(createNewLevelList()) {
	using FunctionType = decltype(createNewLevelList())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x502340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameLevelManager::deleteUserMessages(GJUserMessage* p0, cocos2d::CCArray* p1, bool p2) -> decltype(deleteUserMessages(p0, p1, p2)) {
	using FunctionType = decltype(deleteUserMessages(p0, p1, p2))(*)(GameLevelManager*, GJUserMessage*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x51d450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::hasRatedLevelStars(int p0) -> decltype(hasRatedLevelStars(p0)) {
	using FunctionType = decltype(hasRatedLevelStars(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x516a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::invalidateMessages(bool p0, bool p1) -> decltype(invalidateMessages(p0, p1)) {
	using FunctionType = decltype(invalidateMessages(p0, p1))(*)(GameLevelManager*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x51d940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::invalidateRequests(bool p0, bool p1) -> decltype(invalidateRequests(p0, p1)) {
	using FunctionType = decltype(invalidateRequests(p0, p1))(*)(GameLevelManager*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x5227f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::invalidateUserList(UserListType p0, bool p1) -> decltype(invalidateUserList(p0, p1)) {
	using FunctionType = decltype(invalidateUserList(p0, p1))(*)(GameLevelManager*, UserListType, bool);
	static auto func = wrapFunction(base::get() + 0x5246b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::ProcessHttpRequest(gd::string p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(ProcessHttpRequest(p0, p1, p2, p3)) {
	using FunctionType = decltype(ProcessHttpRequest(p0, p1, p2, p3))(*)(GameLevelManager*, gd::string, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x4f3510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::removeDLFromActive(char const* p0) -> decltype(removeDLFromActive(p0)) {
	using FunctionType = decltype(removeDLFromActive(p0))(*)(GameLevelManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x50a630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::updateLevelRewards(GJGameLevel* p0) -> decltype(updateLevelRewards(p0)) {
	using FunctionType = decltype(updateLevelRewards(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x503980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::uploadLevelComment(int p0, gd::string p1, int p2) -> decltype(uploadLevelComment(p0, p1, p2)) {
	using FunctionType = decltype(uploadLevelComment(p0, p1, p2))(*)(GameLevelManager*, int, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x51fb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::userIDForAccountID(int p0) -> decltype(userIDForAccountID(p0)) {
	using FunctionType = decltype(userIDForAccountID(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5037b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::acceptFriendRequest(int p0, int p1) -> decltype(acceptFriendRequest(p0, p1)) {
	using FunctionType = decltype(acceptFriendRequest(p0, p1))(*)(GameLevelManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x522b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::createSmartTemplate() -> decltype(createSmartTemplate()) {
	using FunctionType = decltype(createSmartTemplate())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x50c280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

void GameLevelManager::resetStoredUserInfo(int id) {
        m_storedUserInfo->removeObjectForKey(id);
    }

auto GameLevelManager::writeSpecialFilters(GJSearchObject* p0) -> decltype(writeSpecialFilters(p0)) {
	using FunctionType = decltype(writeSpecialFilters(p0))(*)(GameLevelManager*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x510460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::resetAccountComments(int p0) -> decltype(resetAccountComments(p0)) {
	using FunctionType = decltype(resetAccountComments(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x51f580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::resetDailyLevelState(GJTimedLevelType p0) -> decltype(resetDailyLevelState(p0)) {
	using FunctionType = decltype(resetDailyLevelState(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x5270e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::storeDailyLevelState(int p0, int p1, GJTimedLevelType p2) -> decltype(storeDailyLevelState(p0, p1, p2)) {
	using FunctionType = decltype(storeDailyLevelState(p0, p1, p2))(*)(GameLevelManager*, int, int, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x526fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::uploadAccountComment(gd::string p0) -> decltype(uploadAccountComment(p0)) {
	using FunctionType = decltype(uploadAccountComment(p0))(*)(GameLevelManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x5209a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::userInfoForAccountID(int p0) -> decltype(userInfoForAccountID(p0)) {
	using FunctionType = decltype(userInfoForAccountID(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5037d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::hasLikedItemFullCheck(LikeItemType p0, int p1, int p2) -> decltype(hasLikedItemFullCheck(p0, p1, p2)) {
	using FunctionType = decltype(hasLikedItemFullCheck(p0, p1, p2))(*)(GameLevelManager*, LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x525520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameLevelManager::deleteSentFriendRequest(int p0) -> decltype(deleteSentFriendRequest(p0)) {
	using FunctionType = decltype(deleteSentFriendRequest(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5221e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::hasDailyStateBeenLoaded(GJTimedLevelType p0) -> decltype(hasDailyStateBeenLoaded(p0)) {
	using FunctionType = decltype(hasDailyStateBeenLoaded(p0))(*)(GameLevelManager*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x527120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::friendRequestFromAccountID(int p0) -> decltype(friendRequestFromAccountID(p0)) {
	using FunctionType = decltype(friendRequestFromAccountID(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x51bce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::resetCommentTimersForLevelID(int p0, CommentKeyType p1) -> decltype(resetCommentTimersForLevelID(p0, p1)) {
	using FunctionType = decltype(resetCommentTimersForLevelID(p0, p1))(*)(GameLevelManager*, int, CommentKeyType);
	static auto func = wrapFunction(base::get() + 0x520a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameLevelManager::handleIt(bool p0, gd::string p1, gd::string p2, GJHttpType p3) -> decltype(handleIt(p0, p1, p2, p3)) {
	using FunctionType = decltype(handleIt(p0, p1, p2, p3))(*)(GameLevelManager*, bool, gd::string, gd::string, GJHttpType);
	static auto func = wrapFunction(base::get() + 0x4f36d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameLevelManager::blockUser(int p0) -> decltype(blockUser(p0)) {
	using FunctionType = decltype(blockUser(p0))(*)(GameLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x523a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::saveLevel(GJGameLevel* p0) -> decltype(saveLevel(p0)) {
	using FunctionType = decltype(saveLevel(p0))(*)(GameLevelManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x5094a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameLevelManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameLevelManager::init), this);
	using FunctionType = decltype(init())(*)(GameLevelManager*);
	static auto func = wrapFunction(base::get() + 0x501010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSearchObject::create(SearchType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(SearchType);
	static auto func = wrapFunction(base::get() + 0x52d700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJSearchObject::create(SearchType p0, gd::string p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(SearchType, gd::string);
	static auto func = wrapFunction(base::get() + 0x52d830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJSearchObject::create(SearchType p0, gd::string p1, gd::string p2, gd::string p3, int p4, bool p5, bool p6, bool p7, int p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15, bool p16, bool p17, bool p18, int p19, int p20, int p21) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21))(*)(SearchType, gd::string, gd::string, gd::string, int, bool, bool, bool, int, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, int, int, int);
	static auto func = wrapFunction(base::get() + 0x52d460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21);
}

auto GJSearchObject::getPageObject(int p0) -> decltype(getPageObject(p0)) {
	using FunctionType = decltype(getPageObject(p0))(*)(GJSearchObject*, int);
	static auto func = wrapFunction(base::get() + 0x52df30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSearchObject::getNextPageObject() -> decltype(getNextPageObject()) {
	using FunctionType = decltype(getNextPageObject())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x52df10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJSearchObject::getPrevPageObject() -> decltype(getPrevPageObject()) {
	using FunctionType = decltype(getPrevPageObject())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x52e160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJSearchObject::getKey() -> decltype(getKey()) {
	using FunctionType = decltype(getKey())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x5114d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJSearchObject::createFromKey(char const* p0) -> decltype(createFromKey(p0)) {
	using FunctionType = decltype(createFromKey(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x50aa20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJSearchObject::isLevelSearchObject() -> decltype(isLevelSearchObject()) {
	using FunctionType = decltype(isLevelSearchObject())(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x52e180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJLevelList::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x502610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJLevelList::getUnpackedDescription() -> decltype(getUnpackedDescription()) {
	using FunctionType = decltype(getUnpackedDescription())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x52e6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJLevelList::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJLevelList*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x52fff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelList::showListInfo() -> decltype(showListInfo()) {
	using FunctionType = decltype(showListInfo())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x52fba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJLevelList::completedLevels() -> decltype(completedLevels()) {
	using FunctionType = decltype(completedLevels())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x52fb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJLevelList::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(GJLevelList*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x52ffc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelList::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJLevelList::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJLevelList*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x5302f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJLevelList::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLevelList::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x530520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLevelList::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLevelList::init), this);
	using FunctionType = decltype(init())(*)(GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x52e620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LikeItemLayer::create(LikeItemType p0, int p1, int p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x5bdd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto LikeItemLayer::init(LikeItemType p0, int p1, int p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(LikeItemLayer*, LikeItemType, int, int);
	static auto func = wrapFunction(base::get() + 0x5bdef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LikeItemLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LikeItemLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LikeItemLayer*);
	static auto func = wrapFunction(base::get() + 0x5be470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelTools::getAudioTitle(int p0) -> decltype(getAudioTitle(p0)) {
	using FunctionType = decltype(getAudioTitle(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x4d8da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getSongObject(int p0) -> decltype(getSongObject(p0)) {
	using FunctionType = decltype(getSongObject(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x4dc4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getAudioString(int p0) -> decltype(getAudioString(p0)) {
	using FunctionType = decltype(getAudioString(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x4dafa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::sortSpeedObjects(cocos2d::CCArray* p0, GJBaseGameLayer* p1) -> decltype(sortSpeedObjects(p0, p1)) {
	using FunctionType = decltype(sortSpeedObjects(p0, p1))(*)(LevelTools*, cocos2d::CCArray*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4dd230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelTools::base64DecodeString(gd::string p0) -> decltype(base64DecodeString(p0)) {
	using FunctionType = decltype(base64DecodeString(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x4dcac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelTools::getLevel(int p0, bool p1) -> decltype(getLevel(p0, p1)) {
	using FunctionType = decltype(getLevel(p0, p1))(*)(int, bool);
	static auto func = wrapFunction(base::get() + 0x4d6840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GameStatsManager::getItemKey(int p0, int p1) -> decltype(getItemKey(p0, p1)) {
	using FunctionType = decltype(getItemKey(p0, p1))(*)(GameStatsManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x66050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::getLevelKey(int p0, bool p1, bool p2, bool p3) -> decltype(getLevelKey(p0, p1, p2, p3)) {
	using FunctionType = decltype(getLevelKey(p0, p1, p2, p3))(*)(GameStatsManager*, int, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x6cd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GameStatsManager::getLevelKey(GJGameLevel* p0) -> decltype(getLevelKey(p0)) {
	using FunctionType = decltype(getLevelKey(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x6cd20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getChallenge(int p0) -> decltype(getChallenge(p0)) {
	using FunctionType = decltype(getChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x73750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getCurrencyKey(GJGameLevel* p0) -> decltype(getCurrencyKey(p0)) {
	using FunctionType = decltype(getCurrencyKey(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x6fcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getStatFromKey(StatKey p0) -> decltype(getStatFromKey(p0)) {
	using FunctionType = decltype(getStatFromKey(p0))(*)(GameStatsManager*, StatKey);
	static auto func = wrapFunction(base::get() + 0x6c690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getBaseDiamonds(int p0) -> decltype(getBaseDiamonds(p0)) {
	using FunctionType = decltype(getBaseDiamonds(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x706c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getBonusDiamonds(int p0) -> decltype(getBonusDiamonds(p0)) {
	using FunctionType = decltype(getBonusDiamonds(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x706e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getItemUnlockState(int p0, UnlockType p1) -> decltype(getItemUnlockState(p0, p1)) {
	using FunctionType = decltype(getItemUnlockState(p0, p1))(*)(GameStatsManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x77e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::getQueuedChallenge(int p0) -> decltype(getQueuedChallenge(p0)) {
	using FunctionType = decltype(getQueuedChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x73830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getGauntletRewardKey(int p0) -> decltype(getGauntletRewardKey(p0)) {
	using FunctionType = decltype(getGauntletRewardKey(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x78490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getBaseCurrencyForLevel(GJGameLevel* p0) -> decltype(getBaseCurrencyForLevel(p0)) {
	using FunctionType = decltype(getBaseCurrencyForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x6fde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getTotalCollectedCurrency() -> decltype(getTotalCollectedCurrency()) {
	using FunctionType = decltype(getTotalCollectedCurrency())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x74b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::getTotalCollectedDiamonds() -> decltype(getTotalCollectedDiamonds()) {
	using FunctionType = decltype(getTotalCollectedDiamonds())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x757b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::getAwardedCurrencyForLevel(GJGameLevel* p0) -> decltype(getAwardedCurrencyForLevel(p0)) {
	using FunctionType = decltype(getAwardedCurrencyForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x6ffb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getAwardedDiamondsForLevel(GJGameLevel* p0) -> decltype(getAwardedDiamondsForLevel(p0)) {
	using FunctionType = decltype(getAwardedDiamondsForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x70720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getSecondaryQueuedChallenge(int p0) -> decltype(getSecondaryQueuedChallenge(p0)) {
	using FunctionType = decltype(getSecondaryQueuedChallenge(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x73910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::getSpecialUnlockDescription(int p0, UnlockType p1, bool p2) -> decltype(getSpecialUnlockDescription(p0, p1, p2)) {
	using FunctionType = decltype(getSpecialUnlockDescription(p0, p1, p2))(*)(GameStatsManager*, int, UnlockType, bool);
	static auto func = wrapFunction(base::get() + 0x789e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameStatsManager::getStat(char const* p0) -> decltype(getStat(p0)) {
	using FunctionType = decltype(getStat(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x66800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::setStat(char const* p0, int p1) -> decltype(setStat(p0, p1)) {
	using FunctionType = decltype(setStat(p0, p1))(*)(GameStatsManager*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x66a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GameStatsManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x89460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasUserCoin(char const* p0) -> decltype(hasUserCoin(p0)) {
	using FunctionType = decltype(hasUserCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x6f490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x5d0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GameStatsManager::addStoreItem(int p0, int p1, int p2, int p3, ShopType p4) -> decltype(addStoreItem(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(addStoreItem(p0, p1, p2, p3, p4))(*)(GameStatsManager*, int, int, int, int, ShopType);
	static auto func = wrapFunction(base::get() + 0x662c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto GameStatsManager::hasSecretCoin(char const* p0) -> decltype(hasSecretCoin(p0)) {
	using FunctionType = decltype(hasSecretCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x6cc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::isItemEnabled(UnlockType p0, int p1) -> decltype(isItemEnabled(p0, p1)) {
	using FunctionType = decltype(isItemEnabled(p0, p1))(*)(GameStatsManager*, UnlockType, int);
	static auto func = wrapFunction(base::get() + 0x78170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::isItemUnlocked(UnlockType p0, int p1) -> decltype(isItemUnlocked(p0, p1)) {
	using FunctionType = decltype(isItemUnlocked(p0, p1))(*)(GameStatsManager*, UnlockType, int);
	static auto func = wrapFunction(base::get() + 0x6b670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::accountIDForIcon(int p0, UnlockType p1) -> decltype(accountIDForIcon(p0, p1)) {
	using FunctionType = decltype(accountIDForIcon(p0, p1))(*)(GameStatsManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x3087a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameStatsManager::areRewardsLoaded() -> decltype(areRewardsLoaded()) {
	using FunctionType = decltype(areRewardsLoaded())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x70f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::createStoreItems() -> decltype(createStoreItems()) {
	using FunctionType = decltype(createStoreItems())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x5d4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::setupIconCredits() -> decltype(setupIconCredits()) {
	using FunctionType = decltype(setupIconCredits())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x308880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::toggleEnableItem(UnlockType p0, int p1, bool p2) -> decltype(toggleEnableItem(p0, p1, p2)) {
	using FunctionType = decltype(toggleEnableItem(p0, p1, p2))(*)(GameStatsManager*, UnlockType, int, bool);
	static auto func = wrapFunction(base::get() + 0x78200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GameStatsManager::countSecretChests(GJRewardType p0) -> decltype(countSecretChests(p0)) {
	using FunctionType = decltype(countSecretChests(p0))(*)(GameStatsManager*, GJRewardType);
	static auto func = wrapFunction(base::get() + 0x885d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool GameStatsManager::hasCompletedLevel(GJGameLevel* level) {
		return m_completedLevels->objectForKey(this->getLevelKey(level)) != nullptr;
	}

auto GameStatsManager::completedStarLevel(GJGameLevel* p0) -> decltype(completedStarLevel(p0)) {
	using FunctionType = decltype(completedStarLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x6d730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasPendingUserCoin(char const* p0) -> decltype(hasPendingUserCoin(p0)) {
	using FunctionType = decltype(hasPendingUserCoin(p0))(*)(GameStatsManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x6f3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::storeChallengeTime(int p0) -> decltype(storeChallengeTime(p0)) {
	using FunctionType = decltype(storeChallengeTime(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x73130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::areChallengesLoaded() -> decltype(areChallengesLoaded()) {
	using FunctionType = decltype(areChallengesLoaded())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x731b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::completedDemonLevel(GJGameLevel* p0) -> decltype(completedDemonLevel(p0)) {
	using FunctionType = decltype(completedDemonLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x6d5a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::recountSpecialStats() -> decltype(recountSpecialStats()) {
	using FunctionType = decltype(recountSpecialStats())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x75ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::resetChallengeTimer() -> decltype(resetChallengeTimer()) {
	using FunctionType = decltype(resetChallengeTimer())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x73190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::trySelectActivePath() -> decltype(trySelectActivePath()) {
	using FunctionType = decltype(trySelectActivePath())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x6c280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::usernameForAccountID(int p0) -> decltype(usernameForAccountID(p0)) {
	using FunctionType = decltype(usernameForAccountID(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x308810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::awardCurrencyForLevel(GJGameLevel* p0) -> decltype(awardCurrencyForLevel(p0)) {
	using FunctionType = decltype(awardCurrencyForLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x70180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

bool GameStatsManager::hasCompletedMainLevel(int levelID) {
		return m_completedLevels->objectForKey(this->getLevelKey(levelID, false, false, false)) != nullptr;
	}

auto GameStatsManager::hasCompletedStarLevel(GJGameLevel* p0) -> decltype(hasCompletedStarLevel(p0)) {
	using FunctionType = decltype(hasCompletedStarLevel(p0))(*)(GameStatsManager*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x6d360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::processChallengeQueue(int p0) -> decltype(processChallengeQueue(p0)) {
	using FunctionType = decltype(processChallengeQueue(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x73d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::createSecretChestItems() -> decltype(createSecretChestItems()) {
	using FunctionType = decltype(createSecretChestItems())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x5fb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::hasCompletedDailyLevel(int p0) -> decltype(hasCompletedDailyLevel(p0)) {
	using FunctionType = decltype(hasCompletedDailyLevel(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x741b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::isSpecialChestUnlocked(gd::string p0) -> decltype(isSpecialChestUnlocked(p0)) {
	using FunctionType = decltype(isSpecialChestUnlocked(p0))(*)(GameStatsManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x77d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::createSpecialChestItems() -> decltype(createSpecialChestItems()) {
	using FunctionType = decltype(createSpecialChestItems())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x5fca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::hasCompletedOnlineLevel(int p0) -> decltype(hasCompletedOnlineLevel(p0)) {
	using FunctionType = decltype(hasCompletedOnlineLevel(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x6d140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::isGauntletChestUnlocked(int p0) -> decltype(isGauntletChestUnlocked(p0)) {
	using FunctionType = decltype(isGauntletChestUnlocked(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x77bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::createSecretChestRewards() -> decltype(createSecretChestRewards()) {
	using FunctionType = decltype(createSecretChestRewards())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x79370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::countUnlockedSecretChests(GJRewardType p0) -> decltype(countUnlockedSecretChests(p0)) {
	using FunctionType = decltype(countUnlockedSecretChests(p0))(*)(GameStatsManager*, GJRewardType);
	static auto func = wrapFunction(base::get() + 0x88630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::hasCompletedGauntletLevel(int p0) -> decltype(hasCompletedGauntletLevel(p0)) {
	using FunctionType = decltype(hasCompletedGauntletLevel(p0))(*)(GameStatsManager*, int);
	static auto func = wrapFunction(base::get() + 0x6d1c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GameStatsManager::generateItemUnlockableData() -> decltype(generateItemUnlockableData()) {
	using FunctionType = decltype(generateItemUnlockableData())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x65480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::removeErrorFromSpecialChests() -> decltype(removeErrorFromSpecialChests()) {
	using FunctionType = decltype(removeErrorFromSpecialChests())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x77560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::resetSpecialStatAchievements() -> decltype(resetSpecialStatAchievements()) {
	using FunctionType = decltype(resetSpecialStatAchievements())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x77920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GameStatsManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameStatsManager::init), this);
	using FunctionType = decltype(init())(*)(GameStatsManager*);
	static auto func = wrapFunction(base::get() + 0x5d410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

void DemonFilterDelegate::demonFilterSelectClosed(int p0) {}

auto LevelSearchLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x5ebb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSearchLayer::scene(int p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x5eba40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSearchLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x5ebc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::getSearchObject(SearchType p0, gd::string p1) -> decltype(getSearchObject(p0, p1)) {
	using FunctionType = decltype(getSearchObject(p0, p1))(*)(LevelSearchLayer*, SearchType, gd::string);
	static auto func = wrapFunction(base::get() + 0x5f0380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSearchLayer::getSearchDiffKey() -> decltype(getSearchDiffKey()) {
	using FunctionType = decltype(getSearchDiffKey())(*)(LevelSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x5f0710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSearchLayer::onFollowed(cocos2d::CCObject* sender) -> decltype(onFollowed(sender)) {
	using FunctionType = decltype(onFollowed(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eee90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onTrending(cocos2d::CCObject* sender) -> decltype(onTrending(sender)) {
	using FunctionType = decltype(onTrending(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eec10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMostLikes(cocos2d::CCObject* sender) -> decltype(onMostLikes(sender)) {
	using FunctionType = decltype(onMostLikes(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eead0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onStarAward(cocos2d::CCObject* sender) -> decltype(onStarAward(sender)) {
	using FunctionType = decltype(onStarAward(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f08c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSuggested(cocos2d::CCObject* sender) -> decltype(onSuggested(sender)) {
	using FunctionType = decltype(onSuggested(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eeb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMostRecent(cocos2d::CCObject* sender) -> decltype(onMostRecent(sender)) {
	using FunctionType = decltype(onMostRecent(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eecb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSearchMode(cocos2d::CCObject* sender) -> decltype(onSearchMode(sender)) {
	using FunctionType = decltype(onSearchMode(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ee380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSearchUser(cocos2d::CCObject* sender) -> decltype(onSearchUser(sender)) {
	using FunctionType = decltype(onSearchUser(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ee800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onLatestStars(cocos2d::CCObject* sender) -> decltype(onLatestStars(sender)) {
	using FunctionType = decltype(onLatestStars(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eedf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMoreOptions(cocos2d::CCObject* sender) -> decltype(onMoreOptions(sender)) {
	using FunctionType = decltype(onMoreOptions(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ee360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSpecialDemon(cocos2d::CCObject* sender) -> decltype(onSpecialDemon(sender)) {
	using FunctionType = decltype(onSpecialDemon(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ef490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMostDownloaded(cocos2d::CCObject* sender) -> decltype(onMostDownloaded(sender)) {
	using FunctionType = decltype(onMostDownloaded(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eea30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onClearFreeSearch(cocos2d::CCObject* sender) -> decltype(onClearFreeSearch(sender)) {
	using FunctionType = decltype(onClearFreeSearch(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ee920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ef6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onMagic(cocos2d::CCObject* sender) -> decltype(onMagic(sender)) {
	using FunctionType = decltype(onMagic(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eed50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onSearch(cocos2d::CCObject* sender) -> decltype(onSearch(sender)) {
	using FunctionType = decltype(onSearch(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ee6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::onFriends(cocos2d::CCObject* sender) -> decltype(onFriends(sender)) {
	using FunctionType = decltype(onFriends(sender))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eef30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelSearchLayer::toggleStar(cocos2d::CCObject* p0) -> decltype(toggleStar(p0)) {
	using FunctionType = decltype(toggleStar(p0))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ef650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::toggleTime(cocos2d::CCObject* p0) -> decltype(toggleTime(p0)) {
	using FunctionType = decltype(toggleTime(p0))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ef4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::clearFilters() -> decltype(clearFilters()) {
	using FunctionType = decltype(clearFilters())(*)(LevelSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x5efdc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSearchLayer::toggleTimeNum(int p0, bool p1) -> decltype(toggleTimeNum(p0, p1)) {
	using FunctionType = decltype(toggleTimeNum(p0, p1))(*)(LevelSearchLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x5ef890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSearchLayer::toggleDifficulty(cocos2d::CCObject* p0) -> decltype(toggleDifficulty(p0)) {
	using FunctionType = decltype(toggleDifficulty(p0))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5eefd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::updateSearchLabel(char const* p0) -> decltype(updateSearchLabel(p0)) {
	using FunctionType = decltype(updateSearchLabel(p0))(*)(LevelSearchLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x5ee3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::confirmClearFilters(cocos2d::CCObject* p0) -> decltype(confirmClearFilters(p0)) {
	using FunctionType = decltype(confirmClearFilters(p0))(*)(LevelSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ee280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::toggleDifficultyNum(int p0, bool p1) -> decltype(toggleDifficultyNum(p0, p1)) {
	using FunctionType = decltype(toggleDifficultyNum(p0, p1))(*)(LevelSearchLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x5ef720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSearchLayer::checkDiff(int p0) -> decltype(checkDiff(p0)) {
	using FunctionType = decltype(checkDiff(p0))(*)(LevelSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x5f0960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::checkTime(int p0) -> decltype(checkTime(p0)) {
	using FunctionType = decltype(checkTime(p0))(*)(LevelSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x5f0a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelSearchLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSearchLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x5f0b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSearchLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSearchLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(LevelSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5f0100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSearchLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(LevelSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5f01c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSearchLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(LevelSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5f0290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSearchLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelSearchLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelSearchLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5f0090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSearchLayer::demonFilterSelectClosed(int p0) -> decltype(demonFilterSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelSearchLayer::demonFilterSelectClosed), this);
	using FunctionType = decltype(demonFilterSelectClosed(p0))(*)(LevelSearchLayer*, int);
	static auto func = wrapFunction(base::get() + 0x5efb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJComment::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x51edd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJComment::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJComment::init), this);
	using FunctionType = decltype(init())(*)(GJComment*);
	static auto func = wrapFunction(base::get() + 0x52e360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommentCell::onGoToLevel(cocos2d::CCObject* sender) -> decltype(onGoToLevel(sender)) {
	using FunctionType = decltype(onGoToLevel(sender))(*)(CommentCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x233020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CommentCell::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(CommentCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x232ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CommentCell::onConfirmDelete(cocos2d::CCObject* sender) -> decltype(onConfirmDelete(sender)) {
	using FunctionType = decltype(onConfirmDelete(sender))(*)(CommentCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2331f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CommentCell::loadFromComment(GJComment* p0) -> decltype(loadFromComment(p0)) {
	using FunctionType = decltype(loadFromComment(p0))(*)(CommentCell*, GJComment*);
	static auto func = wrapFunction(base::get() + 0x2266f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CommentCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommentCell::init), this);
	using FunctionType = decltype(init())(*)(CommentCell*);
	static auto func = wrapFunction(base::get() + 0x232fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommentCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommentCell::draw), this);
	using FunctionType = decltype(draw())(*)(CommentCell*);
	static auto func = wrapFunction(base::get() + 0x2332e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommentCell::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&CommentCell::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(CommentCell*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0x2333b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CommentCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CommentCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CommentCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x233750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ShaderGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ShaderGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x18f0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ShaderGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(ShaderGameObject*);
	static auto func = wrapFunction(base::get() + 0x18b710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShaderGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ShaderGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ShaderGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x18b780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto KeyframeGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(KeyframeGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1ad8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto KeyframeGameObject::updateShadowObjects(GJBaseGameLayer* p0, EditorUI* p1) -> decltype(updateShadowObjects(p0, p1)) {
	using FunctionType = decltype(updateShadowObjects(p0, p1))(*)(KeyframeGameObject*, GJBaseGameLayer*, EditorUI*);
	static auto func = wrapFunction(base::get() + 0x1ad510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto KeyframeGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeyframeGameObject::init), this);
	using FunctionType = decltype(init())(*)(KeyframeGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ad4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeyframeGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&KeyframeGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(KeyframeGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1ad770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto KeyframeGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&KeyframeGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(KeyframeGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1ade40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ArtTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(ArtTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1cd8f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ArtTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ArtTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1cd890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ArtTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ArtTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ArtTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1cd460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(EndTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1becc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EndTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EndTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1bf950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EndTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(EndTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1bec70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EndTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EndTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bee70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ForceBlockGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ForceBlockGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1ccec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ForceBlockGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ForceBlockGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ForceBlockGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1cc370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SFXTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1b3b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SFXTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SFXTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SFXTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b0040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UISettingsGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(UISettingsGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1c0840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UISettingsGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UISettingsGameObject::init), this);
	using FunctionType = decltype(init())(*)(UISettingsGameObject*);
	static auto func = wrapFunction(base::get() + 0x1bfbb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UISettingsGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&UISettingsGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(UISettingsGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bfc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ItemTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(ItemTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1c7040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ItemTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ItemTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1cac80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ItemTriggerGameObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ItemTriggerGameObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(ItemTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1c7000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ItemTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ItemTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ItemTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c7260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RandTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(RandTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1aa2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto RandTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(RandTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1aa600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto RandTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RandTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(RandTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1aa020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RandTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&RandTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(RandTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1aab30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SongTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1b4ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SongTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SongTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SongTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b4800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CountTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(CountTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1ba430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CountTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(CountTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1ba850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CountTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&CountTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(CountTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bac80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpawnTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(SpawnTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1b6f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SpawnTriggerGameObject::updateRemapKeys(gd::vector<int> const& p0) -> decltype(updateRemapKeys(p0)) {
	using FunctionType = decltype(updateRemapKeys(p0))(*)(SpawnTriggerGameObject*, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0x1b6690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SpawnTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SpawnTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1b7420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SpawnTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SpawnTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(SpawnTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b6640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SpawnTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SpawnTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SpawnTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b7830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TimerTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(TimerTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1c5120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto TimerTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TimerTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1c6aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TimerTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TimerTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TimerTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c5310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CameraTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(CameraTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1c0b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CameraTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(CameraTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1c4650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CameraTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&CameraTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(CameraTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1c0da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ObjectControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(ObjectControlGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1ced00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ObjectControlGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ObjectControlGameObject::init), this);
	using FunctionType = decltype(init())(*)(ObjectControlGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ce7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&ObjectControlGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(ObjectControlGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1ce830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(PlayerControlGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1ce540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerControlGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerControlGameObject::init), this);
	using FunctionType = decltype(init())(*)(PlayerControlGameObject*);
	static auto func = wrapFunction(base::get() + 0x1cda10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&PlayerControlGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(PlayerControlGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1cda60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SpawnParticleGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SpawnParticleGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1d0e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SpawnParticleGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SpawnParticleGameObject::init), this);
	using FunctionType = decltype(init())(*)(SpawnParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x1cf9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SpawnParticleGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SpawnParticleGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SpawnParticleGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1cfa00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AudioLineGuideGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(AudioLineGuideGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1cc0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto AudioLineGuideGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AudioLineGuideGameObject::init), this);
	using FunctionType = decltype(init())(*)(AudioLineGuideGameObject*);
	static auto func = wrapFunction(base::get() + 0x1cb630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AudioLineGuideGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&AudioLineGuideGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(AudioLineGuideGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1cb680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RotateGameplayGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(RotateGameplayGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1d2480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto RotateGameplayGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RotateGameplayGameObject::init), this);
	using FunctionType = decltype(init())(*)(RotateGameplayGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d1270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RotateGameplayGameObject::updateStartValues() -> decltype(updateStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RotateGameplayGameObject::updateStartValues), this);
	using FunctionType = decltype(updateStartValues())(*)(RotateGameplayGameObject*);
	static auto func = wrapFunction(base::get() + 0x1d2800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RotateGameplayGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&RotateGameplayGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(RotateGameplayGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1d12c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TriggerControlGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(TriggerControlGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1cf8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto TriggerControlGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TriggerControlGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1cf650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TriggerControlGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TriggerControlGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TriggerControlGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1ceec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SequenceTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(SequenceTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1ab7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SequenceTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(SequenceTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1abe10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SequenceTriggerGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SequenceTriggerGameObject::init), this);
	using FunctionType = decltype(init())(*)(SequenceTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ab4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SequenceTriggerGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SequenceTriggerGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(SequenceTriggerGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ab4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SequenceTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&SequenceTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(SequenceTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1ac290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TransformTriggerGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(TransformTriggerGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1bcdb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto TransformTriggerGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TransformTriggerGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1bcde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TransformTriggerGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TransformTriggerGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TransformTriggerGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1bd1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AdvancedFollowTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(AdvancedFollowTriggerObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x196500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto AdvancedFollowTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&AdvancedFollowTriggerObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(AdvancedFollowTriggerObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x18fcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EventLinkTrigger::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(EventLinkTrigger*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1b5220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EventLinkTrigger::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EventLinkTrigger*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1b5f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EventLinkTrigger::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EventLinkTrigger::init), this);
	using FunctionType = decltype(init())(*)(EventLinkTrigger*);
	static auto func = wrapFunction(base::get() + 0x1b51d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EventLinkTrigger::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EventLinkTrigger::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EventLinkTrigger*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b53d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnterEffectObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EnterEffectObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x185f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EnterEffectObject::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EnterEffectObject::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EnterEffectObject*);
	static auto func = wrapFunction(base::get() + 0x185bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EnterEffectObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EnterEffectObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EnterEffectObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x175e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameOptionsTrigger::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(GameOptionsTrigger*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x199a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GameOptionsTrigger::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&GameOptionsTrigger::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(GameOptionsTrigger*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x198620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EnhancedTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(EnhancedTriggerObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1a5550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EnhancedTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&EnhancedTriggerObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(EnhancedTriggerObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a4d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GradientTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(GradientTriggerObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x18b290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GradientTriggerObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GradientTriggerObject::init), this);
	using FunctionType = decltype(init())(*)(GradientTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x18a0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GradientTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&GradientTriggerObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(GradientTriggerObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x18a100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto KeyframeAnimTriggerObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(KeyframeAnimTriggerObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1a4a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto KeyframeAnimTriggerObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeyframeAnimTriggerObject::init), this);
	using FunctionType = decltype(init())(*)(KeyframeAnimTriggerObject*);
	static auto func = wrapFunction(base::get() + 0x1a3e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeyframeAnimTriggerObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&KeyframeAnimTriggerObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(KeyframeAnimTriggerObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a3e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DashRingObject::create(char const* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(char const*);
	static auto func = wrapFunction(base::get() + 0x19dbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto DashRingObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(DashRingObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x19dd40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto DashRingObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&DashRingObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(DashRingObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x19deb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0xd9700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LevelSettingsObject::getSaveString() -> decltype(getSaveString()) {
	using FunctionType = decltype(getSaveString())(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0xdf860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelSettingsObject::objectFromDict(cocos2d::CCDictionary* p0) -> decltype(objectFromDict(p0)) {
	using FunctionType = decltype(objectFromDict(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0xf34a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSettingsObject::objectFromString(gd::string const& p0) -> decltype(objectFromString(p0)) {
	using FunctionType = decltype(objectFromString(p0))(*)(gd::string const&);
	static auto func = wrapFunction(base::get() + 0xdb700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelSettingsObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsObject::init), this);
	using FunctionType = decltype(init())(*)(LevelSettingsObject*);
	static auto func = wrapFunction(base::get() + 0xf32f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TeleportPortalObject::create(char const* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(char const*, bool);
	static auto func = wrapFunction(base::get() + 0x1a5aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto TeleportPortalObject::getTeleportXOff(cocos2d::CCNode* p0) -> decltype(getTeleportXOff(p0)) {
	using FunctionType = decltype(getTeleportXOff(p0))(*)(TeleportPortalObject*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x1a5d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto TeleportPortalObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(TeleportPortalObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1a7d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TeleportPortalObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&TeleportPortalObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(TeleportPortalObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x1a5e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&TeleportPortalObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(TeleportPortalObject*, float);
	static auto func = wrapFunction(base::get() + 0x1a5ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::setStartPos(cocos2d::CCPoint p0) -> decltype(setStartPos(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&TeleportPortalObject::setStartPos), this);
	using FunctionType = decltype(setStartPos(p0))(*)(TeleportPortalObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x1a5c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&TeleportPortalObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(TeleportPortalObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1a6040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::addToGroup(int p0) -> decltype(addToGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TeleportPortalObject::addToGroup), this);
	using FunctionType = decltype(addToGroup(p0))(*)(TeleportPortalObject*, int);
	static auto func = wrapFunction(base::get() + 0x1a5f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::removeFromGroup(int p0) -> decltype(removeFromGroup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TeleportPortalObject::removeFromGroup), this);
	using FunctionType = decltype(removeFromGroup(p0))(*)(TeleportPortalObject*, int);
	static auto func = wrapFunction(base::get() + 0x1a5fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::setRotation2(float p0) -> decltype(setRotation2(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&TeleportPortalObject::setRotation2), this);
	using FunctionType = decltype(setRotation2(p0))(*)(TeleportPortalObject*, float);
	static auto func = wrapFunction(base::get() + 0x1a5f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::addToGroup2(int p0) -> decltype(addToGroup2(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TeleportPortalObject::addToGroup2), this);
	using FunctionType = decltype(addToGroup2(p0))(*)(TeleportPortalObject*, int);
	static auto func = wrapFunction(base::get() + 0x1a5f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto TeleportPortalObject::removeFromGroup2(int p0) -> decltype(removeFromGroup2(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&TeleportPortalObject::removeFromGroup2), this);
	using FunctionType = decltype(removeFromGroup2(p0))(*)(TeleportPortalObject*, int);
	static auto func = wrapFunction(base::get() + 0x1a5f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AdvancedFollowEditObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(AdvancedFollowEditObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x198350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto AdvancedFollowEditObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&AdvancedFollowEditObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(AdvancedFollowEditObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1977d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsDelegate::levelSettingsUpdated() -> decltype(levelSettingsUpdated()) {
	throw std::runtime_error("LevelSettingsDelegate::levelSettingsUpdated not implemented");
}

LevelEditorLayer* LevelEditorLayer::get() {
        return GameManager::sharedState()->m_levelEditorLayer;
    }

auto LevelEditorLayer::init(GJGameLevel* p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(LevelEditorLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0xd7300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::getSongIDs(bool& p0) -> decltype(getSongIDs(p0)) {
	using FunctionType = decltype(getSongIDs(p0))(*)(LevelEditorLayer*, bool&);
	static auto func = wrapFunction(base::get() + 0xe4010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getAllObjects() -> decltype(getAllObjects()) {
	using FunctionType = decltype(getAllObjects())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xde200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::getLastObjectX() -> decltype(getLastObjectX()) {
	using FunctionType = decltype(getLastObjectX())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xeacf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::getLevelString() -> decltype(getLevelString()) {
	using FunctionType = decltype(getLevelString())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xdf4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::getLockedLayers() -> decltype(getLockedLayers()) {
	using FunctionType = decltype(getLockedLayers())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe3d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::getSectionCount() -> decltype(getSectionCount()) {
	using FunctionType = decltype(getSectionCount())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe4e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::getSavedEditorPosition(int p0) -> decltype(getSavedEditorPosition(p0)) {
	using FunctionType = decltype(getSavedEditorPosition(p0))(*)(LevelEditorLayer*, int);
	static auto func = wrapFunction(base::get() + 0xe49f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::getSavedEditorPositions() -> decltype(getSavedEditorPositions()) {
	using FunctionType = decltype(getSavedEditorPositions())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe4a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::getSFXIDs() -> decltype(getSFXIDs()) {
	using FunctionType = decltype(getSFXIDs())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe4540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::onPlaytest() -> decltype(onPlaytest()) {
	using FunctionType = decltype(onPlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xee840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::onStopPlaytest() -> decltype(onStopPlaytest()) {
	using FunctionType = decltype(onStopPlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xef430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::onPausePlaytest() -> decltype(onPausePlaytest()) {
	using FunctionType = decltype(onPausePlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xef110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::onResumePlaytest() -> decltype(onResumePlaytest()) {
	using FunctionType = decltype(onResumePlaytest())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xef2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::addSpecial(GameObject* p0) -> decltype(addSpecial(p0)) {
	using FunctionType = decltype(addSpecial(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xdbf30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::objectMoved(GameObject* p0) -> decltype(objectMoved(p0)) {
	using FunctionType = decltype(objectMoved(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xe5590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::createObject(int p0, cocos2d::CCPoint p1, bool p2) -> decltype(createObject(p0, p1, p2)) {
	using FunctionType = decltype(createObject(p0, p1, p2))(*)(LevelEditorLayer*, int, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0xdc4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelEditorLayer::handleAction(bool p0, cocos2d::CCArray* p1) -> decltype(handleAction(p0, p1)) {
	using FunctionType = decltype(handleAction(p0, p1))(*)(LevelEditorLayer*, bool, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0xdebb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::removeObject(GameObject* p0, bool p1) -> decltype(removeObject(p0, p1)) {
	using FunctionType = decltype(removeObject(p0, p1))(*)(LevelEditorLayer*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0xde260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::toggleGround(bool p0) -> decltype(toggleGround(p0)) {
	using FunctionType = decltype(toggleGround(p0))(*)(LevelEditorLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xdb060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::updateEditor(float p0) -> decltype(updateEditor(p0)) {
	using FunctionType = decltype(updateEditor(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0xd9800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::addToUndoList(UndoObject* p0, bool p1) -> decltype(addToUndoList(p0, p1)) {
	using FunctionType = decltype(addToUndoList(p0, p1))(*)(LevelEditorLayer*, UndoObject*, bool);
	static auto func = wrapFunction(base::get() + 0xdbdc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::isLayerLocked(int p0) -> decltype(isLayerLocked(p0)) {
	using FunctionType = decltype(isLayerLocked(p0))(*)(LevelEditorLayer*, int);
	static auto func = wrapFunction(base::get() + 0xe4ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::removeSpecial(GameObject* p0) -> decltype(removeSpecial(p0)) {
	using FunctionType = decltype(removeSpecial(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xde320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::updateOptions() -> decltype(updateOptions()) {
	using FunctionType = decltype(updateOptions())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xd8810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::addPlayerPoint(cocos2d::CCPoint p0) -> decltype(addPlayerPoint(p0)) {
	using FunctionType = decltype(addPlayerPoint(p0))(*)(LevelEditorLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xf7560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::redoLastAction() -> decltype(redoLastAction()) {
	using FunctionType = decltype(redoLastAction())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xdf480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::undoLastAction() -> decltype(undoLastAction()) {
	using FunctionType = decltype(undoLastAction())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xdf4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::unlockAllLayers() -> decltype(unlockAllLayers()) {
	using FunctionType = decltype(unlockAllLayers())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe4f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updateDebugDraw() -> decltype(updateDebugDraw()) {
	using FunctionType = decltype(updateDebugDraw())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe6970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updateLevelFont(int p0) -> decltype(updateLevelFont(p0)) {
	using FunctionType = decltype(updateLevelFont(p0))(*)(LevelEditorLayer*, int);
	static auto func = wrapFunction(base::get() + 0xed850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::updateEditorMode() -> decltype(updateEditorMode()) {
	using FunctionType = decltype(updateEditorMode())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xdac80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::objectsAtPosition(cocos2d::CCPoint p0) -> decltype(objectsAtPosition(p0)) {
	using FunctionType = decltype(objectsAtPosition(p0))(*)(LevelEditorLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xddaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::updateGameObjects() -> decltype(updateGameObjects()) {
	using FunctionType = decltype(updateGameObjects())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xd9c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updateObjectLabel(GameObject* p0) -> decltype(updateObjectLabel(p0)) {
	using FunctionType = decltype(updateObjectLabel(p0))(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0xe4f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelEditorLayer::updatePreviewAnim() -> decltype(updatePreviewAnim()) {
	using FunctionType = decltype(updatePreviewAnim())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xf0810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::saveEditorPosition(cocos2d::CCPoint& p0, int p1) -> decltype(saveEditorPosition(p0, p1)) {
	using FunctionType = decltype(saveEditorPosition(p0, p1))(*)(LevelEditorLayer*, cocos2d::CCPoint&, int);
	static auto func = wrapFunction(base::get() + 0xe49d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::claimCustomParticle(gd::string const& p0, cocos2d::ParticleStruct const& p1, int p2, int p3, int p4, bool p5) -> decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(claimCustomParticle(p0, p1, p2, p3, p4, p5))(*)(LevelEditorLayer*, gd::string const&, cocos2d::ParticleStruct const&, int, int, int, bool);
	static auto func = wrapFunction(base::get() + 0xf0900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto LevelEditorLayer::tryUpdateSpeedObject(EffectGameObject* p0, bool p1) -> decltype(tryUpdateSpeedObject(p0, p1)) {
	using FunctionType = decltype(tryUpdateSpeedObject(p0, p1))(*)(LevelEditorLayer*, EffectGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0xe5400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::unclaimCustomParticle(gd::string const& p0, cocos2d::CCParticleSystemQuad* p1) -> decltype(unclaimCustomParticle(p0, p1)) {
	using FunctionType = decltype(unclaimCustomParticle(p0, p1))(*)(LevelEditorLayer*, gd::string const&, cocos2d::CCParticleSystemQuad*);
	static auto func = wrapFunction(base::get() + 0xf09c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelEditorLayer::updateKeyframeObjects() -> decltype(updateKeyframeObjects()) {
	using FunctionType = decltype(updateKeyframeObjects())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xe68f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::updatePreviewParticle(ParticleGameObject* p0) -> decltype(updatePreviewParticle(p0)) {
	using FunctionType = decltype(updatePreviewParticle(p0))(*)(LevelEditorLayer*, ParticleGameObject*);
	static auto func = wrapFunction(base::get() + 0x19b760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::createObjectsFromSetup(gd::string& p0) -> decltype(createObjectsFromSetup(p0)) {
	using FunctionType = decltype(createObjectsFromSetup(p0))(*)(LevelEditorLayer*, gd::string&);
	static auto func = wrapFunction(base::get() + 0xd90b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::removeAllObjectsOfType(int p0) -> decltype(removeAllObjectsOfType(p0)) {
	using FunctionType = decltype(removeAllObjectsOfType(p0))(*)(LevelEditorLayer*, int);
	static auto func = wrapFunction(base::get() + 0xde830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::updatePreviewParticles() -> decltype(updatePreviewParticles()) {
	using FunctionType = decltype(updatePreviewParticles())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xea7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::resetUnusedColorChannels() -> decltype(resetUnusedColorChannels()) {
	using FunctionType = decltype(resetUnusedColorChannels())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xea560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelEditorLayer::rotationForSlopeNearObject(GameObject* p0) -> decltype(rotationForSlopeNearObject(p0)) {
	using FunctionType = decltype(rotationForSlopeNearObject(p0))(*)(LevelEditorLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xdcc90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelEditorLayer::scene(GJGameLevel* p0, bool p1) -> decltype(scene(p0, p1)) {
	using FunctionType = decltype(scene(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0xd71f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelEditorLayer::draw() -> decltype(draw()) {
	throw std::runtime_error("LevelEditorLayer::draw not implemented");
}

auto LevelEditorLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&LevelEditorLayer::postUpdate), this);
	using FunctionType = decltype(postUpdate(p0))(*)(LevelEditorLayer*, float);
	static auto func = wrapFunction(base::get() + 0xefae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelEditorLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	throw std::runtime_error("LevelEditorLayer::updateVisibility not implemented");
}

auto LevelEditorLayer::playerTookDamage(PlayerObject* p0) -> decltype(playerTookDamage(p0)) {
	throw std::runtime_error("LevelEditorLayer::playerTookDamage not implemented");
}

auto LevelEditorLayer::updateColor(cocos2d::_ccColor3B& p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue& p5, int p6, bool p7, EffectGameObject* p8, int p9, int p10) -> decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)) {
	throw std::runtime_error("LevelEditorLayer::updateColor not implemented");
}

auto LevelEditorLayer::addToGroup(GameObject* p0, int p1, bool p2) -> decltype(addToGroup(p0, p1, p2)) {
	throw std::runtime_error("LevelEditorLayer::addToGroup not implemented");
}

auto LevelEditorLayer::removeFromGroup(GameObject* p0, int p1) -> decltype(removeFromGroup(p0, p1)) {
	throw std::runtime_error("LevelEditorLayer::removeFromGroup not implemented");
}

auto LevelEditorLayer::updateObjectSection(GameObject* p0) -> decltype(updateObjectSection(p0)) {
	throw std::runtime_error("LevelEditorLayer::updateObjectSection not implemented");
}

auto LevelEditorLayer::updateDisabledObjectsLastPos(cocos2d::CCArray* p0) -> decltype(updateDisabledObjectsLastPos(p0)) {
	throw std::runtime_error("LevelEditorLayer::updateDisabledObjectsLastPos not implemented");
}

auto LevelEditorLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) -> decltype(timeForPos(p0, p1, p2, p3, p4)) {
	throw std::runtime_error("LevelEditorLayer::timeForPos not implemented");
}

auto LevelEditorLayer::posForTime(float p0) -> decltype(posForTime(p0)) {
	throw std::runtime_error("LevelEditorLayer::posForTime not implemented");
}

auto LevelEditorLayer::resetSPTriggered() -> decltype(resetSPTriggered()) {
	throw std::runtime_error("LevelEditorLayer::resetSPTriggered not implemented");
}

auto LevelEditorLayer::didRotateGameplay() -> decltype(didRotateGameplay()) {
	throw std::runtime_error("LevelEditorLayer::didRotateGameplay not implemented");
}

auto LevelEditorLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	throw std::runtime_error("LevelEditorLayer::manualUpdateObjectColors not implemented");
}

auto LevelEditorLayer::activatedAudioTrigger(SFXTriggerGameObject* p0) -> decltype(activatedAudioTrigger(p0)) {
	throw std::runtime_error("LevelEditorLayer::activatedAudioTrigger not implemented");
}

auto LevelEditorLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	throw std::runtime_error("LevelEditorLayer::checkpointActivated not implemented");
}

auto LevelEditorLayer::addKeyframe(KeyframeGameObject* p0) -> decltype(addKeyframe(p0)) {
	throw std::runtime_error("LevelEditorLayer::addKeyframe not implemented");
}

auto LevelEditorLayer::levelSettingsUpdated() -> decltype(levelSettingsUpdated()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelEditorLayer::levelSettingsUpdated), this);
	using FunctionType = decltype(levelSettingsUpdated())(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xdb2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectDelegate::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	throw std::runtime_error("ColorSelectDelegate::colorSelectClosed not implemented");
}

auto GJRotationControlDelegate::angleChanged(float p0) -> decltype(angleChanged(p0)) {
	throw std::runtime_error("GJRotationControlDelegate::angleChanged not implemented");
}

auto GJRotationControlDelegate::angleChangeBegin() -> decltype(angleChangeBegin()) {
	throw std::runtime_error("GJRotationControlDelegate::angleChangeBegin not implemented");
}

auto GJRotationControlDelegate::angleChangeEnded() -> decltype(angleChangeEnded()) {
	throw std::runtime_error("GJRotationControlDelegate::angleChangeEnded not implemented");
}

auto GJScaleControlDelegate::scaleXChanged(float p0) -> decltype(scaleXChanged(p0)) {
	throw std::runtime_error("GJScaleControlDelegate::scaleXChanged not implemented");
}

auto GJScaleControlDelegate::scaleYChanged(float p0) -> decltype(scaleYChanged(p0)) {
	throw std::runtime_error("GJScaleControlDelegate::scaleYChanged not implemented");
}

auto GJScaleControlDelegate::scaleXYChanged(float p0, float p1) -> decltype(scaleXYChanged(p0, p1)) {
	throw std::runtime_error("GJScaleControlDelegate::scaleXYChanged not implemented");
}

auto GJScaleControlDelegate::scaleChangeBegin() -> decltype(scaleChangeBegin()) {
	throw std::runtime_error("GJScaleControlDelegate::scaleChangeBegin not implemented");
}

auto GJScaleControlDelegate::scaleChangeEnded() -> decltype(scaleChangeEnded()) {
	throw std::runtime_error("GJScaleControlDelegate::scaleChangeEnded not implemented");
}

auto GJScaleControlDelegate::updateScaleControl() -> decltype(updateScaleControl()) {
	throw std::runtime_error("GJScaleControlDelegate::updateScaleControl not implemented");
}

auto GJScaleControlDelegate::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	throw std::runtime_error("GJScaleControlDelegate::anchorPointMoved not implemented");
}

auto GJTransformControlDelegate::transformScaleXChanged(float p0) -> decltype(transformScaleXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleXChanged not implemented");
}

auto GJTransformControlDelegate::transformScaleYChanged(float p0) -> decltype(transformScaleYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleYChanged not implemented");
}

auto GJTransformControlDelegate::transformScaleXYChanged(float p0, float p1) -> decltype(transformScaleXYChanged(p0, p1)) {
	throw std::runtime_error("GJTransformControlDelegate::transformScaleXYChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationXChanged(float p0) -> decltype(transformRotationXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationXChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationYChanged(float p0) -> decltype(transformRotationYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationYChanged not implemented");
}

auto GJTransformControlDelegate::transformRotationChanged(float p0) -> decltype(transformRotationChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformRotationChanged not implemented");
}

auto GJTransformControlDelegate::transformResetRotation() -> decltype(transformResetRotation()) {
	throw std::runtime_error("GJTransformControlDelegate::transformResetRotation not implemented");
}

auto GJTransformControlDelegate::transformRestoreRotation() -> decltype(transformRestoreRotation()) {
	throw std::runtime_error("GJTransformControlDelegate::transformRestoreRotation not implemented");
}

auto GJTransformControlDelegate::transformSkewXChanged(float p0) -> decltype(transformSkewXChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformSkewXChanged not implemented");
}

auto GJTransformControlDelegate::transformSkewYChanged(float p0) -> decltype(transformSkewYChanged(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::transformSkewYChanged not implemented");
}

auto GJTransformControlDelegate::transformChangeBegin() -> decltype(transformChangeBegin()) {
	throw std::runtime_error("GJTransformControlDelegate::transformChangeBegin not implemented");
}

auto GJTransformControlDelegate::transformChangeEnded() -> decltype(transformChangeEnded()) {
	throw std::runtime_error("GJTransformControlDelegate::transformChangeEnded not implemented");
}

auto GJTransformControlDelegate::updateTransformControl() -> decltype(updateTransformControl()) {
	throw std::runtime_error("GJTransformControlDelegate::updateTransformControl not implemented");
}

auto GJTransformControlDelegate::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	throw std::runtime_error("GJTransformControlDelegate::anchorPointMoved not implemented");
}

auto GJTransformControlDelegate::getTransformNode() -> decltype(getTransformNode()) {
	throw std::runtime_error("GJTransformControlDelegate::getTransformNode not implemented");
}

auto GJTransformControlDelegate::getUI() -> decltype(getUI()) {
	throw std::runtime_error("GJTransformControlDelegate::getUI not implemented");
}

auto MusicDownloadDelegate::loadSongInfoFinished(SongInfoObject* p0) -> decltype(loadSongInfoFinished(p0)) {
	throw std::runtime_error("MusicDownloadDelegate::loadSongInfoFinished not implemented");
}

auto MusicDownloadDelegate::loadSongInfoFailed(int p0, GJSongError p1) -> decltype(loadSongInfoFailed(p0, p1)) {
	throw std::runtime_error("MusicDownloadDelegate::loadSongInfoFailed not implemented");
}

auto MusicDownloadDelegate::downloadSongFinished(int p0) -> decltype(downloadSongFinished(p0)) {
	throw std::runtime_error("MusicDownloadDelegate::downloadSongFinished not implemented");
}

auto MusicDownloadDelegate::downloadSongFailed(int p0, GJSongError p1) -> decltype(downloadSongFailed(p0, p1)) {
	throw std::runtime_error("MusicDownloadDelegate::downloadSongFailed not implemented");
}

auto MusicDownloadDelegate::songStateChanged() -> decltype(songStateChanged()) {
	throw std::runtime_error("MusicDownloadDelegate::songStateChanged not implemented");
}

auto MusicDownloadDelegate::downloadSFXFinished(int p0) -> decltype(downloadSFXFinished(p0)) {
	throw std::runtime_error("MusicDownloadDelegate::downloadSFXFinished not implemented");
}

auto MusicDownloadDelegate::downloadSFXFailed(int p0, GJSongError p1) -> decltype(downloadSFXFailed(p0, p1)) {
	throw std::runtime_error("MusicDownloadDelegate::downloadSFXFailed not implemented");
}

auto MusicDownloadDelegate::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	throw std::runtime_error("MusicDownloadDelegate::musicActionFinished not implemented");
}

auto MusicDownloadDelegate::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	throw std::runtime_error("MusicDownloadDelegate::musicActionFailed not implemented");
}

auto EditorUI::init(LevelEditorLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EditorUI*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0xcc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::getSnapAngle(GameObject* p0, cocos2d::CCArray* p1) -> decltype(getSnapAngle(p0, p1)) {
	using FunctionType = decltype(getSnapAngle(p0, p1))(*)(EditorUI*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x4db40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::getGroupCenter(cocos2d::CCArray* p0, bool p1) -> decltype(getGroupCenter(p0, p1)) {
	using FunctionType = decltype(getGroupCenter(p0, p1))(*)(EditorUI*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x3f570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::getRelativeOffset(GameObject* p0) -> decltype(getRelativeOffset(p0)) {
	using FunctionType = decltype(getRelativeOffset(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x4ca710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::getSelectedObjects() -> decltype(getSelectedObjects()) {
	using FunctionType = decltype(getSelectedObjects())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x406e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::getEditColorTargets(ColorAction*& p0, ColorAction*& p1, EffectGameObject*& p2) -> decltype(getEditColorTargets(p0, p1, p2)) {
	using FunctionType = decltype(getEditColorTargets(p0, p1, p2))(*)(EditorUI*, ColorAction*&, ColorAction*&, EffectGameObject*&);
	static auto func = wrapFunction(base::get() + 0x4cf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::getCreateMenuItemButton(cocos2d::CCSprite* p0, cocos2d::SEL_MenuHandler p1, cocos2d::CCMenu* p2, float p3, int p4, cocos2d::CCPoint p5) -> decltype(getCreateMenuItemButton(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(getCreateMenuItemButton(p0, p1, p2, p3, p4, p5))(*)(EditorUI*, cocos2d::CCSprite*, cocos2d::SEL_MenuHandler, cocos2d::CCMenu*, float, int, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x326f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto EditorUI::getXMin(int p0) -> decltype(getXMin(p0)) {
	using FunctionType = decltype(getXMin(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0x329d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::onPlayback(cocos2d::CCObject* sender) -> decltype(onPlayback(sender)) {
	using FunctionType = decltype(onPlayback(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xff20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPlaytest(cocos2d::CCObject* sender) -> decltype(onPlaytest(sender)) {
	using FunctionType = decltype(onPlaytest(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x10160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDuplicate(cocos2d::CCObject* sender) -> decltype(onDuplicate(sender)) {
	using FunctionType = decltype(onDuplicate(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onGroupSticky(cocos2d::CCObject* sender) -> decltype(onGroupSticky(sender)) {
	using FunctionType = decltype(onGroupSticky(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x10540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onCreateObject(int p0) -> decltype(onCreateObject(p0)) {
	using FunctionType = decltype(onCreateObject(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0x384d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::onStopPlaytest(cocos2d::CCObject* sender) -> decltype(onStopPlaytest(sender)) {
	using FunctionType = decltype(onStopPlaytest(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x103a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onUngroupSticky(cocos2d::CCObject* sender) -> decltype(onUngroupSticky(sender)) {
	using FunctionType = decltype(onUngroupSticky(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x10590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeleteSelected(cocos2d::CCObject* sender) -> decltype(onDeleteSelected(sender)) {
	using FunctionType = decltype(onDeleteSelected(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xfd90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeleteStartPos(cocos2d::CCObject* sender) -> decltype(onDeleteStartPos(sender)) {
	using FunctionType = decltype(onDeleteStartPos(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onDeleteSelectedType(cocos2d::CCObject* sender) -> decltype(onDeleteSelectedType(sender)) {
	using FunctionType = decltype(onDeleteSelectedType(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x35690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPaste(cocos2d::CCObject* sender) -> decltype(onPaste(sender)) {
	using FunctionType = decltype(onPaste(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2eaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onPause(cocos2d::CCObject* sender) -> decltype(onPause(sender)) {
	using FunctionType = decltype(onPause(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::onCreate() -> decltype(onCreate()) {
	using FunctionType = decltype(onCreate())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x31b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::onDelete(cocos2d::CCObject* sender) -> decltype(onDelete(sender)) {
	using FunctionType = decltype(onDelete(sender))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x316b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorUI::createLoop() -> decltype(createLoop()) {
	using FunctionType = decltype(createLoop())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x48bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::moveObject(GameObject* p0, cocos2d::CCPoint p1) -> decltype(moveObject(p0, p1)) {
	using FunctionType = decltype(moveObject(p0, p1))(*)(EditorUI*, GameObject*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x42170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::toggleMode(cocos2d::CCObject* p0) -> decltype(toggleMode(p0)) {
	using FunctionType = decltype(toggleMode(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleSnap(cocos2d::CCObject* p0) -> decltype(toggleSnap(p0)) {
	using FunctionType = decltype(toggleSnap(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xfb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::updateZoom(float p0) -> decltype(updateZoom(p0)) {
	using FunctionType = decltype(updateZoom(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x41400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::deselectAll() -> decltype(deselectAll()) {
	using FunctionType = decltype(deselectAll())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x36640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::toggleSwipe(cocos2d::CCObject* p0) -> decltype(toggleSwipe(p0)) {
	using FunctionType = decltype(toggleSwipe(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xf9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::alignObjects(cocos2d::CCArray* p0, bool p1) -> decltype(alignObjects(p0, p1)) {
	using FunctionType = decltype(alignObjects(p0, p1))(*)(EditorUI*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x50c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::deleteObject(GameObject* p0, bool p1) -> decltype(deleteObject(p0, p1)) {
	using FunctionType = decltype(deleteObject(p0, p1))(*)(EditorUI*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x36370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::scaleObjects(cocos2d::CCArray* p0, float p1, float p2, cocos2d::CCPoint p3, ObjectScaleType p4) -> decltype(scaleObjects(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(scaleObjects(p0, p1, p2, p3, p4))(*)(EditorUI*, cocos2d::CCArray*, float, float, cocos2d::CCPoint, ObjectScaleType);
	static auto func = wrapFunction(base::get() + 0x42ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto EditorUI::selectObject(GameObject* p0, bool p1) -> decltype(selectObject(p0, p1)) {
	using FunctionType = decltype(selectObject(p0, p1))(*)(EditorUI*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x32190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::showMaxError() -> decltype(showMaxError()) {
	using FunctionType = decltype(showMaxError())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x38120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::toggleLockUI(bool p0) -> decltype(toggleLockUI(p0)) {
	using FunctionType = decltype(toggleLockUI(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x30d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::doCopyObjects(bool p0) -> decltype(doCopyObjects(p0)) {
	using FunctionType = decltype(doCopyObjects(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x419e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::moveGamelayer(cocos2d::CCPoint p0) -> decltype(moveGamelayer(p0)) {
	using FunctionType = decltype(moveGamelayer(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x32d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::rotateObjects(cocos2d::CCArray* p0, float p1, cocos2d::CCPoint p2) -> decltype(rotateObjects(p0, p1, p2)) {
	using FunctionType = decltype(rotateObjects(p0, p1, p2))(*)(EditorUI*, cocos2d::CCArray*, float, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x3f780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::selectObjects(cocos2d::CCArray* p0, bool p1) -> decltype(selectObjects(p0, p1)) {
	using FunctionType = decltype(selectObjects(p0, p1))(*)(EditorUI*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x3fbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::setupEditMenu() -> decltype(setupEditMenu()) {
	using FunctionType = decltype(setupEditMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x496b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::sliderChanged(cocos2d::CCObject* p0) -> decltype(sliderChanged(p0)) {
	using FunctionType = decltype(sliderChanged(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xf360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::updateButtons() -> decltype(updateButtons()) {
	using FunctionType = decltype(updateButtons())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x303f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::deselectObject(GameObject* p0) -> decltype(deselectObject(p0)) {
	using FunctionType = decltype(deselectObject(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x365a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::deselectObject() -> decltype(deselectObject()) {
	using FunctionType = decltype(deselectObject())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x36850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::doPasteObjects(bool p0) -> decltype(doPasteObjects(p0)) {
	using FunctionType = decltype(doPasteObjects(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x41b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::moveObjectCall(EditCommand p0) -> decltype(moveObjectCall(p0)) {
	using FunctionType = decltype(moveObjectCall(p0))(*)(EditorUI*, EditCommand);
	static auto func = wrapFunction(base::get() + 0x4d7c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::redoLastAction(cocos2d::CCObject* p0) -> decltype(redoLastAction(p0)) {
	using FunctionType = decltype(redoLastAction(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xfd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleFreeMove(cocos2d::CCObject* p0) -> decltype(toggleFreeMove(p0)) {
	using FunctionType = decltype(toggleFreeMove(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xfab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::undoLastAction(cocos2d::CCObject* p0) -> decltype(undoLastAction(p0)) {
	using FunctionType = decltype(undoLastAction(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xfcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::assignNewGroups(bool p0) -> decltype(assignNewGroups(p0)) {
	using FunctionType = decltype(assignNewGroups(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x487f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::createRockBases(cocos2d::CCArray* p0) -> decltype(createRockBases(p0)) {
	using FunctionType = decltype(createRockBases(p0))(*)(EditorUI*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x5d8d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::playtestStopped() -> decltype(playtestStopped()) {
	using FunctionType = decltype(playtestStopped())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x41330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::setupCreateMenu() -> decltype(setupCreateMenu()) {
	using FunctionType = decltype(setupCreateMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x11500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::setupDeleteMenu() -> decltype(setupDeleteMenu()) {
	using FunctionType = decltype(setupDeleteMenu())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x105e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::transformObject(GameObject* p0, EditCommand p1, bool p2) -> decltype(transformObject(p0, p1, p2)) {
	using FunctionType = decltype(transformObject(p0, p1, p2))(*)(EditorUI*, GameObject*, EditCommand, bool);
	static auto func = wrapFunction(base::get() + 0x4ec40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto EditorUI::createUndoObject(UndoCommand p0, bool p1) -> decltype(createUndoObject(p0, p1)) {
	using FunctionType = decltype(createUndoObject(p0, p1))(*)(EditorUI*, UndoCommand, bool);
	static auto func = wrapFunction(base::get() + 0x40790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::editButtonUsable() -> decltype(editButtonUsable()) {
	using FunctionType = decltype(editButtonUsable())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x4b3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::showMaxCoinError() -> decltype(showMaxCoinError()) {
	using FunctionType = decltype(showMaxCoinError())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x383a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateCreateMenu(bool p0) -> decltype(updateCreateMenu(p0)) {
	using FunctionType = decltype(updateCreateMenu(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x31c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::createCustomItems() -> decltype(createCustomItems()) {
	using FunctionType = decltype(createCustomItems())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x35000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::editButton2Usable() -> decltype(editButton2Usable()) {
	using FunctionType = decltype(editButton2Usable())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x4c120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::showMaxBasicError() -> decltype(showMaxBasicError()) {
	using FunctionType = decltype(showMaxBasicError())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x38260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updatePlaybackBtn() -> decltype(updatePlaybackBtn()) {
	using FunctionType = decltype(updatePlaybackBtn())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x30c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::dynamicGroupUpdate(bool p0) -> decltype(dynamicGroupUpdate(p0)) {
	using FunctionType = decltype(dynamicGroupUpdate(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x47c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::recreateButtonTabs() -> decltype(recreateButtonTabs()) {
	using FunctionType = decltype(recreateButtonTabs())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x355b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::shouldDeleteObject(GameObject* p0) -> decltype(shouldDeleteObject(p0)) {
	using FunctionType = decltype(shouldDeleteObject(p0))(*)(EditorUI*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x36140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::toggleEnableRotate(cocos2d::CCObject* p0) -> decltype(toggleEnableRotate(p0)) {
	using FunctionType = decltype(toggleEnableRotate(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xfba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::updateGridNodeSize() -> decltype(updateGridNodeSize()) {
	using FunctionType = decltype(updateGridNodeSize())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x32b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateGroupIDLabel() -> decltype(updateGroupIDLabel()) {
	using FunctionType = decltype(updateGroupIDLabel())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x302f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::isSpecialSnapObject(int p0) -> decltype(isSpecialSnapObject(p0)) {
	using FunctionType = decltype(isSpecialSnapObject(p0))(*)(EditorUI*, int);
	static auto func = wrapFunction(base::get() + 0x4f110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::transformObjectCall(EditCommand p0) -> decltype(transformObjectCall(p0)) {
	using FunctionType = decltype(transformObjectCall(p0))(*)(EditorUI*, EditCommand);
	static auto func = wrapFunction(base::get() + 0x4dbf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::updateDeleteButtons() -> decltype(updateDeleteButtons()) {
	using FunctionType = decltype(updateDeleteButtons())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x35a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::changeSelectedObjects(cocos2d::CCArray* p0, bool p1) -> decltype(changeSelectedObjects(p0, p1)) {
	using FunctionType = decltype(changeSelectedObjects(p0, p1))(*)(EditorUI*, cocos2d::CCArray*, bool);
	static auto func = wrapFunction(base::get() + 0x40570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::deselectTargetPortals() -> decltype(deselectTargetPortals()) {
	using FunctionType = decltype(deselectTargetPortals())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x36210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::toggleObjectInfoLabel() -> decltype(toggleObjectInfoLabel()) {
	using FunctionType = decltype(toggleObjectInfoLabel())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x30b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateEditButtonColor(int p0, cocos2d::_ccColor3B p1) -> decltype(updateEditButtonColor(p0, p1)) {
	using FunctionType = decltype(updateEditButtonColor(p0, p1))(*)(EditorUI*, int, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x42300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::updateEditColorButton() -> decltype(updateEditColorButton()) {
	using FunctionType = decltype(updateEditColorButton())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x4c630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::updateObjectInfoLabel() -> decltype(updateObjectInfoLabel()) {
	using FunctionType = decltype(updateObjectInfoLabel())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x32dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::selectAllWithDirection(bool p0) -> decltype(selectAllWithDirection(p0)) {
	using FunctionType = decltype(selectAllWithDirection(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x40d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::spriteFromObjectString(gd::string p0, bool p1, bool p2, int p3, cocos2d::CCArray* p4, cocos2d::CCArray* p5, GameObject* p6) -> decltype(spriteFromObjectString(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(spriteFromObjectString(p0, p1, p2, p3, p4, p5, p6))(*)(EditorUI*, gd::string, bool, bool, int, cocos2d::CCArray*, cocos2d::CCArray*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x37820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto EditorUI::activateRotationControl(cocos2d::CCObject* p0) -> decltype(activateRotationControl(p0)) {
	using FunctionType = decltype(activateRotationControl(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x41020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::activateTransformControl(cocos2d::CCObject* p0) -> decltype(activateTransformControl(p0)) {
	using FunctionType = decltype(activateTransformControl(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x437d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::menuItemFromObjectString(gd::string p0, int p1) -> decltype(menuItemFromObjectString(p0, p1)) {
	using FunctionType = decltype(menuItemFromObjectString(p0, p1))(*)(EditorUI*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x35380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EditorUI::toggleSpecialEditButtons() -> decltype(toggleSpecialEditButtons()) {
	using FunctionType = decltype(toggleSpecialEditButtons())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x30f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::constrainGameLayerPosition(float x, float y) -> decltype(constrainGameLayerPosition(x, y)) {
	using FunctionType = decltype(constrainGameLayerPosition(x, y))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0x2e5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, x, y);
}

void EditorUI::constrainGameLayerPosition() {
		this->constrainGameLayerPosition(-100, -100);
	}

auto EditorUI::showUI(bool p0) -> decltype(showUI(p0)) {
	using FunctionType = decltype(showUI(p0))(*)(EditorUI*, bool);
	static auto func = wrapFunction(base::get() + 0x411b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::zoomIn(cocos2d::CCObject* p0) -> decltype(zoomIn(p0)) {
	using FunctionType = decltype(zoomIn(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x104a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::resetUI() -> decltype(resetUI()) {
	using FunctionType = decltype(resetUI())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x2e250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::zoomOut(cocos2d::CCObject* p0) -> decltype(zoomOut(p0)) {
	using FunctionType = decltype(zoomOut(p0))(*)(EditorUI*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x104f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorUI::selectAll() -> decltype(selectAll()) {
	using FunctionType = decltype(selectAll())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x40a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorUI::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::draw), this);
	using FunctionType = decltype(draw())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x515f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x520b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x526d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x52c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&EditorUI::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(EditorUI*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x535c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x53600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x422d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorUI::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditorUI*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x53640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::getUI() -> decltype(getUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::getUI), this);
	using FunctionType = decltype(getUI())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x57430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&EditorUI::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(EditorUI*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x36bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditorUI::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditorUI*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x36a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::updateTransformControl() -> decltype(updateTransformControl()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::updateTransformControl), this);
	using FunctionType = decltype(updateTransformControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x43bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformChangeBegin() -> decltype(transformChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformChangeBegin), this);
	using FunctionType = decltype(transformChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x445a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformChangeEnded() -> decltype(transformChangeEnded()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformChangeEnded), this);
	using FunctionType = decltype(transformChangeEnded())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x44680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::getTransformNode() -> decltype(getTransformNode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::getTransformNode), this);
	using FunctionType = decltype(getTransformNode())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x57440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformScaleXChanged(float p0) -> decltype(transformScaleXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformScaleXChanged), this);
	using FunctionType = decltype(transformScaleXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x4fe20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformScaleYChanged(float p0) -> decltype(transformScaleYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformScaleYChanged), this);
	using FunctionType = decltype(transformScaleYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x50030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformScaleXYChanged(float p0, float p1) -> decltype(transformScaleXYChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::transformScaleXYChanged), this);
	using FunctionType = decltype(transformScaleXYChanged(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0x50190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::transformSkewXChanged(float p0) -> decltype(transformSkewXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformSkewXChanged), this);
	using FunctionType = decltype(transformSkewXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x50300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformSkewYChanged(float p0) -> decltype(transformSkewYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformSkewYChanged), this);
	using FunctionType = decltype(transformSkewYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x50460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationXChanged(float p0) -> decltype(transformRotationXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationXChanged), this);
	using FunctionType = decltype(transformRotationXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x505c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationYChanged(float p0) -> decltype(transformRotationYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationYChanged), this);
	using FunctionType = decltype(transformRotationYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x50720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformRotationChanged(float p0) -> decltype(transformRotationChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::transformRotationChanged), this);
	using FunctionType = decltype(transformRotationChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x50880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::transformResetRotation() -> decltype(transformResetRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformResetRotation), this);
	using FunctionType = decltype(transformResetRotation())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x509f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::transformRestoreRotation() -> decltype(transformRestoreRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::transformRestoreRotation), this);
	using FunctionType = decltype(transformRestoreRotation())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x50ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x41300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&EditorUI::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(EditorUI*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x4d3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorUI::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(EditorUI*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x54720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0x547c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditorUI::angleChangeBegin() -> decltype(angleChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::angleChangeBegin), this);
	using FunctionType = decltype(angleChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x516d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::angleChangeEnded() -> decltype(angleChangeEnded()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::angleChangeEnded), this);
	using FunctionType = decltype(angleChangeEnded())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x51710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::angleChanged(float p0) -> decltype(angleChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::angleChanged), this);
	using FunctionType = decltype(angleChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x51730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::updateScaleControl() -> decltype(updateScaleControl()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::updateScaleControl), this);
	using FunctionType = decltype(updateScaleControl())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x42700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::anchorPointMoved(cocos2d::CCPoint p0) -> decltype(anchorPointMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&EditorUI::anchorPointMoved), this);
	using FunctionType = decltype(anchorPointMoved(p0))(*)(EditorUI*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x446a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scaleChangeBegin() -> decltype(scaleChangeBegin()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::scaleChangeBegin), this);
	using FunctionType = decltype(scaleChangeBegin())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x42dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::scaleChangeEnded() -> decltype(scaleChangeEnded()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorUI::scaleChangeEnded), this);
	using FunctionType = decltype(scaleChangeEnded())(*)(EditorUI*);
	static auto func = wrapFunction(base::get() + 0x42e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorUI::scaleXChanged(float p0) -> decltype(scaleXChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::scaleXChanged), this);
	using FunctionType = decltype(scaleXChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x42e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scaleYChanged(float p0) -> decltype(scaleYChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&EditorUI::scaleYChanged), this);
	using FunctionType = decltype(scaleYChanged(p0))(*)(EditorUI*, float);
	static auto func = wrapFunction(base::get() + 0x43550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorUI::scaleXYChanged(float p0, float p1) -> decltype(scaleXYChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&EditorUI::scaleXYChanged), this);
	using FunctionType = decltype(scaleXYChanged(p0, p1))(*)(EditorUI*, float, float);
	static auto func = wrapFunction(base::get() + 0x43680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCCircleWave::create(float p0, float p1, float p2, bool p3) -> decltype(create(p0, p1, p2, p3)) {
	using FunctionType = decltype(create(p0, p1, p2, p3))(*)(float, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x1693e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3);
}

auto CCCircleWave::create(float p0, float p1, float p2, bool p3, bool p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(float, float, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1693f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto CCCircleWave::init(float p0, float p1, float p2, bool p3, bool p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(CCCircleWave*, float, float, float, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1694d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto CCCircleWave::updatePosition(float p0) -> decltype(updatePosition(p0)) {
	using FunctionType = decltype(updatePosition(p0))(*)(CCCircleWave*, float);
	static auto func = wrapFunction(base::get() + 0x169760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCCircleWave::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&CCCircleWave::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(CCCircleWave*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x169730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCCircleWave::removeMeAndCleanup() -> decltype(removeMeAndCleanup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCCircleWave::removeMeAndCleanup), this);
	using FunctionType = decltype(removeMeAndCleanup())(*)(CCCircleWave*);
	static auto func = wrapFunction(base::get() + 0x169c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCCircleWave::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCCircleWave::draw), this);
	using FunctionType = decltype(draw())(*)(CCCircleWave*);
	static auto func = wrapFunction(base::get() + 0x169ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCCircleWave::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&CCCircleWave::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(CCCircleWave*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x169830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CurrencyRewardLayer::create(int p0, int p1, int p2, int p3, CurrencySpriteType p4, int p5, CurrencySpriteType p6, int p7, cocos2d::CCPoint p8, CurrencyRewardType p9, float p10, float p11) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11))(*)(int, int, int, int, CurrencySpriteType, int, CurrencySpriteType, int, cocos2d::CCPoint, CurrencyRewardType, float, float);
	static auto func = wrapFunction(base::get() + 0x767320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
}

auto CurrencyRewardLayer::init(int p0, int p1, int p2, int p3, CurrencySpriteType p4, int p5, CurrencySpriteType p6, int p7, cocos2d::CCPoint p8, CurrencyRewardType p9, float p10, float p11) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11))(*)(CurrencyRewardLayer*, int, int, int, int, CurrencySpriteType, int, CurrencySpriteType, int, cocos2d::CCPoint, CurrencyRewardType, float, float);
	static auto func = wrapFunction(base::get() + 0x767400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11);
}

auto CurrencyRewardLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CurrencyRewardLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(CurrencyRewardLayer*, float);
	static auto func = wrapFunction(base::get() + 0x76a390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCCircleWaveDelegate::circleWaveWillBeRemoved(CCCircleWave* p0) -> decltype(circleWaveWillBeRemoved(p0)) {
	throw std::runtime_error("CCCircleWaveDelegate::circleWaveWillBeRemoved not implemented");
}

auto CurrencyRewardDelegate::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	throw std::runtime_error("CurrencyRewardDelegate::currencyWillExit not implemented");
}

auto PlayLayer::create(GJGameLevel* p0, bool p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0xa5d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

PlayLayer* PlayLayer::get() {
		return GameManager::get()->m_playLayer;
	}

auto PlayLayer::init(GJGameLevel* p0, bool p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(PlayLayer*, GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0xa5db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

PlayLayer::~PlayLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xa5920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) PlayLayer(geode::CutoffConstructor, sizeof(PlayLayer));
	CCDestructor::lock(this) = true;
}

auto PlayLayer::getCurrentPercent() -> decltype(getCurrentPercent()) {
	using FunctionType = decltype(getCurrentPercent())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb3970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::getLastCheckpoint() -> decltype(getLastCheckpoint()) {
	using FunctionType = decltype(getLastCheckpoint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb6b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::onQuit() -> decltype(onQuit()) {
	using FunctionType = decltype(onQuit())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xad390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resetLevel() -> decltype(resetLevel()) {
	using FunctionType = decltype(resetLevel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xac8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::startMusic() -> decltype(startMusic()) {
	using FunctionType = decltype(startMusic())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xad570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showNewBest(bool p0, int p1, int p2, bool p3, bool p4, bool p5) -> decltype(showNewBest(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(showNewBest(p0, p1, p2, p3, p4, p5))(*)(PlayLayer*, bool, int, int, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0xaf2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto PlayLayer::prepareMusic(bool p0) -> decltype(prepareMusic(p0)) {
	using FunctionType = decltype(prepareMusic(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xad230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::levelComplete() -> decltype(levelComplete()) {
	using FunctionType = decltype(levelComplete())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xad6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::incrementJumps() -> decltype(incrementJumps()) {
	using FunctionType = decltype(incrementJumps())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb8700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::markCheckpoint() -> decltype(markCheckpoint()) {
	using FunctionType = decltype(markCheckpoint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb53a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::storeCheckpoint(CheckpointObject* p0) -> decltype(storeCheckpoint(p0)) {
	using FunctionType = decltype(storeCheckpoint(p0))(*)(PlayLayer*, CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0xb74f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::updateInfoLabel() -> decltype(updateInfoLabel()) {
	using FunctionType = decltype(updateInfoLabel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xa96e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::removeAllObjects() -> decltype(removeAllObjects()) {
	using FunctionType = decltype(removeAllObjects())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xad440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::removeCheckpoint(bool p0) -> decltype(removeCheckpoint(p0)) {
	using FunctionType = decltype(removeCheckpoint(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xb7590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::resumeAndRestart(bool p0) -> decltype(resumeAndRestart(p0)) {
	using FunctionType = decltype(resumeAndRestart(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xb88d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::showCompleteText() -> decltype(showCompleteText()) {
	using FunctionType = decltype(showCompleteText())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xae690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::startGameDelayed() -> decltype(startGameDelayed()) {
	using FunctionType = decltype(startGameDelayed())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xad660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::delayedResetLevel() -> decltype(delayedResetLevel()) {
	using FunctionType = decltype(delayedResetLevel())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb4c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::loadDefaultColors() -> decltype(loadDefaultColors()) {
	using FunctionType = decltype(loadDefaultColors())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xab730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::setupHasCompleted() -> decltype(setupHasCompleted()) {
	using FunctionType = decltype(setupHasCompleted())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xa7210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateProgressbar() -> decltype(updateProgressbar()) {
	using FunctionType = decltype(updateProgressbar())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xab590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::loadFromCheckpoint(CheckpointObject* p0) -> decltype(loadFromCheckpoint(p0)) {
	using FunctionType = decltype(loadFromCheckpoint(p0))(*)(PlayLayer*, CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0xb7690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::loadLastCheckpoint() -> decltype(loadLastCheckpoint()) {
	using FunctionType = decltype(loadLastCheckpoint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb7640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showCompleteEffect() -> decltype(showCompleteEffect()) {
	using FunctionType = decltype(showCompleteEffect())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xae230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::togglePracticeMode(bool p0) -> decltype(togglePracticeMode(p0)) {
	using FunctionType = decltype(togglePracticeMode(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xb81f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::optimizeColorGroups() -> decltype(optimizeColorGroups()) {
	using FunctionType = decltype(optimizeColorGroups())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xa7f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::resetLevelFromStart() -> decltype(resetLevelFromStart()) {
	using FunctionType = decltype(resetLevelFromStart())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb8330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::optimizeOpacityGroups() -> decltype(optimizeOpacityGroups()) {
	using FunctionType = decltype(optimizeOpacityGroups())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xa8130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::playEndAnimationToPos(cocos2d::CCPoint p0) -> decltype(playEndAnimationToPos(p0)) {
	using FunctionType = decltype(playEndAnimationToPos(p0))(*)(PlayLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0xaffb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::scanActiveSaveObjects() -> decltype(scanActiveSaveObjects()) {
	using FunctionType = decltype(scanActiveSaveObjects())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xa91b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::updateEffectPositions() -> decltype(updateEffectPositions()) {
	using FunctionType = decltype(updateEffectPositions())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb4d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::loadDynamicSaveObjects(gd::vector<SavedObjectStateRef>& p0) -> decltype(loadDynamicSaveObjects(p0)) {
	using FunctionType = decltype(loadDynamicSaveObjects(p0))(*)(PlayLayer*, gd::vector<SavedObjectStateRef>&);
	static auto func = wrapFunction(base::get() + 0xb7ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::scanDynamicSaveObjects() -> decltype(scanDynamicSaveObjects()) {
	using FunctionType = decltype(scanDynamicSaveObjects())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xa8320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::processLoadedMoveActions() -> decltype(processLoadedMoveActions()) {
	using FunctionType = decltype(processLoadedMoveActions())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb0ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::processCreateObjectsFromSetup() -> decltype(processCreateObjectsFromSetup()) {
	using FunctionType = decltype(processCreateObjectsFromSetup())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xa69f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::createObjectsFromSetupFinished() -> decltype(createObjectsFromSetupFinished()) {
	using FunctionType = decltype(createObjectsFromSetupFinished())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb0a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::playPlatformerEndAnimationToPos(cocos2d::CCPoint p0, bool p1) -> decltype(playPlatformerEndAnimationToPos(p0, p1)) {
	using FunctionType = decltype(playPlatformerEndAnimationToPos(p0, p1))(*)(PlayLayer*, cocos2d::CCPoint, bool);
	static auto func = wrapFunction(base::get() + 0xb0570, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayLayer::scene(GJGameLevel* p0, bool p1, bool p2) -> decltype(scene(p0, p1, p2)) {
	using FunctionType = decltype(scene(p0, p1, p2))(*)(PlayLayer*, GJGameLevel*, bool, bool);
	static auto func = wrapFunction(base::get() + 0xa5c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto PlayLayer::resume() -> decltype(resume()) {
	using FunctionType = decltype(resume())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb8a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::showHint() -> decltype(showHint()) {
	using FunctionType = decltype(showHint())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb4ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::addCircle(CCCircleWave* cw) -> decltype(addCircle(cw)) {
	using FunctionType = decltype(addCircle(cw))(*)(PlayLayer*, CCCircleWave*);
	static auto func = wrapFunction(base::get() + 0xb4cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, cw);
}

auto PlayLayer::addObject(GameObject* p0) -> decltype(addObject(p0)) {
	using FunctionType = decltype(addObject(p0))(*)(PlayLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xabae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::fullReset() -> decltype(fullReset()) {
	using FunctionType = decltype(fullReset())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb8080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::pauseGame(bool p0) -> decltype(pauseGame(p0)) {
	using FunctionType = decltype(pauseGame(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xb8790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayLayer::startGame() -> decltype(startGame()) {
	using FunctionType = decltype(startGame())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xad330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	throw std::runtime_error("PlayLayer::onEnterTransitionDidFinish not implemented");
}

auto PlayLayer::onExit() -> decltype(onExit()) {
	throw std::runtime_error("PlayLayer::onExit not implemented");
}

auto PlayLayer::postUpdate(float p0) -> decltype(postUpdate(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::postUpdate), this);
	using FunctionType = decltype(postUpdate(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0xb4df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::checkForEnd() -> decltype(checkForEnd()) {
	throw std::runtime_error("PlayLayer::checkForEnd not implemented");
}

auto PlayLayer::testTime() -> decltype(testTime()) {
	throw std::runtime_error("PlayLayer::testTime not implemented");
}

auto PlayLayer::updateVerifyDamage() -> decltype(updateVerifyDamage()) {
	throw std::runtime_error("PlayLayer::updateVerifyDamage not implemented");
}

auto PlayLayer::updateAttemptTime(float p0) -> decltype(updateAttemptTime(p0)) {
	throw std::runtime_error("PlayLayer::updateAttemptTime not implemented");
}

auto PlayLayer::updateVisibility(float p0) -> decltype(updateVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayLayer::updateVisibility), this);
	using FunctionType = decltype(updateVisibility(p0))(*)(PlayLayer*, float);
	static auto func = wrapFunction(base::get() + 0xb10e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::opacityForObject(GameObject* p0) -> decltype(opacityForObject(p0)) {
	throw std::runtime_error("PlayLayer::opacityForObject not implemented");
}

auto PlayLayer::updateColor(cocos2d::_ccColor3B& p0, float p1, int p2, bool p3, float p4, cocos2d::_ccHSVValue& p5, int p6, bool p7, EffectGameObject* p8, int p9, int p10) -> decltype(updateColor(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)) {
	throw std::runtime_error("PlayLayer::updateColor not implemented");
}

auto PlayLayer::activateEndTrigger(int p0, bool p1, bool p2) -> decltype(activateEndTrigger(p0, p1, p2)) {
	throw std::runtime_error("PlayLayer::activateEndTrigger not implemented");
}

auto PlayLayer::activatePlatformerEndTrigger(EndTriggerGameObject* p0, gd::vector<int> const& p1) -> decltype(activatePlatformerEndTrigger(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<EndTriggerGameObject*, gd::vector<int> const&>::func(&PlayLayer::activatePlatformerEndTrigger), this);
	using FunctionType = decltype(activatePlatformerEndTrigger(p0, p1))(*)(PlayLayer*, EndTriggerGameObject*, gd::vector<int> const&);
	static auto func = wrapFunction(base::get() + 0xb0480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlayLayer::toggleGlitter(bool p0) -> decltype(toggleGlitter(p0)) {
	throw std::runtime_error("PlayLayer::toggleGlitter not implemented");
}

auto PlayLayer::destroyPlayer(PlayerObject* p0, GameObject* p1) -> decltype(destroyPlayer(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<PlayerObject*, GameObject*>::func(&PlayLayer::destroyPlayer), this);
	using FunctionType = decltype(destroyPlayer(p0, p1))(*)(PlayLayer*, PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xb40f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlayLayer::toggleGroundVisibility(bool p0) -> decltype(toggleGroundVisibility(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayLayer::toggleGroundVisibility), this);
	using FunctionType = decltype(toggleGroundVisibility(p0))(*)(PlayLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xb3f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayLayer::toggleMGVisibility(bool p0) -> decltype(toggleMGVisibility(p0)) {
	throw std::runtime_error("PlayLayer::toggleMGVisibility not implemented");
}

auto PlayLayer::toggleHideAttempts(bool p0) -> decltype(toggleHideAttempts(p0)) {
	throw std::runtime_error("PlayLayer::toggleHideAttempts not implemented");
}

auto PlayLayer::timeForPos(cocos2d::CCPoint p0, int p1, int p2, bool p3, int p4) -> decltype(timeForPos(p0, p1, p2, p3, p4)) {
	throw std::runtime_error("PlayLayer::timeForPos not implemented");
}

auto PlayLayer::posForTime(float p0) -> decltype(posForTime(p0)) {
	throw std::runtime_error("PlayLayer::posForTime not implemented");
}

auto PlayLayer::resetSPTriggered() -> decltype(resetSPTriggered()) {
	throw std::runtime_error("PlayLayer::resetSPTriggered not implemented");
}

auto PlayLayer::updateTimeWarp(float p0) -> decltype(updateTimeWarp(p0)) {
	throw std::runtime_error("PlayLayer::updateTimeWarp not implemented");
}

auto PlayLayer::playGravityEffect(bool p0) -> decltype(playGravityEffect(p0)) {
	throw std::runtime_error("PlayLayer::playGravityEffect not implemented");
}

auto PlayLayer::manualUpdateObjectColors(GameObject* p0) -> decltype(manualUpdateObjectColors(p0)) {
	throw std::runtime_error("PlayLayer::manualUpdateObjectColors not implemented");
}

auto PlayLayer::checkpointActivated(CheckpointGameObject* p0) -> decltype(checkpointActivated(p0)) {
	throw std::runtime_error("PlayLayer::checkpointActivated not implemented");
}

auto PlayLayer::flipArt(bool p0) -> decltype(flipArt(p0)) {
	throw std::runtime_error("PlayLayer::flipArt not implemented");
}

auto PlayLayer::updateTimeLabel(int p0, int p1, bool p2) -> decltype(updateTimeLabel(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<int, int, bool>::func(&PlayLayer::updateTimeLabel), this);
	using FunctionType = decltype(updateTimeLabel(p0, p1, p2))(*)(PlayLayer*, int, int, bool);
	static auto func = wrapFunction(base::get() + 0xb39e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto PlayLayer::checkSnapshot() -> decltype(checkSnapshot()) {
	throw std::runtime_error("PlayLayer::checkSnapshot not implemented");
}

auto PlayLayer::toggleProgressbar() -> decltype(toggleProgressbar()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayLayer::toggleProgressbar), this);
	using FunctionType = decltype(toggleProgressbar())(*)(PlayLayer*);
	static auto func = wrapFunction(base::get() + 0xb3bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayLayer::toggleInfoLabel() -> decltype(toggleInfoLabel()) {
	throw std::runtime_error("PlayLayer::toggleInfoLabel not implemented");
}

auto PlayLayer::removeAllCheckpoints() -> decltype(removeAllCheckpoints()) {
	throw std::runtime_error("PlayLayer::removeAllCheckpoints not implemented");
}

auto PlayLayer::toggleMusicInPractice() -> decltype(toggleMusicInPractice()) {
	throw std::runtime_error("PlayLayer::toggleMusicInPractice not implemented");
}

auto PlayLayer::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	throw std::runtime_error("PlayLayer::currencyWillExit not implemented");
}

auto PlayLayer::circleWaveWillBeRemoved(CCCircleWave* p0) -> decltype(circleWaveWillBeRemoved(p0)) {
	throw std::runtime_error("PlayLayer::circleWaveWillBeRemoved not implemented");
}

auto PlayLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	throw std::runtime_error("PlayLayer::dialogClosed not implemented");
}

auto AnimatedSpriteDelegate::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	throw std::runtime_error("AnimatedSpriteDelegate::animationFinished not implemented");
}

auto PlayerObject::create(int p0, int p1, GJBaseGameLayer* p2, cocos2d::CCLayer* p3, bool p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(int, int, GJBaseGameLayer*, cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3dbca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto PlayerObject::init(int p0, int p1, GJBaseGameLayer* p2, cocos2d::CCLayer* p3, bool p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(PlayerObject*, int, int, GJBaseGameLayer*, cocos2d::CCLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3dbd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto PlayerObject::getYVelocity() -> decltype(getYVelocity()) {
	using FunctionType = decltype(getYVelocity())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3de3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::getActiveMode() -> decltype(getActiveMode()) {
	using FunctionType = decltype(getActiveMode())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f6cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::setSecondColor(cocos2d::_ccColor3B const& p0) -> decltype(setSecondColor(p0)) {
	using FunctionType = decltype(setSecondColor(p0))(*)(PlayerObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x3df590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::bumpPlayer(float p0, int p1, bool p2, GameObject* p3) -> decltype(bumpPlayer(p0, p1, p2, p3)) {
	using FunctionType = decltype(bumpPlayer(p0, p1, p2, p3))(*)(PlayerObject*, float, int, bool, GameObject*);
	static auto func = wrapFunction(base::get() + 0x3fb4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::isSafeFlip(float p0) -> decltype(isSafeFlip(p0)) {
	using FunctionType = decltype(isSafeFlip(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3ece70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::pushButton(PlayerButton p0) -> decltype(pushButton(p0)) {
	using FunctionType = decltype(pushButton(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x3f4bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateJump(float p0) -> decltype(updateJump(p0)) {
	using FunctionType = decltype(updateJump(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3df600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::boostPlayer(float p0) -> decltype(boostPlayer(p0)) {
	using FunctionType = decltype(boostPlayer(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3e75b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::createRobot(int p0) -> decltype(createRobot(p0)) {
	using FunctionType = decltype(createRobot(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3dd580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::flashPlayer(float p0, float p1, cocos2d::_ccColor3B p2, cocos2d::_ccColor3B p3) -> decltype(flashPlayer(p0, p1, p2, p3)) {
	using FunctionType = decltype(flashPlayer(p0, p1, p2, p3))(*)(PlayerObject*, float, float, cocos2d::_ccColor3B, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x3efee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::flipGravity(bool p0, bool p1) -> decltype(flipGravity(p0, p1)) {
	using FunctionType = decltype(flipGravity(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3e4a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::resetStreak() -> decltype(resetStreak()) {
	using FunctionType = decltype(resetStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e4520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::setupStreak() -> decltype(setupStreak()) {
	using FunctionType = decltype(setupStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3ddd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::stopDashing() -> decltype(stopDashing()) {
	using FunctionType = decltype(stopDashing())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e2cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::createSpider(int p0) -> decltype(createSpider(p0)) {
	using FunctionType = decltype(createSpider(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3dd8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::preCollision() -> decltype(preCollision()) {
	using FunctionType = decltype(preCollision())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e5890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::startDashing(DashRingObject* p0) -> decltype(startDashing(p0)) {
	using FunctionType = decltype(startDashing(p0))(*)(PlayerObject*, DashRingObject*);
	static auto func = wrapFunction(base::get() + 0x3f2380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::levelWillFlip() -> decltype(levelWillFlip()) {
	using FunctionType = decltype(levelWillFlip())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e4780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::modeDidChange() -> decltype(modeDidChange()) {
	using FunctionType = decltype(modeDidChange())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f77e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::postCollision(float p0) -> decltype(postCollision(p0)) {
	using FunctionType = decltype(postCollision(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3e5a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::propellPlayer(float p0, bool p1, int p2) -> decltype(propellPlayer(p0, p1, p2)) {
	using FunctionType = decltype(propellPlayer(p0, p1, p2))(*)(PlayerObject*, float, bool, int);
	static auto func = wrapFunction(base::get() + 0x3fb7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto PlayerObject::releaseButton(PlayerButton p0) -> decltype(releaseButton(p0)) {
	using FunctionType = decltype(releaseButton(p0))(*)(PlayerObject*, PlayerButton);
	static auto func = wrapFunction(base::get() + 0x3f5e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::reversePlayer(EffectGameObject* p0) -> decltype(reversePlayer(p0)) {
	using FunctionType = decltype(reversePlayer(p0))(*)(PlayerObject*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x3f6390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::toggleFlyMode(bool p0, bool p1) -> decltype(toggleFlyMode(p0, p1)) {
	using FunctionType = decltype(toggleFlyMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3f6d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::touchedObject(GameObject* p0) -> decltype(touchedObject(p0)) {
	using FunctionType = decltype(touchedObject(p0))(*)(PlayerObject*, GameObject*);
	static auto func = wrapFunction(base::get() + 0x3fcd70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateCollide(PlayerCollisionDirection p0, GameObject* p1) -> decltype(updateCollide(p0, p1)) {
	using FunctionType = decltype(updateCollide(p0, p1))(*)(PlayerObject*, PlayerCollisionDirection, GameObject*);
	static auto func = wrapFunction(base::get() + 0x3ed5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::updateDashArt() -> decltype(updateDashArt()) {
	using FunctionType = decltype(updateDashArt())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f1e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updateEffects(float p0) -> decltype(updateEffects(p0)) {
	using FunctionType = decltype(updateEffects(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3e3f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateTimeMod(float p0, bool p1) -> decltype(updateTimeMod(p0, p1)) {
	using FunctionType = decltype(updateTimeMod(p0, p1))(*)(PlayerObject*, float, bool);
	static auto func = wrapFunction(base::get() + 0x3ddb80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::activateStreak() -> decltype(activateStreak()) {
	using FunctionType = decltype(activateStreak())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e4610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::incrementJumps() -> decltype(incrementJumps()) {
	using FunctionType = decltype(incrementJumps())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e4a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::switchedToMode(GameObjectType p0) -> decltype(switchedToMode(p0)) {
	using FunctionType = decltype(switchedToMode(p0))(*)(PlayerObject*, GameObjectType);
	static auto func = wrapFunction(base::get() + 0x3f3880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::toggleBirdMode(bool p0, bool p1) -> decltype(toggleBirdMode(p0, p1)) {
	using FunctionType = decltype(toggleBirdMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3f7800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleDartMode(bool p0, bool p1) -> decltype(toggleDartMode(p0, p1)) {
	using FunctionType = decltype(toggleDartMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3f88a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleRollMode(bool p0, bool p1) -> decltype(toggleRollMode(p0, p1)) {
	using FunctionType = decltype(toggleRollMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3f8f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::doReversePlayer(bool p0) -> decltype(doReversePlayer(p0)) {
	using FunctionType = decltype(doReversePlayer(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3e3760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::playDeathEffect() -> decltype(playDeathEffect()) {
	using FunctionType = decltype(playDeathEffect())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x1ead80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playerDestroyed(bool p0) -> decltype(playerDestroyed(p0)) {
	using FunctionType = decltype(playerDestroyed(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3f4690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::resetPlayerIcon() -> decltype(resetPlayerIcon()) {
	using FunctionType = decltype(resetPlayerIcon())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f75e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::toggleRobotMode(bool p0, bool p1) -> decltype(toggleRobotMode(p0, p1)) {
	using FunctionType = decltype(toggleRobotMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3f9320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleSwingMode(bool p0, bool p1) -> decltype(toggleSwingMode(p0, p1)) {
	using FunctionType = decltype(toggleSwingMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3f7ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::updateGlowColor() -> decltype(updateGlowColor()) {
	using FunctionType = decltype(updateGlowColor())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3fa940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerArt() -> decltype(updatePlayerArt()) {
	using FunctionType = decltype(updatePlayerArt())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f66e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::deactivateStreak(bool p0) -> decltype(deactivateStreak(p0)) {
	using FunctionType = decltype(deactivateStreak(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3de280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::placeStreakPoint() -> decltype(placeStreakPoint()) {
	using FunctionType = decltype(placeStreakPoint())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e46f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::spawnScaleCircle() -> decltype(spawnScaleCircle()) {
	using FunctionType = decltype(spawnScaleCircle())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f4400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::toggleSpiderMode(bool p0, bool p1) -> decltype(toggleSpiderMode(p0, p1)) {
	using FunctionType = decltype(toggleSpiderMode(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3f9760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::updatePlayerGlow() -> decltype(updatePlayerGlow()) {
	using FunctionType = decltype(updatePlayerGlow())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f6550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::collidedWithSlope(float p0, GameObject* p1, bool p2) -> decltype(collidedWithSlope(p0, p1, p2)) {
	using FunctionType = decltype(collidedWithSlope(p0, p1, p2))(*)(PlayerObject*, float, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3e78f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto PlayerObject::releaseAllButtons() -> decltype(releaseAllButtons()) {
	using FunctionType = decltype(releaseAllButtons())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3fb040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::resetAllParticles() -> decltype(resetAllParticles()) {
	using FunctionType = decltype(resetAllParticles())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e44b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::spawnPortalCircle(cocos2d::_ccColor3B p0, float p1) -> decltype(spawnPortalCircle(p0, p1)) {
	using FunctionType = decltype(spawnPortalCircle(p0, p1))(*)(PlayerObject*, cocos2d::_ccColor3B, float);
	static auto func = wrapFunction(base::get() + 0x3f42d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::toggleGhostEffect(GhostType p0) -> decltype(toggleGhostEffect(p0)) {
	using FunctionType = decltype(toggleGhostEffect(p0))(*)(PlayerObject*, GhostType);
	static auto func = wrapFunction(base::get() + 0x3f3e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::togglePlayerScale(bool p0, bool p1) -> decltype(togglePlayerScale(p0, p1)) {
	using FunctionType = decltype(togglePlayerScale(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x3f39d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::updatePlayerFrame(int p0) -> decltype(updatePlayerFrame(p0)) {
	using FunctionType = decltype(updatePlayerFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3f85c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateStreakBlend(bool p0) -> decltype(updateStreakBlend(p0)) {
	using FunctionType = decltype(updateStreakBlend(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3de350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::collidedWithObject(float p0, GameObject* p1) -> decltype(collidedWithObject(p0, p1)) {
	using FunctionType = decltype(collidedWithObject(p0, p1))(*)(PlayerObject*, float, GameObject*);
	static auto func = wrapFunction(base::get() + 0x3ee020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::collidedWithObject(float p0, GameObject* p1, cocos2d::CCRect p2, bool p3) -> decltype(collidedWithObject(p0, p1, p2, p3)) {
	using FunctionType = decltype(collidedWithObject(p0, p1, p2, p3))(*)(PlayerObject*, float, GameObject*, cocos2d::CCRect, bool);
	static auto func = wrapFunction(base::get() + 0x3e7850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto PlayerObject::deactivateParticle() -> decltype(deactivateParticle()) {
	using FunctionType = decltype(deactivateParticle())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e2a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::loadFromCheckpoint(PlayerCheckpoint* p0) -> decltype(loadFromCheckpoint(p0)) {
	using FunctionType = decltype(loadFromCheckpoint(p0))(*)(PlayerObject*, PlayerCheckpoint*);
	static auto func = wrapFunction(base::get() + 0x3fc940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::playCompleteEffect(bool p0, bool p1) -> decltype(playCompleteEffect(p0, p1)) {
	using FunctionType = decltype(playCompleteEffect(p0, p1))(*)(PlayerObject*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x1f2ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::rotateGameplayOnly(bool p0) -> decltype(rotateGameplayOnly(p0)) {
	using FunctionType = decltype(rotateGameplayOnly(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3f6a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::tryPlaceCheckpoint() -> decltype(tryPlaceCheckpoint()) {
	using FunctionType = decltype(tryPlaceCheckpoint())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e4080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playDynamicSpiderRun() -> decltype(playDynamicSpiderRun()) {
	using FunctionType = decltype(playDynamicSpiderRun())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e3400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::playSpiderDashEffect(cocos2d::CCPoint from, cocos2d::CCPoint to) -> decltype(playSpiderDashEffect(from, to)) {
	using FunctionType = decltype(playSpiderDashEffect(from, to))(*)(PlayerObject*, cocos2d::CCPoint, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x3ef720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, from, to);
}

auto PlayerObject::togglePlatformerMode(bool p0) -> decltype(togglePlatformerMode(p0)) {
	using FunctionType = decltype(togglePlatformerMode(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3de0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::animatePlatformerJump(float p0) -> decltype(animatePlatformerJump(p0)) {
	using FunctionType = decltype(animatePlatformerJump(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3e4e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::enableCustomGlowColor(cocos2d::_ccColor3B const& p0) -> decltype(enableCustomGlowColor(p0)) {
	using FunctionType = decltype(enableCustomGlowColor(p0))(*)(PlayerObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x3fa900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerBirdFrame(int p0) -> decltype(updatePlayerBirdFrame(p0)) {
	using FunctionType = decltype(updatePlayerBirdFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3f7c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerDartFrame(int p0) -> decltype(updatePlayerDartFrame(p0)) {
	using FunctionType = decltype(updatePlayerDartFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3f8d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerRollFrame(int p0) -> decltype(updatePlayerRollFrame(p0)) {
	using FunctionType = decltype(updatePlayerRollFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3f90f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerShipFrame(int p0) -> decltype(updatePlayerShipFrame(p0)) {
	using FunctionType = decltype(updatePlayerShipFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3f7180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateShipSpriteExtra(gd::string p0) -> decltype(updateShipSpriteExtra(p0)) {
	using FunctionType = decltype(updateShipSpriteExtra(p0))(*)(PlayerObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x3dd4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void PlayerObject::disableCustomGlowColor() {
		m_hasCustomGlowColor = false;
	}

auto PlayerObject::removePlacedCheckpoint() -> decltype(removePlacedCheckpoint()) {
	using FunctionType = decltype(removePlacedCheckpoint())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f4650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerRobotFrame(int p0) -> decltype(updatePlayerRobotFrame(p0)) {
	using FunctionType = decltype(updatePlayerRobotFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3fb000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerSwingFrame(int p0) -> decltype(updatePlayerSwingFrame(p0)) {
	using FunctionType = decltype(updatePlayerSwingFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3f8300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::removePendingCheckpoint() -> decltype(removePendingCheckpoint()) {
	using FunctionType = decltype(removePendingCheckpoint())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f3830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::updatePlayerSpiderFrame(int p0) -> decltype(updatePlayerSpiderFrame(p0)) {
	using FunctionType = decltype(updatePlayerSpiderFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3fb020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updatePlayerJetpackFrame(int p0) -> decltype(updatePlayerJetpackFrame(p0)) {
	using FunctionType = decltype(updatePlayerJetpackFrame(p0))(*)(PlayerObject*, int);
	static auto func = wrapFunction(base::get() + 0x3f73b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PlayerObject::updateRobotAnimationSpeed() -> decltype(updateRobotAnimationSpeed()) {
	using FunctionType = decltype(updateRobotAnimationSpeed())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3fc360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::stopPlatformerJumpAnimation() -> decltype(stopPlatformerJumpAnimation()) {
	using FunctionType = decltype(stopPlatformerJumpAnimation())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e5350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::isFlying() -> decltype(isFlying()) {
	using FunctionType = decltype(isFlying())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3e29d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerObject::hitGround(GameObject* p0, bool p1) -> decltype(hitGround(p0, p1)) {
	using FunctionType = decltype(hitGround(p0, p1))(*)(PlayerObject*, GameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3eceb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto PlayerObject::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::update), this);
	using FunctionType = decltype(update(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3de460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3fd070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3fd080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3fd090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&PlayerObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(PlayerObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x3f9c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3fd0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setRotation(float p0) -> decltype(setRotation(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&PlayerObject::setRotation), this);
	using FunctionType = decltype(setRotation(p0))(*)(PlayerObject*, float);
	static auto func = wrapFunction(base::get() + 0x3fcfe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&PlayerObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(PlayerObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x3fae00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&PlayerObject::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(PlayerObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x3fa7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setFlipX(bool p0) -> decltype(setFlipX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setFlipX), this);
	using FunctionType = decltype(setFlipX(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3fcff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::setFlipY(bool p0) -> decltype(setFlipY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&PlayerObject::setFlipY), this);
	using FunctionType = decltype(setFlipY(p0))(*)(PlayerObject*, bool);
	static auto func = wrapFunction(base::get() + 0x3fd060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PlayerObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3f2e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::getRealPosition() -> decltype(getRealPosition()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::getRealPosition), this);
	using FunctionType = decltype(getRealPosition())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3fafd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::getOrientedBox() -> decltype(getOrientedBox()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::getOrientedBox), this);
	using FunctionType = decltype(getOrientedBox())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3fc2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::getObjectRotation() -> decltype(getObjectRotation()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerObject::getObjectRotation), this);
	using FunctionType = decltype(getObjectRotation())(*)(PlayerObject*);
	static auto func = wrapFunction(base::get() + 0x3fc300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerObject::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&PlayerObject::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(PlayerObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x3fd190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CheckpointGameObject::triggerObject(GJBaseGameLayer* p0, int p1, gd::vector<int> const* p2) -> decltype(triggerObject(p0, p1, p2)) {
	using FunctionType = decltype(triggerObject(p0, p1, p2))(*)(CheckpointGameObject*, GJBaseGameLayer*, int, gd::vector<int> const*);
	static auto func = wrapFunction(base::get() + 0x1b89c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CheckpointGameObject::customObjectSetup(gd::vector<gd::string>& p0, gd::vector<void*>& p1) -> decltype(customObjectSetup(p0, p1)) {
	using FunctionType = decltype(customObjectSetup(p0, p1))(*)(CheckpointGameObject*, gd::vector<gd::string>&, gd::vector<void*>&);
	static auto func = wrapFunction(base::get() + 0x1ba120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CheckpointGameObject::setupCustomSprites(gd::string p0) -> decltype(setupCustomSprites(p0)) {
	using FunctionType = decltype(setupCustomSprites(p0))(*)(CheckpointGameObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1b8db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CheckpointGameObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointGameObject::init), this);
	using FunctionType = decltype(init())(*)(CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x1b8960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CheckpointGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ba260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CheckpointGameObject::getSaveString(GJBaseGameLayer* p0) -> decltype(getSaveString(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJBaseGameLayer*>::func(&CheckpointGameObject::getSaveString), this);
	using FunctionType = decltype(getSaveString(p0))(*)(CheckpointGameObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x1b97a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CheckpointGameObject::triggerActivated(float p0) -> decltype(triggerActivated(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CheckpointGameObject::triggerActivated), this);
	using FunctionType = decltype(triggerActivated(p0))(*)(CheckpointGameObject*, float);
	static auto func = wrapFunction(base::get() + 0x1b89e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CheckpointGameObject::restoreObject() -> decltype(restoreObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointGameObject::restoreObject), this);
	using FunctionType = decltype(restoreObject())(*)(CheckpointGameObject*);
	static auto func = wrapFunction(base::get() + 0x1ba2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CheckpointGameObject::updateSyncedAnimation(float p0, int p1) -> decltype(updateSyncedAnimation(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, int>::func(&CheckpointGameObject::updateSyncedAnimation), this);
	using FunctionType = decltype(updateSyncedAnimation(p0, p1))(*)(CheckpointGameObject*, float, int);
	static auto func = wrapFunction(base::get() + 0x1b9390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SongInfoObject::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x55fb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SongInfoObject::create(int p0, gd::string p1, gd::string p2, int p3, float p4, gd::string p5, gd::string p6, gd::string p7, int p8) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(int, gd::string, gd::string, int, float, gd::string, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x55d1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto SongInfoObject::create(cocos2d::CCDictionary* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x557250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SongInfoObject::init(int p0, gd::string p1, gd::string p2, int p3, float p4, gd::string p5, gd::string p6, gd::string p7, int p8) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(SongInfoObject*, int, gd::string, gd::string, int, float, gd::string, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x55fe20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto SongInfoObject::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(SongInfoObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x560020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongInfoObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&SongInfoObject::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(SongInfoObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x560500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongInfoObject::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongInfoObject::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x560650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerCheckpoint::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerCheckpoint::init), this);
	using FunctionType = decltype(init())(*)(PlayerCheckpoint*);
	static auto func = wrapFunction(base::get() + 0xb8d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CheckpointObject::getObject() -> decltype(getObject()) {
	using FunctionType = decltype(getObject())(*)(CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0xb5170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CheckpointObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CheckpointObject::init), this);
	using FunctionType = decltype(init())(*)(CheckpointObject*);
	static auto func = wrapFunction(base::get() + 0xb8ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::decrementForcePrio() -> decltype(decrementForcePrio()) {
	using FunctionType = decltype(decrementForcePrio())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CCBlockLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::init), this);
	using FunctionType = decltype(init())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f05e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::draw), this);
	using FunctionType = decltype(draw())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCBlockLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CCBlockLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4f08c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCBlockLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCBlockLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CCBlockLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4f0920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCBlockLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCBlockLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CCBlockLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4f08e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCBlockLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CCBlockLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CCBlockLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4f0900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCBlockLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f06f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::enterLayer() -> decltype(enterLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::enterLayer), this);
	using FunctionType = decltype(enterLayer())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::exitLayer() -> decltype(exitLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::exitLayer), this);
	using FunctionType = decltype(exitLayer())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f07c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCBlockLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(CCBlockLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4f0800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCBlockLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCBlockLayer::hideLayer), this);
	using FunctionType = decltype(hideLayer(p0))(*)(CCBlockLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4f0810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCBlockLayer::layerVisible() -> decltype(layerVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::layerVisible), this);
	using FunctionType = decltype(layerVisible())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::enterAnimFinished), this);
	using FunctionType = decltype(enterAnimFinished())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::disableUI() -> decltype(disableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::disableUI), this);
	using FunctionType = decltype(disableUI())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCBlockLayer::enableUI() -> decltype(enableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCBlockLayer::enableUI), this);
	using FunctionType = decltype(enableUI())(*)(CCBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4f0710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorPauseLayer::create(LevelEditorLayer* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x26ee60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto EditorPauseLayer::init(LevelEditorLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EditorPauseLayer*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x26ef60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::onNewGroupX(cocos2d::CCObject* sender) -> decltype(onNewGroupX(sender)) {
	using FunctionType = decltype(onNewGroupX(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onNewGroupY(cocos2d::CCObject* sender) -> decltype(onNewGroupY(sender)) {
	using FunctionType = decltype(onNewGroupY(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSelectAll(cocos2d::CCObject* sender) -> decltype(onSelectAll(sender)) {
	using FunctionType = decltype(onSelectAll(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onCopyWColor(cocos2d::CCObject* sender) -> decltype(onCopyWColor(sender)) {
	using FunctionType = decltype(onCopyWColor(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onCreateLoop(cocos2d::CCObject* sender) -> decltype(onCreateLoop(sender)) {
	using FunctionType = decltype(onCreateLoop(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onExitNoSave(cocos2d::CCObject* sender) -> decltype(onExitNoSave(sender)) {
	using FunctionType = decltype(onExitNoSave(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onBuildHelper(cocos2d::CCObject* sender) -> decltype(onBuildHelper(sender)) {
	using FunctionType = decltype(onBuildHelper(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onPasteWColor(cocos2d::CCObject* sender) -> decltype(onPasteWColor(sender)) {
	using FunctionType = decltype(onPasteWColor(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSaveAndExit(cocos2d::CCObject* sender) -> decltype(onSaveAndExit(sender)) {
	using FunctionType = decltype(onSaveAndExit(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSaveAndPlay(cocos2d::CCObject* sender) -> decltype(onSaveAndPlay(sender)) {
	using FunctionType = decltype(onSaveAndPlay(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2716c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onCreateExtras(cocos2d::CCObject* sender) -> decltype(onCreateExtras(sender)) {
	using FunctionType = decltype(onCreateExtras(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSelectAllLeft(cocos2d::CCObject* sender) -> decltype(onSelectAllLeft(sender)) {
	using FunctionType = decltype(onSelectAllLeft(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSelectAllRight(cocos2d::CCObject* sender) -> decltype(onSelectAllRight(sender)) {
	using FunctionType = decltype(onSelectAllRight(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onUnlockAllLayers(cocos2d::CCObject* sender) -> decltype(onUnlockAllLayers(sender)) {
	using FunctionType = decltype(onUnlockAllLayers(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onResetUnusedColors(cocos2d::CCObject* sender) -> decltype(onResetUnusedColors(sender)) {
	using FunctionType = decltype(onResetUnusedColors(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onHelp(cocos2d::CCObject* sender) -> decltype(onHelp(sender)) {
	using FunctionType = decltype(onHelp(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSave(cocos2d::CCObject* sender) -> decltype(onSave(sender)) {
	using FunctionType = decltype(onSave(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2717a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onSong(cocos2d::CCObject* sender) -> decltype(onSong(sender)) {
	using FunctionType = decltype(onSong(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onAlignX(cocos2d::CCObject* sender) -> decltype(onAlignX(sender)) {
	using FunctionType = decltype(onAlignX(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onAlignY(cocos2d::CCObject* sender) -> decltype(onAlignY(sender)) {
	using FunctionType = decltype(onAlignY(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onResume(cocos2d::CCObject* sender) -> decltype(onResume(sender)) {
	using FunctionType = decltype(onResume(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onOptions(cocos2d::CCObject* sender) -> decltype(onOptions(sender)) {
	using FunctionType = decltype(onOptions(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x272090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::onReGroup(cocos2d::CCObject* sender) -> decltype(onReGroup(sender)) {
	using FunctionType = decltype(onReGroup(sender))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorPauseLayer::toggleDebugDraw(cocos2d::CCObject* p0) -> decltype(toggleDebugDraw(p0)) {
	using FunctionType = decltype(toggleDebugDraw(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x272050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::toggleEditorGrid(cocos2d::CCObject* p0) -> decltype(toggleEditorGrid(p0)) {
	using FunctionType = decltype(toggleEditorGrid(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::togglePreviewAnim(cocos2d::CCObject* p0) -> decltype(togglePreviewAnim(p0)) {
	using FunctionType = decltype(togglePreviewAnim(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::uncheckAllPortals(cocos2d::CCObject* p0) -> decltype(uncheckAllPortals(p0)) {
	using FunctionType = decltype(uncheckAllPortals(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::toggleEditorGround(cocos2d::CCObject* p0) -> decltype(toggleEditorGround(p0)) {
	using FunctionType = decltype(toggleEditorGround(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::toggleIgnoreDamage(cocos2d::CCObject* p0) -> decltype(toggleIgnoreDamage(p0)) {
	using FunctionType = decltype(toggleIgnoreDamage(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::toggleSelectFilter(cocos2d::CCObject* p0) -> decltype(toggleSelectFilter(p0)) {
	using FunctionType = decltype(toggleSelectFilter(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::toggleHideInvisible(cocos2d::CCObject* p0) -> decltype(toggleHideInvisible(p0)) {
	using FunctionType = decltype(toggleHideInvisible(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x272030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::togglePreviewShaders(cocos2d::CCObject* p0) -> decltype(togglePreviewShaders(p0)) {
	using FunctionType = decltype(togglePreviewShaders(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::toggleShowObjectInfo(cocos2d::CCObject* p0) -> decltype(toggleShowObjectInfo(p0)) {
	using FunctionType = decltype(toggleShowObjectInfo(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::toggleEditorColorMode(cocos2d::CCObject* p0) -> decltype(toggleEditorColorMode(p0)) {
	using FunctionType = decltype(toggleEditorColorMode(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x272000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::togglePreviewParticles(cocos2d::CCObject* p0) -> decltype(togglePreviewParticles(p0)) {
	using FunctionType = decltype(togglePreviewParticles(p0))(*)(EditorPauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x271fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditorPauseLayer::playStep2() -> decltype(playStep2()) {
	using FunctionType = decltype(playStep2())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0x272a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::playStep3() -> decltype(playStep3()) {
	using FunctionType = decltype(playStep3())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0x272b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::saveLevel() -> decltype(saveLevel()) {
	using FunctionType = decltype(saveLevel())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0x2725a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EditorPauseLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorPauseLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0x272ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorPauseLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditorPauseLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditorPauseLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x272d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorPauseLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorPauseLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EditorPauseLayer*);
	static auto func = wrapFunction(base::get() + 0x26f8c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorPauseLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditorPauseLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditorPauseLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x272bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PauseLayer::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x3b4400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto PauseLayer::onSettings(cocos2d::CCObject* sender) -> decltype(onSettings(sender)) {
	using FunctionType = decltype(onSettings(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onNormalMode(cocos2d::CCObject* sender) -> decltype(onNormalMode(sender)) {
	using FunctionType = decltype(onNormalMode(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onRestartFull(cocos2d::CCObject* sender) -> decltype(onRestartFull(sender)) {
	using FunctionType = decltype(onRestartFull(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onPracticeMode(cocos2d::CCObject* sender) -> decltype(onPracticeMode(sender)) {
	using FunctionType = decltype(onPracticeMode(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onEdit(cocos2d::CCObject* sender) -> decltype(onEdit(sender)) {
	using FunctionType = decltype(onEdit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onQuit(cocos2d::CCObject* sender) -> decltype(onQuit(sender)) {
	using FunctionType = decltype(onQuit(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onResume(cocos2d::CCObject* sender) -> decltype(onResume(sender)) {
	using FunctionType = decltype(onResume(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::onRestart(cocos2d::CCObject* sender) -> decltype(onRestart(sender)) {
	using FunctionType = decltype(onRestart(sender))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto PauseLayer::sfxSliderChanged(cocos2d::CCObject* p0) -> decltype(sfxSliderChanged(p0)) {
	using FunctionType = decltype(sfxSliderChanged(p0))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PauseLayer::setupProgressBars() -> decltype(setupProgressBars()) {
	using FunctionType = decltype(setupProgressBars())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x3b4fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PauseLayer::musicSliderChanged(cocos2d::CCObject* p0) -> decltype(musicSliderChanged(p0)) {
	using FunctionType = decltype(musicSliderChanged(p0))(*)(PauseLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b5c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto PauseLayer::goEdit() -> decltype(goEdit()) {
	using FunctionType = decltype(goEdit())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x3b5fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PauseLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("PauseLayer::keyBackClicked not implemented");
}

auto PauseLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&PauseLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(PauseLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x3b6010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PauseLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PauseLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(PauseLayer*);
	static auto func = wrapFunction(base::get() + 0x3b4500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PauseLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	throw std::runtime_error("PauseLayer::keyUp not implemented");
}

void SetTextPopupDelegate::setTextPopupClosed(SetTextPopup* p0, gd::string p1) {}

auto ShareCommentDelegate::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	throw std::runtime_error("ShareCommentDelegate::shareCommentClosed not implemented");
}

auto LevelBrowserLayer::create(GJSearchObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x4675c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelBrowserLayer::init(GJSearchObject* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelBrowserLayer*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x467790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

LevelBrowserLayer::~LevelBrowserLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x467380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) LevelBrowserLayer(geode::CutoffConstructor, sizeof(LevelBrowserLayer));
	CCDestructor::lock(this) = true;
}

auto LevelBrowserLayer::getSearchTitle() -> decltype(getSearchTitle()) {
	using FunctionType = decltype(getSearchTitle())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x46c370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelBrowserLayer::onGoToPage(cocos2d::CCObject* sender) -> decltype(onGoToPage(sender)) {
	using FunctionType = decltype(onGoToPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4691f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4691b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onDeleteAll(cocos2d::CCObject* sender) -> decltype(onDeleteAll(sender)) {
	using FunctionType = decltype(onDeleteAll(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onFavorites(cocos2d::CCObject* sender) -> decltype(onFavorites(sender)) {
	using FunctionType = decltype(onFavorites(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onLocalMode(cocos2d::CCObject* sender) -> decltype(onLocalMode(sender)) {
	using FunctionType = decltype(onLocalMode(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onSavedMode(cocos2d::CCObject* sender) -> decltype(onSavedMode(sender)) {
	using FunctionType = decltype(onSavedMode(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onGoToFolder(cocos2d::CCObject* sender) -> decltype(onGoToFolder(sender)) {
	using FunctionType = decltype(onGoToFolder(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x46a500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onClearSearch(cocos2d::CCObject* sender) -> decltype(onClearSearch(sender)) {
	using FunctionType = decltype(onClearSearch(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x46a880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onGoToLastPage(cocos2d::CCObject* sender) -> decltype(onGoToLastPage(sender)) {
	using FunctionType = decltype(onGoToLastPage(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x46a5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onDeleteSelected(cocos2d::CCObject* sender) -> decltype(onDeleteSelected(sender)) {
	using FunctionType = decltype(onDeleteSelected(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onMyOnlineLevels(cocos2d::CCObject* sender) -> decltype(onMyOnlineLevels(sender)) {
	using FunctionType = decltype(onMyOnlineLevels(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onToggleAllObjects(cocos2d::CCObject* sender) -> decltype(onToggleAllObjects(sender)) {
	using FunctionType = decltype(onToggleAllObjects(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onRemoveAllFavorites(cocos2d::CCObject* sender) -> decltype(onRemoveAllFavorites(sender)) {
	using FunctionType = decltype(onRemoveAllFavorites(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onNew(cocos2d::CCObject* sender) -> decltype(onNew(sender)) {
	using FunctionType = decltype(onNew(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4697a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x46d2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x46a1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onSaved(cocos2d::CCObject* sender) -> decltype(onSaved(sender)) {
	using FunctionType = decltype(onSaved(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x469e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onSearch(cocos2d::CCObject* sender) -> decltype(onSearch(sender)) {
	using FunctionType = decltype(onSearch(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x46a5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::onRefresh(cocos2d::CCObject* sender) -> decltype(onRefresh(sender)) {
	using FunctionType = decltype(onRefresh(sender))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x46a090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelBrowserLayer::createNewList(cocos2d::CCObject* p0) -> decltype(createNewList(p0)) {
	using FunctionType = decltype(createNewList(p0))(*)(LevelBrowserLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x46d520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::updatePageLabel() -> decltype(updatePageLabel()) {
	using FunctionType = decltype(updatePageLabel())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x469230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelBrowserLayer::setupLevelBrowser(cocos2d::CCArray* p0) -> decltype(setupLevelBrowser(p0)) {
	using FunctionType = decltype(setupLevelBrowser(p0))(*)(LevelBrowserLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x46c070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

cocos2d::CCScene* LevelBrowserLayer::scene(GJSearchObject* search) {
        auto scene = cocos2d::CCScene::create();
        scene->addChild(LevelBrowserLayer::create(search));

        AppDelegate::get()->m_runningScene = scene;
        return scene;
    }

auto LevelBrowserLayer::loadPage(GJSearchObject* p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(LevelBrowserLayer*, GJSearchObject*);
	static auto func = wrapFunction(base::get() + 0x46a900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelBrowserLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x46de00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x46dfa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelBrowserLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(LevelBrowserLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x46e090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelBrowserLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(LevelBrowserLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x46e0f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelBrowserLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(LevelBrowserLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x46e0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelBrowserLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(LevelBrowserLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x46e0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x46dfb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelBrowserLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelBrowserLayer*);
	static auto func = wrapFunction(base::get() + 0x46d390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelBrowserLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&LevelBrowserLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(LevelBrowserLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x46d3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelBrowserLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&LevelBrowserLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(LevelBrowserLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x46ca00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelBrowserLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&LevelBrowserLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(LevelBrowserLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x46cb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, char const*>::func(&LevelBrowserLayer::setupPageInfo), this);
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(LevelBrowserLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x46cc40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<gd::string, ShareCommentLayer*>::func(&LevelBrowserLayer::shareCommentClosed), this);
	using FunctionType = decltype(shareCommentClosed(p0, p1))(*)(LevelBrowserLayer*, gd::string, ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x46d6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetTextPopup*, gd::string>::func(&LevelBrowserLayer::setTextPopupClosed), this);
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(LevelBrowserLayer*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x46d790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelBrowserLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelBrowserLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x46d9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelBrowserLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelBrowserLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x46d1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelBrowserLayer::updateResultArray(cocos2d::CCArray* p0) -> decltype(updateResultArray(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*>::func(&LevelBrowserLayer::updateResultArray), this);
	using FunctionType = decltype(updateResultArray(p0))(*)(LevelBrowserLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x46e110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelBrowserLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&LevelBrowserLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(LevelBrowserLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x46de80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto SetTextPopup::create(gd::string p0, gd::string p1, int p2, gd::string p3, gd::string p4, bool p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(gd::string, gd::string, int, gd::string, gd::string, bool, float);
	static auto func = wrapFunction(base::get() + 0x289fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto SetTextPopup::init(gd::string p0, gd::string p1, int p2, gd::string p3, gd::string p4, bool p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(SetTextPopup*, gd::string, gd::string, int, gd::string, gd::string, bool, float);
	static auto func = wrapFunction(base::get() + 0x28a750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto SetTextPopup::onResetValue(cocos2d::CCObject* sender) -> decltype(onResetValue(sender)) {
	using FunctionType = decltype(onResetValue(sender))(*)(SetTextPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28afa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetTextPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetTextPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28aee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetTextPopup::onCancel(cocos2d::CCObject* sender) -> decltype(onCancel(sender)) {
	using FunctionType = decltype(onCancel(sender))(*)(SetTextPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28b030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetTextPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetTextPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetTextPopup*);
	static auto func = wrapFunction(base::get() + 0x28b260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTextPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetTextPopup::show), this);
	using FunctionType = decltype(show())(*)(SetTextPopup*);
	static auto func = wrapFunction(base::get() + 0x28b200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTextPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetTextPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetTextPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x28b0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetTextPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetTextPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetTextPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x28b110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareCommentLayer::create(gd::string p0, int p1, CommentType p2, int p3, gd::string p4) -> decltype(create(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4))(*)(gd::string, int, CommentType, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x5a46f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4);
}

auto ShareCommentLayer::init(gd::string p0, int p1, CommentType p2, int p3, gd::string p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(ShareCommentLayer*, gd::string, int, CommentType, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x5a4950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto ShareCommentLayer::onClear(cocos2d::CCObject* sender) -> decltype(onClear(sender)) {
	using FunctionType = decltype(onClear(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5a5c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5a5cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5a5d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::onPercent(cocos2d::CCObject* sender) -> decltype(onPercent(sender)) {
	using FunctionType = decltype(onPercent(sender))(*)(ShareCommentLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5a5a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareCommentLayer::updateCharCountLabel() -> decltype(updateCharCountLabel()) {
	using FunctionType = decltype(updateCharCountLabel())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x5a63d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShareCommentLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareCommentLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x5a60d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShareCommentLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareCommentLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x5a6020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShareCommentLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ShareCommentLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(ShareCommentLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5a6270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareCommentLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ShareCommentLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(ShareCommentLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5a6110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareCommentLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ShareCommentLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ShareCommentLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5a6290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareCommentLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ShareCommentLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(ShareCommentLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x5a64e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ShareCommentLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&ShareCommentLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(ShareCommentLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x5a65e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ShareCommentLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&ShareCommentLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(ShareCommentLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x5a6700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GameObjectCopy::create(GameObject* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GameObject*);
	static auto func = wrapFunction(base::get() + 0xdf290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameObjectCopy::resetObject() -> decltype(resetObject()) {
	using FunctionType = decltype(resetObject())(*)(GameObjectCopy*);
	static auto func = wrapFunction(base::get() + 0xdf3a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UndoObject::create(GameObject* p0, UndoCommand p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GameObject*, UndoCommand);
	static auto func = wrapFunction(base::get() + 0xdbe40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto UndoObject::createWithArray(cocos2d::CCArray* p0, UndoCommand p1) -> decltype(createWithArray(p0, p1)) {
	using FunctionType = decltype(createWithArray(p0, p1))(*)(UndoObject*, cocos2d::CCArray*, UndoCommand);
	static auto func = wrapFunction(base::get() + 0xdea20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto EndLevelLayer::onEdit(cocos2d::CCObject* sender) -> decltype(onEdit(sender)) {
	using FunctionType = decltype(onEdit(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x49d3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::onMenu(cocos2d::CCObject* sender) -> decltype(onMenu(sender)) {
	using FunctionType = decltype(onMenu(sender))(*)(EndLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x49d2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EndLevelLayer::playEndEffect() -> decltype(playEndEffect()) {
	using FunctionType = decltype(playEndEffect())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x49e4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::playCoinEffect(float p0) -> decltype(playCoinEffect(p0)) {
	using FunctionType = decltype(playCoinEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0x49da20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::playStarEffect(float p0) -> decltype(playStarEffect(p0)) {
	using FunctionType = decltype(playStarEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0x49d6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::playDiamondEffect(float p0) -> decltype(playDiamondEffect(p0)) {
	using FunctionType = decltype(playDiamondEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0x49df20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::starEnterFinished() -> decltype(starEnterFinished()) {
	using FunctionType = decltype(starEnterFinished())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x49e390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto EndLevelLayer::playCurrencyEffect(float p0) -> decltype(playCurrencyEffect(p0)) {
	using FunctionType = decltype(playCurrencyEffect(p0))(*)(EndLevelLayer*, float);
	static auto func = wrapFunction(base::get() + 0x49dbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x49e360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EndLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EndLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x49eb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndLevelLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndLevelLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x49b580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndLevelLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EndLevelLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(EndLevelLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x49d530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndLevelLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndLevelLayer::enterAnimFinished), this);
	using FunctionType = decltype(enterAnimFinished())(*)(EndLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x49e280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndLevelLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EndLevelLayer::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(EndLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x49eba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDailyLevelDelegate::dailyStatusFinished(GJTimedLevelType p0) -> decltype(dailyStatusFinished(p0)) {
	throw std::runtime_error("GJDailyLevelDelegate::dailyStatusFinished not implemented");
}

auto GJDailyLevelDelegate::dailyStatusFailed(GJTimedLevelType p0, GJErrorCode p1) -> decltype(dailyStatusFailed(p0, p1)) {
	throw std::runtime_error("GJDailyLevelDelegate::dailyStatusFailed not implemented");
}

auto DailyLevelPage::create(GJTimedLevelType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x20f540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto DailyLevelPage::init(GJTimedLevelType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(DailyLevelPage*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x20f6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DailyLevelPage::getDailyTimeString(int p0) -> decltype(getDailyTimeString(p0)) {
	using FunctionType = decltype(getDailyTimeString(p0))(*)(DailyLevelPage*, int);
	static auto func = wrapFunction(base::get() + 0x2103a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DailyLevelPage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(DailyLevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x210300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DailyLevelPage::onTheSafe(cocos2d::CCObject* sender) -> decltype(onTheSafe(sender)) {
	using FunctionType = decltype(onTheSafe(sender))(*)(DailyLevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x210340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DailyLevelPage::updateTimers(float p0) -> decltype(updateTimers(p0)) {
	using FunctionType = decltype(updateTimers(p0))(*)(DailyLevelPage*, float);
	static auto func = wrapFunction(base::get() + 0x210720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DailyLevelPage::createDailyNode(GJGameLevel* p0, bool p1, float p2, bool p3) -> decltype(createDailyNode(p0, p1, p2, p3)) {
	using FunctionType = decltype(createDailyNode(p0, p1, p2, p3))(*)(DailyLevelPage*, GJGameLevel*, bool, float, bool);
	static auto func = wrapFunction(base::get() + 0x210930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto DailyLevelPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DailyLevelPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x2116b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DailyLevelPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DailyLevelPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x211620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DailyLevelPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DailyLevelPage::show), this);
	using FunctionType = decltype(show())(*)(DailyLevelPage*);
	static auto func = wrapFunction(base::get() + 0x211480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DailyLevelPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&DailyLevelPage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(DailyLevelPage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x211600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DailyLevelPage::dailyStatusFinished(GJTimedLevelType p0) -> decltype(dailyStatusFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJTimedLevelType>::func(&DailyLevelPage::dailyStatusFinished), this);
	using FunctionType = decltype(dailyStatusFinished(p0))(*)(DailyLevelPage*, GJTimedLevelType);
	static auto func = wrapFunction(base::get() + 0x210b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DailyLevelPage::dailyStatusFailed(GJTimedLevelType p0, GJErrorCode p1) -> decltype(dailyStatusFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJTimedLevelType, GJErrorCode>::func(&DailyLevelPage::dailyStatusFailed), this);
	using FunctionType = decltype(dailyStatusFailed(p0, p1))(*)(DailyLevelPage*, GJTimedLevelType, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x210f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto DailyLevelPage::levelDownloadFinished(GJGameLevel* p0) -> decltype(levelDownloadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&DailyLevelPage::levelDownloadFinished), this);
	using FunctionType = decltype(levelDownloadFinished(p0))(*)(DailyLevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x2111b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DailyLevelPage::levelDownloadFailed(int p0) -> decltype(levelDownloadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&DailyLevelPage::levelDownloadFailed), this);
	using FunctionType = decltype(levelDownloadFailed(p0))(*)(DailyLevelPage*, int);
	static auto func = wrapFunction(base::get() + 0x211270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1d96f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto EditLevelLayer::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(EditLevelLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1d9820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dc2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onSetFolder(cocos2d::CCObject* sender) -> decltype(onSetFolder(sender)) {
	using FunctionType = decltype(onSetFolder(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dc080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onGuidelines(cocos2d::CCObject* sender) -> decltype(onGuidelines(sender)) {
	using FunctionType = decltype(onGuidelines(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dc500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onLevelLeaderboard(cocos2d::CCObject* sender) -> decltype(onLevelLeaderboard(sender)) {
	using FunctionType = decltype(onLevelLeaderboard(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dc120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onUpdateDescription(cocos2d::CCObject* sender) -> decltype(onUpdateDescription(sender)) {
	using FunctionType = decltype(onUpdateDescription(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dbc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dc170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onEdit(cocos2d::CCObject* sender) -> decltype(onEdit(sender)) {
	using FunctionType = decltype(onEdit(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dadc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onHelp(cocos2d::CCObject* sender) -> decltype(onHelp(sender)) {
	using FunctionType = decltype(onHelp(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dbe00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1daf10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1db050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditLevelLayer::confirmClone(cocos2d::CCObject* p0) -> decltype(confirmClone(p0)) {
	using FunctionType = decltype(confirmClone(p0))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dbed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::confirmDelete(cocos2d::CCObject* p0) -> decltype(confirmDelete(p0)) {
	using FunctionType = decltype(confirmDelete(p0))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dbd10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::confirmMoveToTop(cocos2d::CCObject* p0) -> decltype(confirmMoveToTop(p0)) {
	using FunctionType = decltype(confirmMoveToTop(p0))(*)(EditLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1dbfa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::scene(GJGameLevel* p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(EditLevelLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x1d9590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EditLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(EditLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x1dd510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&EditLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(EditLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x1dd540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&EditLevelLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(EditLevelLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x1dd410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&EditLevelLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(EditLevelLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1dd060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&EditLevelLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(EditLevelLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1dc940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&EditLevelLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(EditLevelLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1dc650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&EditLevelLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(EditLevelLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1dca20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditLevelLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&EditLevelLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(EditLevelLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x1dd5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&EditLevelLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(EditLevelLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x1dd770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto EditLevelLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&EditLevelLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(EditLevelLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x1dd590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

GJAccountManager* GJAccountManager::get() {
		return GJAccountManager::sharedState();
	}

auto GJAccountManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0xcba00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJAccountManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJAccountManager::init), this);
	using FunctionType = decltype(init())(*)(GJAccountManager*);
	static auto func = wrapFunction(base::get() + 0xcdf10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DailyLevelNode::create(GJGameLevel* p0, DailyLevelPage* p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GJGameLevel*, DailyLevelPage*, bool);
	static auto func = wrapFunction(base::get() + 0x211340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto DailyLevelNode::init(GJGameLevel* p0, DailyLevelPage* p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(DailyLevelNode*, GJGameLevel*, DailyLevelPage*, bool);
	static auto func = wrapFunction(base::get() + 0x211b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto DailyLevelNode::onSkipLevel(cocos2d::CCObject* sender) -> decltype(onSkipLevel(sender)) {
	using FunctionType = decltype(onSkipLevel(sender))(*)(DailyLevelNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x212660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DailyLevelNode::onClaimReward(cocos2d::CCObject* sender) -> decltype(onClaimReward(sender)) {
	using FunctionType = decltype(onClaimReward(sender))(*)(DailyLevelNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x212560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DailyLevelNode::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&DailyLevelNode::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(DailyLevelNode*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x212820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ColorAction::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b27c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ColorAction::saveToState(CAState& p0) -> decltype(saveToState(p0)) {
	using FunctionType = decltype(saveToState(p0))(*)(ColorAction*, CAState&);
	static auto func = wrapFunction(base::get() + 0x2b2d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorAction::setupFromMap(gd::map<gd::string, gd::string>& p0) -> decltype(setupFromMap(p0)) {
	using FunctionType = decltype(setupFromMap(p0))(*)(ColorAction*, gd::map<gd::string, gd::string>&);
	static auto func = wrapFunction(base::get() + 0x2b4aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorAction::loadFromState(CAState& p0) -> decltype(loadFromState(p0)) {
	using FunctionType = decltype(loadFromState(p0))(*)(ColorAction*, CAState&);
	static auto func = wrapFunction(base::get() + 0x2b2e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorAction::setupFromString(gd::string p0) -> decltype(setupFromString(p0)) {
	using FunctionType = decltype(setupFromString(p0))(*)(ColorAction*, gd::string);
	static auto func = wrapFunction(base::get() + 0x2b4a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ConfigureValuePopupDelegate::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	throw std::runtime_error("ConfigureValuePopupDelegate::valuePopupClosed not implemented");
}

auto SliderDelegate::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	throw std::runtime_error("SliderDelegate::sliderBegan not implemented");
}

auto SliderDelegate::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	throw std::runtime_error("SliderDelegate::sliderEnded not implemented");
}

auto SetupTriggerPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1, float p2, float p3, int p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(SetupTriggerPopup*, EffectGameObject*, cocos2d::CCArray*, float, float, int);
	static auto func = wrapFunction(base::get() + 0x214070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto SetupTriggerPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onCustomButton(cocos2d::CCObject* sender) -> decltype(onCustomButton(sender)) {
	using FunctionType = decltype(onCustomButton(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x218190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTriggerPopup::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SetupTriggerPopup::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(SetupTriggerPopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x21f060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x2182f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::show), this);
	using FunctionType = decltype(show())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x218130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::pageChanged() -> decltype(pageChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::pageChanged), this);
	using FunctionType = decltype(pageChanged())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0xa6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::toggleGroup(int p0, bool p1) -> decltype(toggleGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupTriggerPopup::toggleGroup), this);
	using FunctionType = decltype(toggleGroup(p0, p1))(*)(SetupTriggerPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x214ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x215d20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTriggerPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2160a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2160e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&SetupTriggerPopup::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(SetupTriggerPopup*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x218330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTriggerPopup::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(SetupTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2183f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupTriggerPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupTriggerPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0xa6b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&SetupTriggerPopup::sliderBegan), this);
	using FunctionType = decltype(sliderBegan(p0))(*)(SetupTriggerPopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x2184a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&SetupTriggerPopup::sliderEnded), this);
	using FunctionType = decltype(sliderEnded(p0))(*)(SetupTriggerPopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x218580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x21a8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTriggerPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x21ce00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::updateToggleItem(int p0, bool p1) -> decltype(updateToggleItem(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupTriggerPopup::updateToggleItem), this);
	using FunctionType = decltype(updateToggleItem(p0, p1))(*)(SetupTriggerPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x21cfd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0xa6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::getValue(int p0) -> decltype(getValue(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&SetupTriggerPopup::getValue), this);
	using FunctionType = decltype(getValue(p0))(*)(SetupTriggerPopup*, int);
	static auto func = wrapFunction(base::get() + 0x21d090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupTriggerPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x21d420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTriggerPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x21d4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTriggerPopup::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupTriggerPopup::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupTriggerPopup*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x21e120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSpecialColorSelectDelegate::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	throw std::runtime_error("GJSpecialColorSelectDelegate::colorSelectClosed not implemented");
}

auto ColorSelectPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(EffectGameObject*, cocos2d::CCArray*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x6e7fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto ColorSelectPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1, ColorAction* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(ColorSelectPopup*, EffectGameObject*, cocos2d::CCArray*, ColorAction*);
	static auto func = wrapFunction(base::get() + 0x6e8300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ColorSelectPopup::closeColorSelect(cocos2d::CCObject* p0) -> decltype(closeColorSelect(p0)) {
	using FunctionType = decltype(closeColorSelect(p0))(*)(ColorSelectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6eaa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ColorSelectPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectPopup::show), this);
	using FunctionType = decltype(show())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x6ee1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(ColorSelectPopup*);
	static auto func = wrapFunction(base::get() + 0x6ebf80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ColorSelectPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ColorSelectPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x6ee290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ColorSelectPopup::colorValueChanged(cocos2d::_ccColor3B p0) -> decltype(colorValueChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B>::func(&ColorSelectPopup::colorValueChanged), this);
	using FunctionType = decltype(colorValueChanged(p0))(*)(ColorSelectPopup*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x6ec740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ColorSelectPopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJSpecialColorSelect*, int>::func(&ColorSelectPopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0, p1))(*)(ColorSelectPopup*, GJSpecialColorSelect*, int);
	static auto func = wrapFunction(base::get() + 0x6ee830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ColorActionSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorActionSprite::init), this);
	using FunctionType = decltype(init())(*)(ColorActionSprite*);
	static auto func = wrapFunction(base::get() + 0x2b25c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSpecialColorSelect::textForColorIdx(int p0) -> decltype(textForColorIdx(p0)) {
	using FunctionType = decltype(textForColorIdx(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x5eacd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJSpecialColorSelect::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSpecialColorSelect::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJSpecialColorSelect*);
	static auto func = wrapFunction(base::get() + 0x5eaf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectLiveOverlay::create(ColorAction* p0, ColorAction* p1, EffectGameObject* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(ColorAction*, ColorAction*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x534340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto ColorSelectLiveOverlay::init(ColorAction* p0, ColorAction* p1, EffectGameObject* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(ColorSelectLiveOverlay*, ColorAction*, ColorAction*, EffectGameObject*);
	static auto func = wrapFunction(base::get() + 0x534510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto ColorSelectLiveOverlay::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectLiveOverlay::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ColorSelectLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x536080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSelectLiveOverlay::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ColorSelectLiveOverlay::show), this);
	using FunctionType = decltype(show())(*)(ColorSelectLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x536130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ConfigureValuePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ConfigureValuePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ConfigureValuePopup*);
	static auto func = wrapFunction(base::get() + 0x5e7e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ConfigureValuePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureValuePopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(ConfigureValuePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5e7d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ConfigureValuePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureValuePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ConfigureValuePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5e7d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SelectArtDelegate::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	throw std::runtime_error("SelectArtDelegate::selectArtClosed not implemented");
}

auto SelectArtLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectArtLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x24e760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectSettingDelegate::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	throw std::runtime_error("SelectSettingDelegate::selectSettingClosed not implemented");
}

auto SelectSettingLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectSettingLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectSettingLayer*);
	static auto func = wrapFunction(base::get() + 0x24f460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongLayerDelegate::customSongLayerClosed() -> decltype(customSongLayerClosed()) {
	throw std::runtime_error("CustomSongLayerDelegate::customSongLayerClosed not implemented");
}

auto LevelSettingsLayer::init(LevelSettingsObject* p0, LevelEditorLayer* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(LevelSettingsLayer*, LevelSettingsObject*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x249830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelSettingsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x24ce00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelSettingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x24d730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelSettingsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelSettingsLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelSettingsLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x24d290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelSettingsLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&LevelSettingsLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(LevelSettingsLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x24d1b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&LevelSettingsLayer::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(LevelSettingsLayer*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x24d4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectSettingLayer*>::func(&LevelSettingsLayer::selectSettingClosed), this);
	using FunctionType = decltype(selectSettingClosed(p0))(*)(LevelSettingsLayer*, SelectSettingLayer*);
	static auto func = wrapFunction(base::get() + 0x24cc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSettingsLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(LevelSettingsLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x24ce50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelSettingsLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelSettingsLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(LevelSettingsLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x24ce90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJChallengeItem::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x8b120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJChallengeItem::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJChallengeItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8b3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJChallengeItem::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(GJChallengeItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8b350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJChallengeItem::createFromString(gd::string p0) -> decltype(createFromString(p0)) {
	using FunctionType = decltype(createFromString(p0))(*)(GJChallengeItem*, gd::string);
	static auto func = wrapFunction(base::get() + 0x8af60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJChallengeItem::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJChallengeItem::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJChallengeItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8b520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJChallengeItem::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJChallengeItem::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJChallengeItem*);
	static auto func = wrapFunction(base::get() + 0x8b5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LocalLevelManager::getCreatedLists(int p0) -> decltype(getCreatedLists(p0)) {
	using FunctionType = decltype(getCreatedLists(p0))(*)(LocalLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5bd470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LocalLevelManager::getCreatedLevels(int p0) -> decltype(getCreatedLevels(p0)) {
	using FunctionType = decltype(getCreatedLevels(p0))(*)(LocalLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5bd3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LocalLevelManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x5bc220, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto LocalLevelManager::tryLoadMainLevelString(int p0) -> decltype(tryLoadMainLevelString(p0)) {
	using FunctionType = decltype(tryLoadMainLevelString(p0))(*)(LocalLevelManager*, int);
	static auto func = wrapFunction(base::get() + 0x5bc400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LocalLevelManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LocalLevelManager::init), this);
	using FunctionType = decltype(init())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x5bc3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LocalLevelManager::encodeDataTo(DS_Dictionary* p0) -> decltype(encodeDataTo(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&LocalLevelManager::encodeDataTo), this);
	using FunctionType = decltype(encodeDataTo(p0))(*)(LocalLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x5bd590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LocalLevelManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&LocalLevelManager::dataLoaded), this);
	using FunctionType = decltype(dataLoaded(p0))(*)(LocalLevelManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x5bd5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LocalLevelManager::firstLoad() -> decltype(firstLoad()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LocalLevelManager::firstLoad), this);
	using FunctionType = decltype(firstLoad())(*)(LocalLevelManager*);
	static auto func = wrapFunction(base::get() + 0x5bd500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJEffectManager::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2b6ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJEffectManager::getSaveString() -> decltype(getSaveString()) {
	using FunctionType = decltype(getSaveString())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x2c78e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::getColorAction(int p0) -> decltype(getColorAction(p0)) {
	using FunctionType = decltype(getColorAction(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2b80f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::getColorSprite(int p0) -> decltype(getColorSprite(p0)) {
	using FunctionType = decltype(getColorSprite(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2b82b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::playerDied() -> decltype(playerDied()) {
	using FunctionType = decltype(playerDied())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x2c4bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::colorExists(int p0) -> decltype(colorExists(p0)) {
	using FunctionType = decltype(colorExists(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2b95d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::shouldBlend(int p0) -> decltype(shouldBlend(p0)) {
	using FunctionType = decltype(shouldBlend(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2b83f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::loadFromState(EffectManagerState& p0) -> decltype(loadFromState(p0)) {
	using FunctionType = decltype(loadFromState(p0))(*)(GJEffectManager*, EffectManagerState&);
	static auto func = wrapFunction(base::get() + 0x2c8600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::processColors() -> decltype(processColors()) {
	using FunctionType = decltype(processColors())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x2b8430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::updateEffects(float p0) -> decltype(updateEffects(p0)) {
	using FunctionType = decltype(updateEffects(p0))(*)(GJEffectManager*, float);
	static auto func = wrapFunction(base::get() + 0x2b9630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::isGroupEnabled(int p0) -> decltype(isGroupEnabled(p0)) {
	using FunctionType = decltype(isGroupEnabled(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2c4610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::hasBeenTriggered(int p0, int p1) -> decltype(hasBeenTriggered(p0, p1)) {
	using FunctionType = decltype(hasBeenTriggered(p0, p1))(*)(GJEffectManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x2c45d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::storeTriggeredID(int p0, int p1) -> decltype(storeTriggeredID(p0, p1)) {
	using FunctionType = decltype(storeTriggeredID(p0, p1))(*)(GJEffectManager*, int, int);
	static auto func = wrapFunction(base::get() + 0x2c4420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJEffectManager::activeColorForIndex(int p0) -> decltype(activeColorForIndex(p0)) {
	using FunctionType = decltype(activeColorForIndex(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2b8260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::activeOpacityForIndex(int p0) -> decltype(activeOpacityForIndex(p0)) {
	using FunctionType = decltype(activeOpacityForIndex(p0))(*)(GJEffectManager*, int);
	static auto func = wrapFunction(base::get() + 0x2b83c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::calculateLightBGColor(cocos2d::_ccColor3B p0) -> decltype(calculateLightBGColor(p0)) {
	using FunctionType = decltype(calculateLightBGColor(p0))(*)(GJEffectManager*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x2c74c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJEffectManager::processInheritedColors() -> decltype(processInheritedColors()) {
	using FunctionType = decltype(processInheritedColors())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x2b8750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::processCopyColorPulseActions() -> decltype(processCopyColorPulseActions()) {
	using FunctionType = decltype(processCopyColorPulseActions())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x2b8b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::reset() -> decltype(reset()) {
	using FunctionType = decltype(reset())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x2b7070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJEffectManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJEffectManager::init), this);
	using FunctionType = decltype(init())(*)(GJEffectManager*);
	static auto func = wrapFunction(base::get() + 0x2b6e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountDelegate::accountStatusChanged() -> decltype(accountStatusChanged()) {
	throw std::runtime_error("GJAccountDelegate::accountStatusChanged not implemented");
}

auto GJAccountSyncDelegate::syncAccountFinished() -> decltype(syncAccountFinished()) {
	throw std::runtime_error("GJAccountSyncDelegate::syncAccountFinished not implemented");
}

auto GJAccountSyncDelegate::syncAccountFailed(BackupAccountError p0, int p1) -> decltype(syncAccountFailed(p0, p1)) {
	throw std::runtime_error("GJAccountSyncDelegate::syncAccountFailed not implemented");
}

auto GJAccountLoginDelegate::loginAccountFinished(int p0, int p1) -> decltype(loginAccountFinished(p0, p1)) {
	throw std::runtime_error("GJAccountLoginDelegate::loginAccountFinished not implemented");
}

auto GJAccountLoginDelegate::loginAccountFailed(AccountError p0) -> decltype(loginAccountFailed(p0)) {
	throw std::runtime_error("GJAccountLoginDelegate::loginAccountFailed not implemented");
}

auto GJAccountBackupDelegate::backupAccountFinished() -> decltype(backupAccountFinished()) {
	throw std::runtime_error("GJAccountBackupDelegate::backupAccountFinished not implemented");
}

auto GJAccountBackupDelegate::backupAccountFailed(BackupAccountError p0, int p1) -> decltype(backupAccountFailed(p0, p1)) {
	throw std::runtime_error("GJAccountBackupDelegate::backupAccountFailed not implemented");
}

auto GJAccountRegisterDelegate::registerAccountFinished() -> decltype(registerAccountFinished()) {
	throw std::runtime_error("GJAccountRegisterDelegate::registerAccountFinished not implemented");
}

auto GJAccountRegisterDelegate::registerAccountFailed(AccountError p0) -> decltype(registerAccountFailed(p0)) {
	throw std::runtime_error("GJAccountRegisterDelegate::registerAccountFailed not implemented");
}

auto GJAccountSettingsDelegate::updateSettingsFinished() -> decltype(updateSettingsFinished()) {
	throw std::runtime_error("GJAccountSettingsDelegate::updateSettingsFinished not implemented");
}

auto GJAccountSettingsDelegate::updateSettingsFailed() -> decltype(updateSettingsFailed()) {
	throw std::runtime_error("GJAccountSettingsDelegate::updateSettingsFailed not implemented");
}

auto GJCommentListLayer::create(BoomListView* p0, char const* p1, cocos2d::_ccColor4B p2, float p3, float p4, bool p5) -> decltype(create(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5))(*)(BoomListView*, char const*, cocos2d::_ccColor4B, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x27c4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5);
}

auto GJCommentListLayer::init(BoomListView* p0, char const* p1, cocos2d::_ccColor4B p2, float p3, float p4, bool p5) -> decltype(init(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5))(*)(GJCommentListLayer*, BoomListView*, char const*, cocos2d::_ccColor4B, float, float, bool);
	static auto func = wrapFunction(base::get() + 0x27c5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto ArtistCell::loadFromObject(SongInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(ArtistCell*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x226170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ArtistCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ArtistCell::init), this);
	using FunctionType = decltype(init())(*)(ArtistCell*);
	static auto func = wrapFunction(base::get() + 0x2329c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ArtistCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ArtistCell::draw), this);
	using FunctionType = decltype(draw())(*)(ArtistCell*);
	static auto func = wrapFunction(base::get() + 0x232b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FontObject::getFontWidth(int p0) -> decltype(getFontWidth(p0)) {
	using FunctionType = decltype(getFontWidth(p0))(*)(FontObject*, int);
	static auto func = wrapFunction(base::get() + 0x1feb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJItemIcon::create(UnlockType unlockType, int itemID, cocos2d::_ccColor3B p2, cocos2d::_ccColor3B p3, bool p4, bool p5, bool p6, cocos2d::_ccColor3B p7) -> decltype(create(unlockType, itemID, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(create(unlockType, itemID, p2, p3, p4, p5, p6, p7))(*)(UnlockType, int, cocos2d::_ccColor3B, cocos2d::_ccColor3B, bool, bool, bool, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x34ef90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(unlockType, itemID, p2, p3, p4, p5, p6, p7);
}

auto GJItemIcon::init(UnlockType p0, int p1, cocos2d::_ccColor3B p2, cocos2d::_ccColor3B p3, bool p4, bool p5, bool p6, cocos2d::_ccColor3B p7) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7))(*)(GJItemIcon*, UnlockType, int, cocos2d::_ccColor3B, cocos2d::_ccColor3B, bool, bool, bool, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x34f0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

GJItemIcon* GJItemIcon::createBrowserItem(UnlockType unlockType, int itemID) {
		return GJItemIcon::create(unlockType, itemID, {0xAF, 0xAF, 0xAF}, {0xFF, 0xFF, 0xFF}, false, true, true, {0xFF, 0xFF, 0xFF});
	}

auto GJItemIcon::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJItemIcon::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJItemIcon*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x34f600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJPurchaseDelegate::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	throw std::runtime_error("GJPurchaseDelegate::didPurchaseItem not implemented");
}

auto GJPathPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x2df5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x2df480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathPage::show), this);
	using FunctionType = decltype(show())(*)(GJPathPage*);
	static auto func = wrapFunction(base::get() + 0x2df600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathPage::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJStoreItem*>::func(&GJPathPage::didPurchaseItem), this);
	using FunctionType = decltype(didPurchaseItem(p0))(*)(GJPathPage*, GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x2dd930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJUserCell::onUnblockUser(cocos2d::CCObject* sender) -> decltype(onUnblockUser(sender)) {
	using FunctionType = decltype(onUnblockUser(sender))(*)(GJUserCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x234640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJUserCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJUserCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x22a2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJUserCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserCell::init), this);
	using FunctionType = decltype(init())(*)(GJUserCell*);
	static auto func = wrapFunction(base::get() + 0x2345f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUserCell::draw() -> decltype(draw()) {
	throw std::runtime_error("GJUserCell::draw not implemented");
}

auto GJUserCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJUserCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJUserCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x234d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUserCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJUserCell::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJUserCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x235020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUserCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJUserCell::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJUserCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x235210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJUserCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJUserCell::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJUserCell*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x235380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto HardStreak::updateStroke(float p0) -> decltype(updateStroke(p0)) {
	using FunctionType = decltype(updateStroke(p0))(*)(HardStreak*, float);
	static auto func = wrapFunction(base::get() + 0x96e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto HardStreak::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HardStreak::init), this);
	using FunctionType = decltype(init())(*)(HardStreak*);
	static auto func = wrapFunction(base::get() + 0x96c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectSFXSortDelegate::sortSelectClosed(SelectSFXSortLayer* p0) -> decltype(sortSelectClosed(p0)) {
	throw std::runtime_error("SelectSFXSortDelegate::sortSelectClosed not implemented");
}

auto SFXBrowser::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(SFXBrowser*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x41e7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SFXBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SFXBrowser::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x41eac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SFXBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SFXBrowser::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x41ea20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SFXBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&SFXBrowser::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(SFXBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x41e090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&SFXBrowser::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(SFXBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x41e1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXBrowser::sortSelectClosed(SelectSFXSortLayer* p0) -> decltype(sortSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectSFXSortLayer*>::func(&SFXBrowser::sortSelectClosed), this);
	using FunctionType = decltype(sortSelectClosed(p0))(*)(SFXBrowser*, SelectSFXSortLayer*);
	static auto func = wrapFunction(base::get() + 0x41e560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&SFXBrowser::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(SFXBrowser*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x41e870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto SFXBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SFXBrowser::getSelectedCellIdx), this);
	using FunctionType = decltype(getSelectedCellIdx())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x41e9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SFXBrowser::shouldSnapToSelected() -> decltype(shouldSnapToSelected()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SFXBrowser::shouldSnapToSelected), this);
	using FunctionType = decltype(shouldSnapToSelected())(*)(SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x41ea00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::init), this);
	using FunctionType = decltype(init())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x4a0e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x4a2c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x4a2c00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShardsPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShardsPage::show), this);
	using FunctionType = decltype(show())(*)(ShardsPage*);
	static auto func = wrapFunction(base::get() + 0x4a2a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(SongsLayer*);
	static auto func = wrapFunction(base::get() + 0x4e9da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto StatsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&StatsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(StatsLayer*);
	static auto func = wrapFunction(base::get() + 0x95690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCCountdown::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCCountdown::init), this);
	using FunctionType = decltype(init())(*)(CCCountdown*);
	static auto func = wrapFunction(base::get() + 0x782f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCCountdown::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCCountdown::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCCountdown*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x783340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJBigSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBigSprite::init), this);
	using FunctionType = decltype(init())(*)(GJBigSprite*);
	static auto func = wrapFunction(base::get() + 0x247f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMapObject::createMonster(int p0) -> decltype(createMonster(p0)) {
	using FunctionType = decltype(createMonster(p0))(*)(GJMapObject*, int);
	static auto func = wrapFunction(base::get() + 0x244df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJScoreCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJScoreCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x228500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJScoreCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScoreCell::init), this);
	using FunctionType = decltype(init())(*)(GJScoreCell*);
	static auto func = wrapFunction(base::get() + 0x2339c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScoreCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScoreCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJScoreCell*);
	static auto func = wrapFunction(base::get() + 0x233c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScoreCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJScoreCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJScoreCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x233bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RewardedVideoDelegate::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	throw std::runtime_error("RewardedVideoDelegate::rewardedVideoFinished not implemented");
}

auto RewardedVideoDelegate::shouldOffsetRewardCurrency() -> decltype(shouldOffsetRewardCurrency()) {
	throw std::runtime_error("RewardedVideoDelegate::shouldOffsetRewardCurrency not implemented");
}

auto GJShopLayer::init(ShopType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJShopLayer*, ShopType);
	static auto func = wrapFunction(base::get() + 0x300240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJShopLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(GJShopLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x301b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJShopLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x301e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJShopLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJShopLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x304340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJShopLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJShopLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJShopLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3046b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJShopLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJShopLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJShopLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3046d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJShopLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJShopLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(GJShopLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x3046f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJShopLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x304730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x302dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::didPurchaseItem(GJStoreItem* p0) -> decltype(didPurchaseItem(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJStoreItem*>::func(&GJShopLayer::didPurchaseItem), this);
	using FunctionType = decltype(didPurchaseItem(p0))(*)(GJShopLayer*, GJStoreItem*);
	static auto func = wrapFunction(base::get() + 0x3026c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJShopLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJShopLayer::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(GJShopLayer*);
	static auto func = wrapFunction(base::get() + 0x302100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJShopLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&GJShopLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(GJShopLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x304180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJStoreItem::init(int p0, int p1, int p2, int p3, ShopType p4) -> decltype(init(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4))(*)(GJStoreItem*, int, int, int, int, ShopType);
	static auto func = wrapFunction(base::get() + 0x8b600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto MapPackCell::loadFromMapPack(GJMapPack* p0) -> decltype(loadFromMapPack(p0)) {
	using FunctionType = decltype(loadFromMapPack(p0))(*)(MapPackCell*, GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x223ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MapPackCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapPackCell::init), this);
	using FunctionType = decltype(init())(*)(MapPackCell*);
	static auto func = wrapFunction(base::get() + 0x230a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapPackCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapPackCell::draw), this);
	using FunctionType = decltype(draw())(*)(MapPackCell*);
	static auto func = wrapFunction(base::get() + 0x230ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsCell::loadFromObject(OptionsObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(OptionsCell*, OptionsObject*);
	static auto func = wrapFunction(base::get() + 0x2232d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRewardDelegate::rewardsStatusFinished(int p0) -> decltype(rewardsStatusFinished(p0)) {
	throw std::runtime_error("GJRewardDelegate::rewardsStatusFinished not implemented");
}

auto GJRewardDelegate::rewardsStatusFailed() -> decltype(rewardsStatusFailed()) {
	throw std::runtime_error("GJRewardDelegate::rewardsStatusFailed not implemented");
}

auto RewardsPage::updateTimers(float p0) -> decltype(updateTimers(p0)) {
	using FunctionType = decltype(updateTimers(p0))(*)(RewardsPage*, float);
	static auto func = wrapFunction(base::get() + 0x1f9460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RewardsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::init), this);
	using FunctionType = decltype(init())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x1f8590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x1f9e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x1f9de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::show), this);
	using FunctionType = decltype(show())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x1f9c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardsPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&RewardsPage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(RewardsPage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1f9dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RewardsPage::rewardsStatusFinished(int p0) -> decltype(rewardsStatusFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&RewardsPage::rewardsStatusFinished), this);
	using FunctionType = decltype(rewardsStatusFinished(p0))(*)(RewardsPage*, int);
	static auto func = wrapFunction(base::get() + 0x1f9900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RewardsPage::rewardsStatusFailed() -> decltype(rewardsStatusFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardsPage::rewardsStatusFailed), this);
	using FunctionType = decltype(rewardsStatusFailed())(*)(RewardsPage*);
	static auto func = wrapFunction(base::get() + 0x1f9b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer*);
	static auto func = wrapFunction(base::get() + 0x5bfb20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer*);
	static auto func = wrapFunction(base::get() + 0x5c3930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SecretLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5c2ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SecretLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5c2b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SecretLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5c2c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SecretLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SecretLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5c2aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ShaderLayer::preCommonShader() -> decltype(preCommonShader()) {
	using FunctionType = decltype(preCommonShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3aa510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preGlitchShader() -> decltype(preGlitchShader()) {
	using FunctionType = decltype(preGlitchShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3ad250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::prePixelateShader() -> decltype(prePixelateShader()) {
	using FunctionType = decltype(prePixelateShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3adef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preChromaticShader() -> decltype(preChromaticShader()) {
	using FunctionType = decltype(preChromaticShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3ad7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preGrayscaleShader() -> decltype(preGrayscaleShader()) {
	using FunctionType = decltype(preGrayscaleShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3af3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preShockLineShader() -> decltype(preShockLineShader()) {
	using FunctionType = decltype(preShockLineShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3acd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preShockWaveShader() -> decltype(preShockWaveShader()) {
	using FunctionType = decltype(preShockWaveShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3ac670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::performCalculations() -> decltype(performCalculations()) {
	using FunctionType = decltype(performCalculations())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3afea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preLensCircleShader() -> decltype(preLensCircleShader()) {
	using FunctionType = decltype(preLensCircleShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3ae720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preMotionBlurShader() -> decltype(preMotionBlurShader()) {
	using FunctionType = decltype(preMotionBlurShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3aecb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preRadialBlurShader() -> decltype(preRadialBlurShader()) {
	using FunctionType = decltype(preRadialBlurShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3ae9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preColorChangeShader() -> decltype(preColorChangeShader()) {
	using FunctionType = decltype(preColorChangeShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3af900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::preSplitScreenShader() -> decltype(preSplitScreenShader()) {
	using FunctionType = decltype(preSplitScreenShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3afb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::updateShockLineCenter(cocos2d::CCPoint p0) -> decltype(updateShockLineCenter(p0)) {
	using FunctionType = decltype(updateShockLineCenter(p0))(*)(ShaderLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x3accf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShaderLayer::updateShockWaveCenter(cocos2d::CCPoint p0) -> decltype(updateShockWaveCenter(p0)) {
	using FunctionType = decltype(updateShockWaveCenter(p0))(*)(ShaderLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x3ac630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShaderLayer::updateMotionBlurSpeedX(float p0, float p1) -> decltype(updateMotionBlurSpeedX(p0, p1)) {
	using FunctionType = decltype(updateMotionBlurSpeedX(p0, p1))(*)(ShaderLayer*, float, float);
	static auto func = wrapFunction(base::get() + 0x3aef90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ShaderLayer::updateMotionBlurSpeedY(float p0, float p1) -> decltype(updateMotionBlurSpeedY(p0, p1)) {
	using FunctionType = decltype(updateMotionBlurSpeedY(p0, p1))(*)(ShaderLayer*, float, float);
	static auto func = wrapFunction(base::get() + 0x3aeff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ShaderLayer::preChromaticGlitchShader() -> decltype(preChromaticGlitchShader()) {
	using FunctionType = decltype(preChromaticGlitchShader())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3adab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto ShaderLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ShaderLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(ShaderLayer*, float);
	static auto func = wrapFunction(base::get() + 0x3aa350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShaderLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderLayer::init), this);
	using FunctionType = decltype(init())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3a8bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ShaderLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShaderLayer::visit), this);
	using FunctionType = decltype(visit())(*)(ShaderLayer*);
	static auto func = wrapFunction(base::get() + 0x3b01c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadPopup::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x25f2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto UploadPopup::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UploadPopup*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x25f5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UploadPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UploadPopup*);
	static auto func = wrapFunction(base::get() + 0x260020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadPopup::show), this);
	using FunctionType = decltype(show())(*)(UploadPopup*);
	static auto func = wrapFunction(base::get() + 0x25ffb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadPopup::levelUploadFinished(GJGameLevel* p0) -> decltype(levelUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&UploadPopup::levelUploadFinished), this);
	using FunctionType = decltype(levelUploadFinished(p0))(*)(UploadPopup*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x25fb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UploadPopup::levelUploadFailed(GJGameLevel* p0) -> decltype(levelUploadFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJGameLevel*>::func(&UploadPopup::levelUploadFailed), this);
	using FunctionType = decltype(levelUploadFailed(p0))(*)(UploadPopup*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x25fda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xc85a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xca520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::backupAccountFinished() -> decltype(backupAccountFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::backupAccountFinished), this);
	using FunctionType = decltype(backupAccountFinished())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xc9a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::backupAccountFailed(BackupAccountError p0, int p1) -> decltype(backupAccountFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BackupAccountError, int>::func(&AccountLayer::backupAccountFailed), this);
	using FunctionType = decltype(backupAccountFailed(p0, p1))(*)(AccountLayer*, BackupAccountError, int);
	static auto func = wrapFunction(base::get() + 0xc9bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLayer::syncAccountFinished() -> decltype(syncAccountFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::syncAccountFinished), this);
	using FunctionType = decltype(syncAccountFinished())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xc9fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::syncAccountFailed(BackupAccountError p0, int p1) -> decltype(syncAccountFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BackupAccountError, int>::func(&AccountLayer::syncAccountFailed), this);
	using FunctionType = decltype(syncAccountFailed(p0, p1))(*)(AccountLayer*, BackupAccountError, int);
	static auto func = wrapFunction(base::get() + 0xca160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLayer::accountStatusChanged() -> decltype(accountStatusChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLayer::accountStatusChanged), this);
	using FunctionType = decltype(accountStatusChanged())(*)(AccountLayer*);
	static auto func = wrapFunction(base::get() + 0xc9a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xca400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCLightFlash::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCLightFlash::init), this);
	using FunctionType = decltype(init())(*)(CCLightFlash*);
	static auto func = wrapFunction(base::get() + 0x4de720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCLightStrip::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCLightStrip::draw), this);
	using FunctionType = decltype(draw())(*)(CCLightStrip*);
	static auto func = wrapFunction(base::get() + 0x4df1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCLightStrip::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&CCLightStrip::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(CCLightStrip*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x4df380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCSpritePart::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&CCSpritePart::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(CCSpritePart*, bool);
	static auto func = wrapFunction(base::get() + 0x353850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ColorAction2::step(float p0) -> decltype(step(p0)) {
	throw std::runtime_error("ColorAction2::step not implemented");
}

auto CreateGuidelinesLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(CreateGuidelinesLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e5010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreateGuidelinesLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(CreateGuidelinesLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e5190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreateGuidelinesLayer::onRecord(cocos2d::CCObject* sender) -> decltype(onRecord(sender)) {
	using FunctionType = decltype(onRecord(sender))(*)(CreateGuidelinesLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e46c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CreateGuidelinesLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CreateGuidelinesLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(CreateGuidelinesLayer*, float);
	static auto func = wrapFunction(base::get() + 0x4e4ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateGuidelinesLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateGuidelinesLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CreateGuidelinesLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4e5260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateGuidelinesLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CreateGuidelinesLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4e5350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateGuidelinesLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CreateGuidelinesLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4e5370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateGuidelinesLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CreateGuidelinesLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4e5410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x4e5450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x4e51c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&CreateGuidelinesLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(CreateGuidelinesLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4e5490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateGuidelinesLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CreateGuidelinesLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CreateGuidelinesLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4e50c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateGuidelinesLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&CreateGuidelinesLayer::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(CreateGuidelinesLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4e54e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateGuidelinesLayer::playMusic() -> decltype(playMusic()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::playMusic), this);
	using FunctionType = decltype(playMusic())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x4e47d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::registerTouch() -> decltype(registerTouch()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::registerTouch), this);
	using FunctionType = decltype(registerTouch())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x4e5210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateGuidelinesLayer::recordingDidStop() -> decltype(recordingDidStop()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateGuidelinesLayer::recordingDidStop), this);
	using FunctionType = decltype(recordingDidStop())(*)(CreateGuidelinesLayer*);
	static auto func = wrapFunction(base::get() + 0x4e4860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FindBPMLayer::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(FindBPMLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e5a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FindBPMLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(FindBPMLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e5a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FindBPMLayer::onRecord(cocos2d::CCObject* sender) -> decltype(onRecord(sender)) {
	using FunctionType = decltype(onRecord(sender))(*)(FindBPMLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e57c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FindBPMLayer::playMusic() -> decltype(playMusic()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindBPMLayer::playMusic), this);
	using FunctionType = decltype(playMusic())(*)(FindBPMLayer*);
	static auto func = wrapFunction(base::get() + 0x4e58d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FindBPMLayer::registerTouch() -> decltype(registerTouch()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindBPMLayer::registerTouch), this);
	using FunctionType = decltype(registerTouch())(*)(FindBPMLayer*);
	static auto func = wrapFunction(base::get() + 0x4e5960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FindBPMLayer::recordingDidStop() -> decltype(recordingDidStop()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindBPMLayer::recordingDidStop), this);
	using FunctionType = decltype(recordingDidStop())(*)(FindBPMLayer*);
	static auto func = wrapFunction(base::get() + 0x4e5800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletNode::init(GJMapPack* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletNode*, GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x53ed50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletNode::nameForType(GauntletType p0) -> decltype(nameForType(p0)) {
	using FunctionType = decltype(nameForType(p0))(*)(GauntletType);
	static auto func = wrapFunction(base::get() + 0x5403e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletNode::frameForType(GauntletType p0) -> decltype(frameForType(p0)) {
	using FunctionType = decltype(frameForType(p0))(*)(GauntletNode*, GauntletType);
	static auto func = wrapFunction(base::get() + 0x5408a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLocalScore::create(int p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, int);
	static auto func = wrapFunction(base::get() + 0x52ca40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJMPDelegate::joinLobbyFinished(int p0) -> decltype(joinLobbyFinished(p0)) {
	throw std::runtime_error("GJMPDelegate::joinLobbyFinished not implemented");
}

auto GJMPDelegate::joinLobbyFailed(int p0, GJMPErrorCode p1) -> decltype(joinLobbyFailed(p0, p1)) {
	throw std::runtime_error("GJMPDelegate::joinLobbyFailed not implemented");
}

auto GJMPDelegate::didUploadMPComment(int p0) -> decltype(didUploadMPComment(p0)) {
	throw std::runtime_error("GJMPDelegate::didUploadMPComment not implemented");
}

auto GJMPDelegate::updateComments() -> decltype(updateComments()) {
	throw std::runtime_error("GJMPDelegate::updateComments not implemented");
}

auto GJPathsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x2dad20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJPathsLayer::onPath(cocos2d::CCObject* sender) -> decltype(onPath(sender)) {
	using FunctionType = decltype(onPath(sender))(*)(GJPathsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2db510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPathsLayer::nameForPath(int p0) -> decltype(nameForPath(p0)) {
	using FunctionType = decltype(nameForPath(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x2dab80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPathsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::init), this);
	using FunctionType = decltype(init())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2dae70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2db590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2db9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2db8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPathsLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathsLayer::show), this);
	using FunctionType = decltype(show())(*)(GJPathsLayer*);
	static auto func = wrapFunction(base::get() + 0x2db9f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteCOpacity::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCSpriteCOpacity::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCSpriteCOpacity*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x45eaa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJPathSprite::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJPathSprite*, int);
	static auto func = wrapFunction(base::get() + 0x2df780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathSprite::updateState() -> decltype(updateState()) {
	using FunctionType = decltype(updateState())(*)(GJPathSprite*);
	static auto func = wrapFunction(base::get() + 0x2db490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathSprite::addRankLabel(int p0) -> decltype(addRankLabel(p0)) {
	using FunctionType = decltype(addRankLabel(p0))(*)(GJPathSprite*, int);
	static auto func = wrapFunction(base::get() + 0x2df890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPathSprite::addShardSprite() -> decltype(addShardSprite()) {
	using FunctionType = decltype(addShardSprite())(*)(GJPathSprite*);
	static auto func = wrapFunction(base::get() + 0x2df370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPathSprite::changeToLockedArt() -> decltype(changeToLockedArt()) {
	using FunctionType = decltype(changeToLockedArt())(*)(GJPathSprite*);
	static auto func = wrapFunction(base::get() + 0x2de380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJPromoPopup::create(gd::string p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x2915e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJPromoPopup::init(gd::string p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJPromoPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x291760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJPromoPopup::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPromoPopup::onExit), this);
	using FunctionType = decltype(onExit())(*)(GJPromoPopup*);
	static auto func = wrapFunction(base::get() + 0x291a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPromoPopup::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPromoPopup::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJPromoPopup*);
	static auto func = wrapFunction(base::get() + 0x291b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPromoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPromoPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJPromoPopup*);
	static auto func = wrapFunction(base::get() + 0x291a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPromoPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPromoPopup::show), this);
	using FunctionType = decltype(show())(*)(GJPromoPopup*);
	static auto func = wrapFunction(base::get() + 0x291b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRewardItem::createSpecial(GJRewardType p0, int p1, int p2, SpecialRewardItem p3, int p4, SpecialRewardItem p5, int p6, int p7, int p8) -> decltype(createSpecial(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {
	using FunctionType = decltype(createSpecial(p0, p1, p2, p3, p4, p5, p6, p7, p8))(*)(GJRewardItem*, GJRewardType, int, int, SpecialRewardItem, int, SpecialRewardItem, int, int, int);
	static auto func = wrapFunction(base::get() + 0x78290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7, p8);
}

auto GJRewardItem::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(GJRewardItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8adb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRewardItem::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJRewardItem::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJRewardItem*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8aef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRewardItem::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRewardItem::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJRewardItem*);
	static auto func = wrapFunction(base::get() + 0x8af50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MPLobbyLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MPLobbyLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MPLobbyLayer*);
	static auto func = wrapFunction(base::get() + 0x46fce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MPLobbyLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&MPLobbyLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(MPLobbyLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x470490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::joinLobbyFinished(int p0) -> decltype(joinLobbyFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&MPLobbyLayer::joinLobbyFinished), this);
	using FunctionType = decltype(joinLobbyFinished(p0))(*)(MPLobbyLayer*, int);
	static auto func = wrapFunction(base::get() + 0x46fe60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::joinLobbyFailed(int p0, GJMPErrorCode p1) -> decltype(joinLobbyFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJMPErrorCode>::func(&MPLobbyLayer::joinLobbyFailed), this);
	using FunctionType = decltype(joinLobbyFailed(p0, p1))(*)(MPLobbyLayer*, int, GJMPErrorCode);
	static auto func = wrapFunction(base::get() + 0x4702c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MPLobbyLayer::updateComments() -> decltype(updateComments()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MPLobbyLayer::updateComments), this);
	using FunctionType = decltype(updateComments())(*)(MPLobbyLayer*);
	static auto func = wrapFunction(base::get() + 0x470190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MPLobbyLayer::didUploadMPComment(int p0) -> decltype(didUploadMPComment(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&MPLobbyLayer::didUploadMPComment), this);
	using FunctionType = decltype(didUploadMPComment(p0))(*)(MPLobbyLayer*, int);
	static auto func = wrapFunction(base::get() + 0x4702a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MPLobbyLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(MPLobbyLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4703c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MPLobbyLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(MPLobbyLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4703e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MPLobbyLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(MPLobbyLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x470400, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&MPLobbyLayer::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(MPLobbyLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4704d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MPLobbyLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MPLobbyLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MPLobbyLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x470420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MPLobbyLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MPLobbyLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(MPLobbyLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x4704f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MPLobbyLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MPLobbyLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(MPLobbyLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x470700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MPLobbyLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&MPLobbyLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(MPLobbyLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x4708a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(MusicBrowser*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x5d4090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicBrowser::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&MusicBrowser::update), this);
	using FunctionType = decltype(update(p0))(*)(MusicBrowser*, float);
	static auto func = wrapFunction(base::get() + 0x5d3510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicBrowser::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x5d4460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MusicBrowser::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicBrowser::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x5d4330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MusicBrowser::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&MusicBrowser::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(MusicBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x5d3ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&MusicBrowser::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(MusicBrowser*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x5d3df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&MusicBrowser::sliderEnded), this);
	using FunctionType = decltype(sliderEnded(p0))(*)(MusicBrowser*, Slider*);
	static auto func = wrapFunction(base::get() + 0x5d3690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&MusicBrowser::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(MusicBrowser*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x5d4010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto MusicBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicBrowser::getSelectedCellIdx), this);
	using FunctionType = decltype(getSelectedCellIdx())(*)(MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x5d4070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MusicBrowser::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MusicBrowser::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MusicBrowser*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5d4290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto OptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x75bcf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto OptionsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(OptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x75bf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(OptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x75d380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&OptionsLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(OptionsLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x75d3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SecretLayer2::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x478d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto SecretLayer2::onSubmit(cocos2d::CCObject* sender) -> decltype(onSubmit(sender)) {
	using FunctionType = decltype(onSubmit(sender))(*)(SecretLayer2*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x47a0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretLayer2::scene() -> decltype(scene()) {
	using FunctionType = decltype(scene())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x478cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretLayer2::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer2::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x478e30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer2::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer2::onExit), this);
	using FunctionType = decltype(onExit())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x47f0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer2::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer2::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer2*);
	static auto func = wrapFunction(base::get() + 0x47efc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer2::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer2::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SecretLayer2*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x47e0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer2::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer2::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SecretLayer2*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x47e190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer2::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer2::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SecretLayer2*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x47e260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer2::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SecretLayer2::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SecretLayer2*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x47e0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SecretLayer2::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretLayer2::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretLayer2*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x47cce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer3::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer3::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer3*);
	static auto func = wrapFunction(base::get() + 0x47f550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer3::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer3::onExit), this);
	using FunctionType = decltype(onExit())(*)(SecretLayer3*);
	static auto func = wrapFunction(base::get() + 0x4843a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer3::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer3::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer3*);
	static auto func = wrapFunction(base::get() + 0x484370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer3::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretLayer3::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretLayer3*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x484050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer4::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer4::init), this);
	using FunctionType = decltype(init())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x38e950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer4::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer4::onExit), this);
	using FunctionType = decltype(onExit())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x393150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer4::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretLayer4::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretLayer4*);
	static auto func = wrapFunction(base::get() + 0x393060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretLayer4::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer4::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SecretLayer4*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3921b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer4::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer4::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SecretLayer4*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x392270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer4::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SecretLayer4::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SecretLayer4*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x392340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretLayer4::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SecretLayer4::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SecretLayer4*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x392190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SecretLayer4::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretLayer4::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretLayer4*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x391980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SimplePlayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x349730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SimplePlayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SimplePlayer*, int);
	static auto func = wrapFunction(base::get() + 0x34e0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void SimplePlayer::setSecondColor(cocos2d::_ccColor3B const& color) {
		m_secondLayer->setColor(color);
		updateColors();
	}

auto SimplePlayer::updateColors() -> decltype(updateColors()) {
	using FunctionType = decltype(updateColors())(*)(SimplePlayer*);
	static auto func = wrapFunction(base::get() + 0x34cf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SimplePlayer::updatePlayerFrame(int p0, IconType p1) -> decltype(updatePlayerFrame(p0, p1)) {
	using FunctionType = decltype(updatePlayerFrame(p0, p1))(*)(SimplePlayer*, int, IconType);
	static auto func = wrapFunction(base::get() + 0x349a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SimplePlayer::createSpiderSprite(int p0) -> decltype(createSpiderSprite(p0)) {
	using FunctionType = decltype(createSpiderSprite(p0))(*)(SimplePlayer*, int);
	static auto func = wrapFunction(base::get() + 0x349850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

void SimplePlayer::enableCustomGlowColor(cocos2d::_ccColor3B const& color) {
		m_hasCustomGlowColor = true;
		m_glowColor = color;
	}

void SimplePlayer::disableCustomGlowColor() {
		m_hasCustomGlowColor = false;
	}

void SimplePlayer::setGlowOutline(cocos2d::ccColor3B color) {
		enableCustomGlowColor(color);
		m_hasGlowOutline = true;
		updateColors();
	}

void SimplePlayer::disableGlowOutline() {
		disableCustomGlowColor();
		m_hasGlowOutline = false;
		updateColors();
	}

auto SimplePlayer::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&SimplePlayer::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(SimplePlayer*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x34ece0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SimplePlayer::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&SimplePlayer::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(SimplePlayer*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x34e980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SlideInLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::init), this);
	using FunctionType = decltype(init())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26c340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::draw), this);
	using FunctionType = decltype(draw())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26ca70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SlideInLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(SlideInLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x26caa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SlideInLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SlideInLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(SlideInLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x26cb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SlideInLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SlideInLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(SlideInLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x26cac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SlideInLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&SlideInLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(SlideInLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x26cae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SlideInLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26c770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26c7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26c6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::enterLayer() -> decltype(enterLayer()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::enterLayer), this);
	using FunctionType = decltype(enterLayer())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26c740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&SlideInLayer::exitLayer), this);
	using FunctionType = decltype(exitLayer(p0))(*)(SlideInLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26c7f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SlideInLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&SlideInLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(SlideInLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x26c840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SlideInLayer::hideLayer(bool p0) -> decltype(hideLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&SlideInLayer::hideLayer), this);
	using FunctionType = decltype(hideLayer(p0))(*)(SlideInLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x26c930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SlideInLayer::layerVisible() -> decltype(layerVisible()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::layerVisible), this);
	using FunctionType = decltype(layerVisible())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26ca10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26ca30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::enterAnimFinished), this);
	using FunctionType = decltype(enterAnimFinished())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26ca00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::disableUI() -> decltype(disableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::disableUI), this);
	using FunctionType = decltype(disableUI())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26c700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SlideInLayer::enableUI() -> decltype(enableUI()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SlideInLayer::enableUI), this);
	using FunctionType = decltype(enableUI())(*)(SlideInLayer*);
	static auto func = wrapFunction(base::get() + 0x26c720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SupportLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SupportLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(SupportLayer*);
	static auto func = wrapFunction(base::get() + 0x376a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SupportLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&SupportLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(SupportLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x378320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SupportLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&SupportLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(SupportLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x378460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SupportLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&SupportLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(SupportLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x3782d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SupportLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SupportLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SupportLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x378710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCAlertCircle::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCAlertCircle::init), this);
	using FunctionType = decltype(init())(*)(CCAlertCircle*);
	static auto func = wrapFunction(base::get() + 0x169fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCAlertCircle::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCAlertCircle::draw), this);
	using FunctionType = decltype(draw())(*)(CCAlertCircle*);
	static auto func = wrapFunction(base::get() + 0x16a030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJChallengeDelegate::challengeStatusFinished() -> decltype(challengeStatusFinished()) {
	throw std::runtime_error("GJChallengeDelegate::challengeStatusFinished not implemented");
}

auto GJChallengeDelegate::challengeStatusFailed() -> decltype(challengeStatusFailed()) {
	throw std::runtime_error("GJChallengeDelegate::challengeStatusFailed not implemented");
}

auto ChallengesPage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x37aa70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ChallengesPage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ChallengesPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x37b610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ChallengesPage::updateTimers(float p0) -> decltype(updateTimers(p0)) {
	using FunctionType = decltype(updateTimers(p0))(*)(ChallengesPage*, float);
	static auto func = wrapFunction(base::get() + 0x37b650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ChallengesPage::createChallengeNode(int number, bool skipAnimation, float animLength, bool isNew) -> decltype(createChallengeNode(number, skipAnimation, animLength, isNew)) {
	using FunctionType = decltype(createChallengeNode(number, skipAnimation, animLength, isNew))(*)(ChallengesPage*, int, bool, float, bool);
	static auto func = wrapFunction(base::get() + 0x37b890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, number, skipAnimation, animLength, isNew);
}

auto ChallengesPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::init), this);
	using FunctionType = decltype(init())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x37abe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x37c280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x37c1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::show), this);
	using FunctionType = decltype(show())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x37c050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&ChallengesPage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(ChallengesPage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x37c1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ChallengesPage::challengeStatusFinished() -> decltype(challengeStatusFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::challengeStatusFinished), this);
	using FunctionType = decltype(challengeStatusFinished())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x37bb50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::challengeStatusFailed() -> decltype(challengeStatusFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ChallengesPage::challengeStatusFailed), this);
	using FunctionType = decltype(challengeStatusFailed())(*)(ChallengesPage*);
	static auto func = wrapFunction(base::get() + 0x37be60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ChallengesPage::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CurrencyRewardLayer*>::func(&ChallengesPage::currencyWillExit), this);
	using FunctionType = decltype(currencyWillExit(p0))(*)(ChallengesPage*, CurrencyRewardLayer*);
	static auto func = wrapFunction(base::get() + 0x37c3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ChallengeNode::create(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) -> decltype(create(challengeItem, challengesPage, isNew)) {
	using FunctionType = decltype(create(challengeItem, challengesPage, isNew))(*)(GJChallengeItem*, ChallengesPage*, bool);
	static auto func = wrapFunction(base::get() + 0x37bf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(challengeItem, challengesPage, isNew);
}

auto ChallengeNode::init(GJChallengeItem* challengeItem, ChallengesPage* challengesPage, bool isNew) -> decltype(init(challengeItem, challengesPage, isNew)) {
	using FunctionType = decltype(init(challengeItem, challengesPage, isNew))(*)(ChallengeNode*, GJChallengeItem*, ChallengesPage*, bool);
	static auto func = wrapFunction(base::get() + 0x37c510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, challengeItem, challengesPage, isNew);
}

auto ChallengeNode::onClaimReward(cocos2d::CCObject* sender) -> decltype(onClaimReward(sender)) {
	using FunctionType = decltype(onClaimReward(sender))(*)(ChallengeNode*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x37d120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSFXDelegate::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	throw std::runtime_error("CustomSFXDelegate::sfxObjectSelected not implemented");
}

auto CustomSFXDelegate::getActiveSFXID() -> decltype(getActiveSFXID()) {
	throw std::runtime_error("CustomSFXDelegate::getActiveSFXID not implemented");
}

auto CustomSFXDelegate::overridePlaySFX(SFXInfoObject* p0) -> decltype(overridePlaySFX(p0)) {
	throw std::runtime_error("CustomSFXDelegate::overridePlaySFX not implemented");
}

auto CustomSFXCell::loadFromObject(SFXInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(CustomSFXCell*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x2237a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSFXCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXCell::init), this);
	using FunctionType = decltype(init())(*)(CustomSFXCell*);
	static auto func = wrapFunction(base::get() + 0x232460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXCell::draw), this);
	using FunctionType = decltype(draw())(*)(CustomSFXCell*);
	static auto func = wrapFunction(base::get() + 0x232560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXCell::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXInfoObject*>::func(&CustomSFXCell::sfxObjectSelected), this);
	using FunctionType = decltype(sfxObjectSelected(p0))(*)(CustomSFXCell*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x232480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSFXCell::getActiveSFXID() -> decltype(getActiveSFXID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXCell::getActiveSFXID), this);
	using FunctionType = decltype(getActiveSFXID())(*)(CustomSFXCell*);
	static auto func = wrapFunction(base::get() + 0x232500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DrawGridLayer::loadTimeMarkers(gd::string p0) -> decltype(loadTimeMarkers(p0)) {
	using FunctionType = decltype(loadTimeMarkers(p0))(*)(DrawGridLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0xdb3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DrawGridLayer::removeFromGuides(GameObject* p0) -> decltype(removeFromGuides(p0)) {
	using FunctionType = decltype(removeFromGuides(p0))(*)(DrawGridLayer*, GameObject*);
	static auto func = wrapFunction(base::get() + 0xe5b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto DrawGridLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&DrawGridLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(DrawGridLayer*, float);
	static auto func = wrapFunction(base::get() + 0xf14b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto DrawGridLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DrawGridLayer::draw), this);
	using FunctionType = decltype(draw())(*)(DrawGridLayer*);
	static auto func = wrapFunction(base::get() + 0xf1640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ExtendedLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ExtendedLayer::init), this);
	using FunctionType = decltype(init())(*)(ExtendedLayer*);
	static auto func = wrapFunction(base::get() + 0x385200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ExtendedLayer::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&ExtendedLayer::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(ExtendedLayer*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x385210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJChestSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x1faf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJChestSprite::switchToState(ChestSpriteState p0, bool p1) -> decltype(switchToState(p0, p1)) {
	using FunctionType = decltype(switchToState(p0, p1))(*)(GJChestSprite*, ChestSpriteState, bool);
	static auto func = wrapFunction(base::get() + 0x1fc3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJChestSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJChestSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJChestSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x1fda20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJChestSprite::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&GJChestSprite::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(GJChestSprite*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1fd930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGroundLayer::create(int p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, int);
	static auto func = wrapFunction(base::get() + 0x5af5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJGroundLayer::init(int p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJGroundLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x5af6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGroundLayer::scaleGround(float p0) -> decltype(scaleGround(p0)) {
	using FunctionType = decltype(scaleGround(p0))(*)(GJGroundLayer*, float);
	static auto func = wrapFunction(base::get() + 0x5b0190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::updateShadows() -> decltype(updateShadows()) {
	using FunctionType = decltype(updateShadows())(*)(GJGroundLayer*);
	static auto func = wrapFunction(base::get() + 0x5b0420, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGroundLayer::positionGround(float p0) -> decltype(positionGround(p0)) {
	using FunctionType = decltype(positionGround(p0))(*)(GJGroundLayer*, float);
	static auto func = wrapFunction(base::get() + 0x5b06f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::toggleVisible01(bool p0) -> decltype(toggleVisible01(p0)) {
	using FunctionType = decltype(toggleVisible01(p0))(*)(GJGroundLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5b0040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::toggleVisible02(bool p0) -> decltype(toggleVisible02(p0)) {
	using FunctionType = decltype(toggleVisible02(p0))(*)(GJGroundLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5b0080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::updateLineBlend(bool p0) -> decltype(updateLineBlend(p0)) {
	using FunctionType = decltype(updateLineBlend(p0))(*)(GJGroundLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5b04b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::updateShadowXPos(float p0, float p1) -> decltype(updateShadowXPos(p0, p1)) {
	using FunctionType = decltype(updateShadowXPos(p0, p1))(*)(GJGroundLayer*, float, float);
	static auto func = wrapFunction(base::get() + 0x5b05f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGroundLayer::updateGround01Color(cocos2d::_ccColor3B p0) -> decltype(updateGround01Color(p0)) {
	using FunctionType = decltype(updateGround01Color(p0))(*)(GJGroundLayer*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x5affc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::updateGround02Color(cocos2d::_ccColor3B p0) -> decltype(updateGround02Color(p0)) {
	using FunctionType = decltype(updateGround02Color(p0))(*)(GJGroundLayer*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x5b0110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGroundLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGroundLayer::draw), this);
	using FunctionType = decltype(draw())(*)(GJGroundLayer*);
	static auto func = wrapFunction(base::get() + 0x5b06e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGroundLayer::showGround() -> decltype(showGround()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGroundLayer::showGround), this);
	using FunctionType = decltype(showGround())(*)(GJGroundLayer*);
	static auto func = wrapFunction(base::get() + 0x5b0500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGroundLayer::fadeInGround(float p0) -> decltype(fadeInGround(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJGroundLayer::fadeInGround), this);
	using FunctionType = decltype(fadeInGround(p0))(*)(GJGroundLayer*, float);
	static auto func = wrapFunction(base::get() + 0x5b0510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJGroundLayer::fadeOutGround(float p0) -> decltype(fadeOutGround(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&GJGroundLayer::fadeOutGround), this);
	using FunctionType = decltype(fadeOutGround(p0))(*)(GJGroundLayer*, float);
	static auto func = wrapFunction(base::get() + 0x5b06b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessageCell::loadFromMessage(GJUserMessage* p0) -> decltype(loadFromMessage(p0)) {
	using FunctionType = decltype(loadFromMessage(p0))(*)(GJMessageCell*, GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x22b1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJMessageCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMessageCell::init), this);
	using FunctionType = decltype(init())(*)(GJMessageCell*);
	static auto func = wrapFunction(base::get() + 0x236600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessageCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMessageCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJMessageCell*);
	static auto func = wrapFunction(base::get() + 0x236910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessageCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJMessageCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJMessageCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2369e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessageCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessageCell::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJMessageCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x236b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessageCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessageCell::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJMessageCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x236d40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessageCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJMessageCell::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJMessageCell*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x236eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRequestCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJRequestCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x22aa60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRequestCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRequestCell::init), this);
	using FunctionType = decltype(init())(*)(GJRequestCell*);
	static auto func = wrapFunction(base::get() + 0x235860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRequestCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRequestCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJRequestCell*);
	static auto func = wrapFunction(base::get() + 0x235b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRequestCell::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJRequestCell::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJRequestCell*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x235c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRequestCell::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJRequestCell::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJRequestCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x235e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRequestCell::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJRequestCell::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJRequestCell*, int, int);
	static auto func = wrapFunction(base::get() + 0x236010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRequestCell::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJRequestCell::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJRequestCell*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x236120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::initWithType(char const* p0, cocos2d::CCTexture2D* p1, bool p2) -> decltype(initWithType(p0, p1, p2)) {
	using FunctionType = decltype(initWithType(p0, p1, p2))(*)(CCAnimatedSprite*, char const*, cocos2d::CCTexture2D*, bool);
	static auto func = wrapFunction(base::get() + 0x32e2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CCAnimatedSprite::runAnimation(gd::string p0) -> decltype(runAnimation(p0)) {
	using FunctionType = decltype(runAnimation(p0))(*)(CCAnimatedSprite*, gd::string);
	static auto func = wrapFunction(base::get() + 0x32eda0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCAnimatedSprite::tweenToAnimation(gd::string p0, float p1) -> decltype(tweenToAnimation(p0, p1)) {
	using FunctionType = decltype(tweenToAnimation(p0, p1))(*)(CCAnimatedSprite*, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x32eeb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCAnimatedSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCAnimatedSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCAnimatedSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x32f2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::setColor(cocos2d::_ccColor3B const& p0) -> decltype(setColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&CCAnimatedSprite::setColor), this);
	using FunctionType = decltype(setColor(p0))(*)(CCAnimatedSprite*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x32f380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&CCAnimatedSprite::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(CCAnimatedSprite*, char const*);
	static auto func = wrapFunction(base::get() + 0x32f2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCAnimatedSprite::animationFinishedO(cocos2d::CCObject* p0) -> decltype(animationFinishedO(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&CCAnimatedSprite::animationFinishedO), this);
	using FunctionType = decltype(animationFinishedO(p0))(*)(CCAnimatedSprite*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x32f280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRobotSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x5a0cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJRobotSprite::init(int p0, gd::string p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJRobotSprite*, int, gd::string);
	static auto func = wrapFunction(base::get() + 0x5a0e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJRobotSprite::updateFrame(int p0) -> decltype(updateFrame(p0)) {
	using FunctionType = decltype(updateFrame(p0))(*)(GJRobotSprite*, int);
	static auto func = wrapFunction(base::get() + 0x5a13a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRobotSprite::updateColors() -> decltype(updateColors()) {
	using FunctionType = decltype(updateColors())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x5a1bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRobotSprite::updateColor01(cocos2d::_ccColor3B p0) -> decltype(updateColor01(p0)) {
	using FunctionType = decltype(updateColor01(p0))(*)(GJRobotSprite*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x5a1bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRobotSprite::updateColor02(cocos2d::_ccColor3B p0) -> decltype(updateColor02(p0)) {
	using FunctionType = decltype(updateColor02(p0))(*)(GJRobotSprite*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x5a1ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRobotSprite::updateGlowColor(cocos2d::_ccColor3B p0, bool p1) -> decltype(updateGlowColor(p0, p1)) {
	using FunctionType = decltype(updateGlowColor(p0, p1))(*)(GJRobotSprite*, cocos2d::_ccColor3B, bool);
	static auto func = wrapFunction(base::get() + 0x5a1f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJRobotSprite::hideGlow() -> decltype(hideGlow()) {
	using FunctionType = decltype(hideGlow())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x5a1b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRobotSprite::showGlow() -> decltype(showGlow()) {
	using FunctionType = decltype(showGlow())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x5a1b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJRobotSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&GJRobotSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(GJRobotSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x5a1f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRobotSprite::hideSecondary() -> decltype(hideSecondary()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRobotSprite::hideSecondary), this);
	using FunctionType = decltype(hideSecondary())(*)(GJRobotSprite*);
	static auto func = wrapFunction(base::get() + 0x5a20a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSmartPrefab::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(GJSmartPrefab*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x4077a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartPrefab::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJSmartPrefab::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJSmartPrefab*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x4078e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSmartPrefab::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSmartPrefab::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJSmartPrefab*);
	static auto func = wrapFunction(base::get() + 0x407790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSongBrowser::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x5c3a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

GJSongBrowser::~GJSongBrowser() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x5c3b90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) GJSongBrowser(geode::CutoffConstructor, sizeof(GJSongBrowser));
	CCDestructor::lock(this) = true;
}

auto GJSongBrowser::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::init), this);
	using FunctionType = decltype(init())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x5c3e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSongBrowser::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x5c4150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSongBrowser::exitLayer(cocos2d::CCObject* p0) -> decltype(exitLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCObject*>::func(&GJSongBrowser::exitLayer), this);
	using FunctionType = decltype(exitLayer(p0))(*)(GJSongBrowser*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5c4120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSongBrowser::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJSongBrowser::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJSongBrowser*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5c46e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSongBrowser::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&GJSongBrowser::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(GJSongBrowser*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x5c47c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto GJSongBrowser::getSelectedCellIdx() -> decltype(getSelectedCellIdx()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSongBrowser::getSelectedCellIdx), this);
	using FunctionType = decltype(getSelectedCellIdx())(*)(GJSongBrowser*);
	static auto func = wrapFunction(base::get() + 0x5c4820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUserMessage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x52d230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJUserMessage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUserMessage::init), this);
	using FunctionType = decltype(init())(*)(GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x52d2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ItemInfoPopup::create(int p0, UnlockType p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x34d550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto ItemInfoPopup::init(int p0, UnlockType p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(ItemInfoPopup*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x34f980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ItemInfoPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(ItemInfoPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x350f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ItemInfoPopup::nameForUnlockType(int p0, UnlockType p1) -> decltype(nameForUnlockType(p0, p1)) {
	using FunctionType = decltype(nameForUnlockType(p0, p1))(*)(ItemInfoPopup*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x350c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto ItemInfoPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ItemInfoPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ItemInfoPopup*);
	static auto func = wrapFunction(base::get() + 0x350fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelListCell::loadFromList(GJLevelList* p0) -> decltype(loadFromList(p0)) {
	using FunctionType = decltype(loadFromList(p0))(*)(LevelListCell*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x224660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelListCell::init), this);
	using FunctionType = decltype(init())(*)(LevelListCell*);
	static auto func = wrapFunction(base::get() + 0x237590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelListCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelListCell::draw), this);
	using FunctionType = decltype(draw())(*)(LevelListCell*);
	static auto func = wrapFunction(base::get() + 0x2376d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuGameLayer::resetPlayer() -> decltype(resetPlayer()) {
	using FunctionType = decltype(resetPlayer())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4d52a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuGameLayer::destroyPlayer() -> decltype(destroyPlayer()) {
	using FunctionType = decltype(destroyPlayer())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4d5e50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MenuGameLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&MenuGameLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(MenuGameLayer*, float);
	static auto func = wrapFunction(base::get() + 0x4d5ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MenuGameLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuGameLayer::init), this);
	using FunctionType = decltype(init())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4d4940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MenuGameLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MenuGameLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(MenuGameLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d6050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MenuGameLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MenuGameLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(MenuGameLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d6170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MenuGameLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MenuGameLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(MenuGameLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d6190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MenuGameLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MenuGameLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(MenuGameLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4d61b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MenuGameLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MenuGameLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(MenuGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4d61f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ObjectManager::init), this);
	using FunctionType = decltype(init())(*)(ObjectManager*);
	static auto func = wrapFunction(base::get() + 0x7574e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectToolbox::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x62daa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto ObjectToolbox::intKeyToFrame(int objectID) -> decltype(intKeyToFrame(objectID)) {
	using FunctionType = decltype(intKeyToFrame(objectID))(*)(ObjectToolbox*, int);
	static auto func = wrapFunction(base::get() + 0x6dda40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, objectID);
}

auto ObjectToolbox::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ObjectToolbox::init), this);
	using FunctionType = decltype(init())(*)(ObjectToolbox*);
	static auto func = wrapFunction(base::get() + 0x62dbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupEndPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupEndPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x62d190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupEndPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupEndPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupEndPopup*);
	static auto func = wrapFunction(base::get() + 0x62ce70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupEndPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupEndPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupEndPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x62d040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupEndPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupEndPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupEndPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x62d080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupAudioTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAudioTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAudioTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4932c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SFXBrowserDelegate::sfxBrowserClosed(SFXBrowser* p0) -> decltype(sfxBrowserClosed(p0)) {
	throw std::runtime_error("SFXBrowserDelegate::sfxBrowserClosed not implemented");
}

auto SetupSFXPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupSFXPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x495bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupSFXPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupSFXPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x495740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupSFXPopup::pageChanged() -> decltype(pageChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSFXPopup::pageChanged), this);
	using FunctionType = decltype(pageChanged())(*)(SetupSFXPopup*);
	static auto func = wrapFunction(base::get() + 0x4956f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSFXPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupSFXPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupSFXPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x495a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupSFXPopup::sfxObjectSelected(SFXInfoObject* p0) -> decltype(sfxObjectSelected(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXInfoObject*>::func(&SetupSFXPopup::sfxObjectSelected), this);
	using FunctionType = decltype(sfxObjectSelected(p0))(*)(SetupSFXPopup*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x4959b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSFXPopup::getActiveSFXID() -> decltype(getActiveSFXID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSFXPopup::getActiveSFXID), this);
	using FunctionType = decltype(getActiveSFXID())(*)(SetupSFXPopup*);
	static auto func = wrapFunction(base::get() + 0x4959d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSFXPopup::overridePlaySFX(SFXInfoObject* p0) -> decltype(overridePlaySFX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXInfoObject*>::func(&SetupSFXPopup::overridePlaySFX), this);
	using FunctionType = decltype(overridePlaySFX(p0))(*)(SetupSFXPopup*, SFXInfoObject*);
	static auto func = wrapFunction(base::get() + 0x4959f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSFXPopup::sfxBrowserClosed(SFXBrowser* p0) -> decltype(sfxBrowserClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SFXBrowser*>::func(&SetupSFXPopup::sfxBrowserClosed), this);
	using FunctionType = decltype(sfxBrowserClosed(p0))(*)(SetupSFXPopup*, SFXBrowser*);
	static auto func = wrapFunction(base::get() + 0x495c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongInfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SongInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x5c67d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialLayer::init), this);
	using FunctionType = decltype(init())(*)(TutorialLayer*);
	static auto func = wrapFunction(base::get() + 0x4b7b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(TutorialLayer*);
	static auto func = wrapFunction(base::get() + 0x4b8560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(TutorialPopup*);
	static auto func = wrapFunction(base::get() + 0x599b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TutorialPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TutorialPopup::show), this);
	using FunctionType = decltype(show())(*)(TutorialPopup*);
	static auto func = wrapFunction(base::get() + 0x599c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementBar::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&AchievementBar::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(AchievementBar*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x5de590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongDelegate::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	throw std::runtime_error("CustomSongDelegate::songIDChanged not implemented");
}

auto CustomSongDelegate::getActiveSongID() -> decltype(getActiveSongID()) {
	throw std::runtime_error("CustomSongDelegate::getActiveSongID not implemented");
}

auto CustomSongCell::onDelete(cocos2d::CCObject* sender) -> decltype(onDelete(sender)) {
	using FunctionType = decltype(onDelete(sender))(*)(CustomSongCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x232080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongCell::loadFromObject(SongInfoObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(CustomSongCell*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x222fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::init), this);
	using FunctionType = decltype(init())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x232060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::draw), this);
	using FunctionType = decltype(draw())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x232270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongCell::songIDChanged), this);
	using FunctionType = decltype(songIDChanged(p0))(*)(CustomSongCell*, int);
	static auto func = wrapFunction(base::get() + 0x232150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongCell::getActiveSongID() -> decltype(getActiveSongID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::getActiveSongID), this);
	using FunctionType = decltype(getActiveSongID())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x2321d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::getSongFileName() -> decltype(getSongFileName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::getSongFileName), this);
	using FunctionType = decltype(getSongFileName())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x232230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongCell::getLevelSettings() -> decltype(getLevelSettings()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongCell::getLevelSettings), this);
	using FunctionType = decltype(getLevelSettings())(*)(CustomSongCell*);
	static auto func = wrapFunction(base::get() + 0x232250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletSprite::create(GauntletType p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GauntletType, bool);
	static auto func = wrapFunction(base::get() + 0x3723e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GauntletSprite::addLockedSprite() -> decltype(addLockedSprite()) {
	using FunctionType = decltype(addLockedSprite())(*)(GauntletSprite*);
	static auto func = wrapFunction(base::get() + 0x372ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GauntletSprite::addNormalSprite() -> decltype(addNormalSprite()) {
	using FunctionType = decltype(addNormalSprite())(*)(GauntletSprite*);
	static auto func = wrapFunction(base::get() + 0x372c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto DownloadMessageDelegate::downloadMessageFinished(GJUserMessage* p0) -> decltype(downloadMessageFinished(p0)) {
	throw std::runtime_error("DownloadMessageDelegate::downloadMessageFinished not implemented");
}

auto DownloadMessageDelegate::downloadMessageFailed(int p0) -> decltype(downloadMessageFailed(p0)) {
	throw std::runtime_error("DownloadMessageDelegate::downloadMessageFailed not implemented");
}

auto GJMessagePopup::loadFromGJMessage(GJUserMessage* p0) -> decltype(loadFromGJMessage(p0)) {
	using FunctionType = decltype(loadFromGJMessage(p0))(*)(GJMessagePopup*, GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x283510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJMessagePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMessagePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJMessagePopup*);
	static auto func = wrapFunction(base::get() + 0x284240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMessagePopup::downloadMessageFinished(GJUserMessage* p0) -> decltype(downloadMessageFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJUserMessage*>::func(&GJMessagePopup::downloadMessageFinished), this);
	using FunctionType = decltype(downloadMessageFinished(p0))(*)(GJMessagePopup*, GJUserMessage*);
	static auto func = wrapFunction(base::get() + 0x2842b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::downloadMessageFailed(int p0) -> decltype(downloadMessageFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJMessagePopup::downloadMessageFailed), this);
	using FunctionType = decltype(downloadMessageFailed(p0))(*)(GJMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x284370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessagePopup::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(GJMessagePopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x284410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessagePopup::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&GJMessagePopup::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(GJMessagePopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x2845d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJMessagePopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJMessagePopup::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJMessagePopup*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2846a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMessagePopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJMessagePopup::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJMessagePopup*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2847a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJOptionsLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x279be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJOptionsLayer::didToggleGV(gd::string p0) -> decltype(didToggleGV(p0)) {
	using FunctionType = decltype(didToggleGV(p0))(*)(GJOptionsLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x250090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJOptionsLayer::countForPage(int p0) -> decltype(countForPage(p0)) {
	using FunctionType = decltype(countForPage(p0))(*)(GJOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x27b230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJOptionsLayer::objectsForPage(int p0) -> decltype(objectsForPage(p0)) {
	using FunctionType = decltype(objectsForPage(p0))(*)(GJOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x27aea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJOptionsLayer::addToggleInternal(char const* p0, int p1, bool p2, char const* p3) -> decltype(addToggleInternal(p0, p1, p2, p3)) {
	using FunctionType = decltype(addToggleInternal(p0, p1, p2, p3))(*)(GJOptionsLayer*, char const*, int, bool, char const*);
	static auto func = wrapFunction(base::get() + 0x27a4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto GJOptionsLayer::incrementCountForPage(int p0) -> decltype(incrementCountForPage(p0)) {
	using FunctionType = decltype(incrementCountForPage(p0))(*)(GJOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x27ad90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(GJOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x27a390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(GJOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2923c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRewardObject::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(GJRewardObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8a800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJRewardObject::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJRewardObject::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJRewardObject*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x8a910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRewardObject::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRewardObject::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJRewardObject*);
	static auto func = wrapFunction(base::get() + 0x8a990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScaleControl::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0xf5e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJScaleControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJScaleControl::init), this);
	using FunctionType = decltype(init())(*)(GJScaleControl*);
	static auto func = wrapFunction(base::get() + 0x55080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJScaleControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x55690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x55880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x55d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJScaleControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJScaleControl::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(GJScaleControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x55e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSpiderSprite::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x5a22a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto HSVWidgetDelegate::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::_ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	throw std::runtime_error("HSVWidgetDelegate::hsvPopupClosed not implemented");
}

auto HSVWidgetDelegate::hsvChanged(ConfigureHSVWidget* p0) -> decltype(hsvChanged(p0)) {
	throw std::runtime_error("HSVWidgetDelegate::hsvChanged not implemented");
}

auto HSVLiveOverlay::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HSVLiveOverlay::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(HSVLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x249110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto HSVLiveOverlay::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HSVLiveOverlay::show), this);
	using FunctionType = decltype(show())(*)(HSVLiveOverlay*);
	static auto func = wrapFunction(base::get() + 0x2491c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto HSVLiveOverlay::hsvChanged(ConfigureHSVWidget* p0) -> decltype(hsvChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureHSVWidget*>::func(&HSVLiveOverlay::hsvChanged), this);
	using FunctionType = decltype(hsvChanged(p0))(*)(HSVLiveOverlay*, ConfigureHSVWidget*);
	static auto func = wrapFunction(base::get() + 0x249290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto HSVWidgetPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&HSVWidgetPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(HSVWidgetPopup*);
	static auto func = wrapFunction(base::get() + 0x40ec10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaLayer::init), this);
	using FunctionType = decltype(init())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x255640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelAreaLayer*);
	static auto func = wrapFunction(base::get() + 0x257750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&LevelAreaLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(LevelAreaLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x257500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SelectListIconDelegate::iconSelectClosed(SelectListIconLayer* p0) -> decltype(iconSelectClosed(p0)) {
	throw std::runtime_error("SelectListIconDelegate::iconSelectClosed not implemented");
}

auto LevelListLayer::init(GJLevelList* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelListLayer*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x33a9a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

LevelListLayer::~LevelListLayer() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x33a830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) LevelListLayer(geode::CutoffConstructor, sizeof(LevelListLayer));
	CCDestructor::lock(this) = true;
}

auto LevelListLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelListLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x33e710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelListLayer::shareCommentClosed(gd::string p0, ShareCommentLayer* p1) -> decltype(shareCommentClosed(p0, p1)) {
	using FunctionType = decltype(shareCommentClosed(p0, p1))(*)(LevelListLayer*, gd::string, ShareCommentLayer*);
	static auto func = wrapFunction(base::get() + 0x33ed50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto LevelListLayer::scene(GJLevelList* p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(LevelListLayer*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x33a8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelListLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelListLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x33dbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelListLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelListLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(LevelListLayer*);
	static auto func = wrapFunction(base::get() + 0x33dc10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelListLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&LevelListLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(LevelListLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x33df90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelListLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&LevelListLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(LevelListLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x33e1d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelListLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelListLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x33e9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::setIDPopupClosed(SetIDPopup* p0, int p1) -> decltype(setIDPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SetIDPopup*, int>::func(&LevelListLayer::setIDPopupClosed), this);
	using FunctionType = decltype(setIDPopupClosed(p0, p1))(*)(LevelListLayer*, SetIDPopup*, int);
	static auto func = wrapFunction(base::get() + 0x33e5b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelListLayer::updateResultArray(cocos2d::CCArray* p0) -> decltype(updateResultArray(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*>::func(&LevelListLayer::updateResultArray), this);
	using FunctionType = decltype(updateResultArray(p0))(*)(LevelListLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x33e6f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&LevelListLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(LevelListLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x33e200, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto LevelListLayer::likedItem(LikeItemType p0, int p1, bool p2) -> decltype(likedItem(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<LikeItemType, int, bool>::func(&LevelListLayer::likedItem), this);
	using FunctionType = decltype(likedItem(p0, p1, p2))(*)(LevelListLayer*, LikeItemType, int, bool);
	static auto func = wrapFunction(base::get() + 0x33ee20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto LevelListLayer::iconSelectClosed(SelectListIconLayer* p0) -> decltype(iconSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectListIconLayer*>::func(&LevelListLayer::iconSelectClosed), this);
	using FunctionType = decltype(iconSelectClosed(p0))(*)(LevelListLayer*, SelectListIconLayer*);
	static auto func = wrapFunction(base::get() + 0x33f060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::levelListDeleteFinished(int p0) -> decltype(levelListDeleteFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelListLayer::levelListDeleteFinished), this);
	using FunctionType = decltype(levelListDeleteFinished(p0))(*)(LevelListLayer*, int);
	static auto func = wrapFunction(base::get() + 0x33f1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::levelListDeleteFailed(int p0) -> decltype(levelListDeleteFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelListLayer::levelListDeleteFailed), this);
	using FunctionType = decltype(levelListDeleteFailed(p0))(*)(LevelListLayer*, int);
	static auto func = wrapFunction(base::get() + 0x33f2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelListLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(LevelListLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x33f5c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelListLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(LevelListLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x33f3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelListLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&LevelListLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(LevelListLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x33f690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ListButtonPage::create(cocos2d::CCArray* p0, cocos2d::CCPoint p1, int p2, int p3, float p4, float p5, float p6) -> decltype(create(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6))(*)(cocos2d::CCArray*, cocos2d::CCPoint, int, int, float, float, float);
	static auto func = wrapFunction(base::get() + 0x3d17f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6);
}

auto ListButtonPage::init(cocos2d::CCArray* p0, cocos2d::CCPoint p1, int p2, int p3, float p4, float p5, float p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(ListButtonPage*, cocos2d::CCArray*, cocos2d::CCPoint, int, int, float, float, float);
	static auto func = wrapFunction(base::get() + 0x3d1ad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto MapSelectLayer::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&MapSelectLayer::update), this);
	using FunctionType = decltype(update(p0))(*)(MapSelectLayer*, float);
	static auto func = wrapFunction(base::get() + 0x246fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MapSelectLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapSelectLayer::init), this);
	using FunctionType = decltype(init())(*)(MapSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x2460d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapSelectLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapSelectLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(MapSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x2472a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapSelectLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MapSelectLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(MapSelectLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x247920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MapSelectLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MapSelectLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(MapSelectLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x247a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MapSelectLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MapSelectLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(MapSelectLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x247c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MapSelectLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&MapSelectLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(MapSelectLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x247d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MapSelectLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapSelectLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(MapSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x247d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MapSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MapSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x2471c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MapSelectLayer::scrollWheel(float p0, float p1) -> decltype(scrollWheel(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, float>::func(&MapSelectLayer::scrollWheel), this);
	using FunctionType = decltype(scrollWheel(p0, p1))(*)(MapSelectLayer*, float, float);
	static auto func = wrapFunction(base::get() + 0x246da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateDemonLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x261c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto RateDemonLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(RateDemonLayer*, int);
	static auto func = wrapFunction(base::get() + 0x261df0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RateDemonLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RateDemonLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RateDemonLayer*);
	static auto func = wrapFunction(base::get() + 0x2629a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RateDemonLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateDemonLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(RateDemonLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x262660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateDemonLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateDemonLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(RateDemonLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x262750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateDemonLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&RateDemonLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(RateDemonLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2628c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RateLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RateLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RateLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x5340a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RateStarsLayer::create(int p0, bool p1, bool p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x2697f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto RateStarsLayer::init(int p0, bool p1, bool p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(RateStarsLayer*, int, bool, bool);
	static auto func = wrapFunction(base::get() + 0x269980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto RateStarsLayer::onToggleCoins(cocos2d::CCObject* sender) -> decltype(onToggleCoins(sender)) {
	using FunctionType = decltype(onToggleCoins(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26a1f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::onRate(cocos2d::CCObject* sender) -> decltype(onRate(sender)) {
	using FunctionType = decltype(onRate(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26a2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26a270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::onFeature(cocos2d::CCObject* sender) -> decltype(onFeature(sender)) {
	using FunctionType = decltype(onFeature(sender))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26a240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto RateStarsLayer::selectRating(cocos2d::CCObject* p0) -> decltype(selectRating(p0)) {
	using FunctionType = decltype(selectRating(p0))(*)(RateStarsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x26a0a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto RateStarsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RateStarsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RateStarsLayer*);
	static auto func = wrapFunction(base::get() + 0x26a730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RateStarsLayer::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateStarsLayer::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(RateStarsLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x26a3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateStarsLayer::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&RateStarsLayer::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(RateStarsLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x26a4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto RateStarsLayer::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&RateStarsLayer::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(RateStarsLayer*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x26a650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetFolderPopup::create(int p0, bool p1, gd::string p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(int, bool, gd::string);
	static auto func = wrapFunction(base::get() + 0x289770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto SetFolderPopup::init(int p0, bool p1, gd::string p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(SetFolderPopup*, int, bool, gd::string);
	static auto func = wrapFunction(base::get() + 0x289960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto SetFolderPopup::setTextPopupClosed(SetTextPopup* p0, gd::string p1) -> decltype(setTextPopupClosed(p0, p1)) {
	using FunctionType = decltype(setTextPopupClosed(p0, p1))(*)(SetFolderPopup*, SetTextPopup*, gd::string);
	static auto func = wrapFunction(base::get() + 0x28a270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetFolderPopup::valueChanged() -> decltype(valueChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetFolderPopup::valueChanged), this);
	using FunctionType = decltype(valueChanged())(*)(SetFolderPopup*);
	static auto func = wrapFunction(base::get() + 0x289e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetItemIDLayer::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetItemIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x967f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetItemIDLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetItemIDLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x96a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetItemIDLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetItemIDLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetItemIDLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x96910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMGTrigger::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupMGTrigger*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e27f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupMGTrigger::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupMGTrigger::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupMGTrigger*);
	static auto func = wrapFunction(base::get() + 0x4e1f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupMGTrigger::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupMGTrigger::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupMGTrigger*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4e2590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupMGTrigger::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupMGTrigger::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupMGTrigger*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x4e2250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto ShareListLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareListLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareListLayer*);
	static auto func = wrapFunction(base::get() + 0x342090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SongSelectNode::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SongSelectNode*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1f7c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SongSelectNode::customSongLayerClosed() -> decltype(customSongLayerClosed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::customSongLayerClosed), this);
	using FunctionType = decltype(customSongLayerClosed())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x1f7d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::songIDChanged(int p0) -> decltype(songIDChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&SongSelectNode::songIDChanged), this);
	using FunctionType = decltype(songIDChanged(p0))(*)(SongSelectNode*, int);
	static auto func = wrapFunction(base::get() + 0x1f7d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongSelectNode::getActiveSongID() -> decltype(getActiveSongID()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getActiveSongID), this);
	using FunctionType = decltype(getActiveSongID())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x1f7da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::getSongFileName() -> decltype(getSongFileName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getSongFileName), this);
	using FunctionType = decltype(getSongFileName())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x1f7dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongSelectNode::getLevelSettings() -> decltype(getLevelSettings()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongSelectNode::getLevelSettings), this);
	using FunctionType = decltype(getLevelSettings())(*)(SongSelectNode*);
	static auto func = wrapFunction(base::get() + 0x1f7f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UIOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(UIOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28f890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UIOptionsLayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x290010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2901e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x290380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UIOptionsLayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(UIOptionsLayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2904c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UIOptionsLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(UIOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x290500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UIOptionsLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&UIOptionsLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(UIOptionsLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x28fa20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UIOptionsLayer::getValue(int p0) -> decltype(getValue(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&UIOptionsLayer::getValue), this);
	using FunctionType = decltype(getValue(p0))(*)(UIOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x28fd30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto WorldLevelPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&WorldLevelPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(WorldLevelPage*);
	static auto func = wrapFunction(base::get() + 0x3a5010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto WorldLevelPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&WorldLevelPage::show), this);
	using FunctionType = decltype(show())(*)(WorldLevelPage*);
	static auto func = wrapFunction(base::get() + 0x3a4ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementCell::init), this);
	using FunctionType = decltype(init())(*)(AchievementCell*);
	static auto func = wrapFunction(base::get() + 0x22d070, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementCell::draw), this);
	using FunctionType = decltype(draw())(*)(AchievementCell*);
	static auto func = wrapFunction(base::get() + 0x22d110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto BitmapFontCache::sharedFontCache() -> decltype(sharedFontCache()) {
	using FunctionType = decltype(sharedFontCache())(*)(BitmapFontCache*);
	static auto func = wrapFunction(base::get() + 0x1fde50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto BitmapFontCache::fontWithConfigFile(char const* p0, float p1) -> decltype(fontWithConfigFile(p0, p1)) {
	using FunctionType = decltype(fontWithConfigFile(p0, p1))(*)(BitmapFontCache*, char const*, float);
	static auto func = wrapFunction(base::get() + 0x1fdff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CCNodeContainer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCNodeContainer::init), this);
	using FunctionType = decltype(init())(*)(CCNodeContainer*);
	static auto func = wrapFunction(base::get() + 0x150e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCNodeContainer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCNodeContainer::visit), this);
	using FunctionType = decltype(visit())(*)(CCNodeContainer*);
	static auto func = wrapFunction(base::get() + 0x150e70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteWithHue::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::draw), this);
	using FunctionType = decltype(draw())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x5b6340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0) -> decltype(initWithTexture(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*>::func(&CCSpriteWithHue::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0))(*)(CCSpriteWithHue*, cocos2d::CCTexture2D*);
	static auto func = wrapFunction(base::get() + 0x5b5c10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1) -> decltype(initWithTexture(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&>::func(&CCSpriteWithHue::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1))(*)(CCSpriteWithHue*, cocos2d::CCTexture2D*, cocos2d::CCRect const&);
	static auto func = wrapFunction(base::get() + 0x5b5c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCSpriteWithHue::initWithTexture(cocos2d::CCTexture2D* p0, cocos2d::CCRect const& p1, bool p2) -> decltype(initWithTexture(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool>::func(&CCSpriteWithHue::initWithTexture), this);
	using FunctionType = decltype(initWithTexture(p0, p1, p2))(*)(CCSpriteWithHue*, cocos2d::CCTexture2D*, cocos2d::CCRect const&, bool);
	static auto func = wrapFunction(base::get() + 0x5b59d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto CCSpriteWithHue::initWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(initWithSpriteFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&CCSpriteWithHue::initWithSpriteFrame), this);
	using FunctionType = decltype(initWithSpriteFrame(p0))(*)(CCSpriteWithHue*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x5b5ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCSpriteWithHue::getShaderName() -> decltype(getShaderName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::getShaderName), this);
	using FunctionType = decltype(getShaderName())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x5b5520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteWithHue::shaderBody() -> decltype(shaderBody()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::shaderBody), this);
	using FunctionType = decltype(shaderBody())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x5b5de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteWithHue::updateColor() -> decltype(updateColor()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteWithHue::updateColor), this);
	using FunctionType = decltype(updateColor())(*)(CCSpriteWithHue*);
	static auto func = wrapFunction(base::get() + 0x5b5e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXWidget::init(SFXInfoObject* p0, CustomSFXDelegate* p1, bool p2, bool p3, bool p4, bool p5, bool p6) -> decltype(init(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6))(*)(CustomSFXWidget*, SFXInfoObject*, CustomSFXDelegate*, bool, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x5a77d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto CustomSFXWidget::updateSFXInfo() -> decltype(updateSFXInfo()) {
	using FunctionType = decltype(updateSFXInfo())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x5a8ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSFXWidget::downloadSFXFinished(int p0) -> decltype(downloadSFXFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSFXWidget::downloadSFXFinished), this);
	using FunctionType = decltype(downloadSFXFinished(p0))(*)(CustomSFXWidget*, int);
	static auto func = wrapFunction(base::get() + 0x5a9940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSFXWidget::downloadSFXFailed(int p0, GJSongError p1) -> decltype(downloadSFXFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSFXWidget::downloadSFXFailed), this);
	using FunctionType = decltype(downloadSFXFailed(p0, p1))(*)(CustomSFXWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x5a99e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSFXWidget::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSFXWidget::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(CustomSFXWidget*);
	static auto func = wrapFunction(base::get() + 0x5a98d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSFXWidget::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CustomSFXWidget::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CustomSFXWidget*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5a9bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MusicBrowserDelegate::musicBrowserClosed(MusicBrowser* p0) -> decltype(musicBrowserClosed(p0)) {
	throw std::runtime_error("MusicBrowserDelegate::musicBrowserClosed not implemented");
}

auto CustomSongLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CustomSongLayer*);
	static auto func = wrapFunction(base::get() + 0x1f50c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongLayer::show), this);
	using FunctionType = decltype(show())(*)(CustomSongLayer*);
	static auto func = wrapFunction(base::get() + 0x1f51a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomSongLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CustomSongLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f4c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomSongLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(CustomSongLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f4c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomSongLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(CustomSongLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f4bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&CustomSongLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(CustomSongLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x1f4cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomSongLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(CustomSongLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1f4d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::dropDownLayerWillClose(GJDropDownLayer* p0) -> decltype(dropDownLayerWillClose(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJDropDownLayer*>::func(&CustomSongLayer::dropDownLayerWillClose), this);
	using FunctionType = decltype(dropDownLayerWillClose(p0))(*)(CustomSongLayer*, GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x1f4f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongLayer::musicBrowserClosed(MusicBrowser* p0) -> decltype(musicBrowserClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<MusicBrowser*>::func(&CustomSongLayer::musicBrowserClosed), this);
	using FunctionType = decltype(musicBrowserClosed(p0))(*)(CustomSongLayer*, MusicBrowser*);
	static auto func = wrapFunction(base::get() + 0x1f5010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndPortalObject::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x379e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto EndPortalObject::updateColors(cocos2d::_ccColor3B p0) -> decltype(updateColors(p0)) {
	using FunctionType = decltype(updateColors(p0))(*)(EndPortalObject*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x37a210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndPortalObject::triggerObject(GJBaseGameLayer* p0) -> decltype(triggerObject(p0)) {
	using FunctionType = decltype(triggerObject(p0))(*)(EndPortalObject*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x37a2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto EndPortalObject::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EndPortalObject::init), this);
	using FunctionType = decltype(init())(*)(EndPortalObject*);
	static auto func = wrapFunction(base::get() + 0x379ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EndPortalObject::setPosition(cocos2d::CCPoint const& p0) -> decltype(setPosition(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint const&>::func(&EndPortalObject::setPosition), this);
	using FunctionType = decltype(setPosition(p0))(*)(EndPortalObject*, cocos2d::CCPoint const&);
	static auto func = wrapFunction(base::get() + 0x37a3e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EndPortalObject::setVisible(bool p0) -> decltype(setVisible(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&EndPortalObject::setVisible), this);
	using FunctionType = decltype(setVisible(p0))(*)(EndPortalObject*, bool);
	static auto func = wrapFunction(base::get() + 0x37a4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ExplodeItemNode::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&ExplodeItemNode::update), this);
	using FunctionType = decltype(update(p0))(*)(ExplodeItemNode*, float);
	static auto func = wrapFunction(base::get() + 0x1f3560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FileSaveManager::init() -> decltype(init()) {
	throw std::runtime_error("FileSaveManager::init not implemented");
}

auto FileSaveManager::firstLoad() -> decltype(firstLoad()) {
	throw std::runtime_error("FileSaveManager::firstLoad not implemented");
}

auto FindObjectPopup::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FindObjectPopup::init), this);
	using FunctionType = decltype(init())(*)(FindObjectPopup*);
	static auto func = wrapFunction(base::get() + 0x289330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FMODAudioEngine::playEffect(gd::string p0) -> decltype(playEffect(p0)) {
	using FunctionType = decltype(playEffect(p0))(*)(FMODAudioEngine*, gd::string);
	static auto func = wrapFunction(base::get() + 0x3c24f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::playEffect(gd::string p0, float p1, float p2, float p3) -> decltype(playEffect(p0, p1, p2, p3)) {
	using FunctionType = decltype(playEffect(p0, p1, p2, p3))(*)(FMODAudioEngine*, gd::string, float, float, float);
	static auto func = wrapFunction(base::get() + 0x3c2560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto FMODAudioEngine::resumeAudio() -> decltype(resumeAudio()) {
	using FunctionType = decltype(resumeAudio())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bc1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::fadeOutMusic(float p0, int p1) -> decltype(fadeOutMusic(p0, p1)) {
	using FunctionType = decltype(fadeOutMusic(p0, p1))(*)(FMODAudioEngine*, float, int);
	static auto func = wrapFunction(base::get() + 0x3c8390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::sharedEngine() -> decltype(sharedEngine()) {
	using FunctionType = decltype(sharedEngine())(*)();
	static auto func = wrapFunction(base::get() + 0x3baf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FMODAudioEngine::stopAllMusic() -> decltype(stopAllMusic()) {
	using FunctionType = decltype(stopAllMusic())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bcc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::updateReverb(FMODReverbPreset p0, bool p1) -> decltype(updateReverb(p0, p1)) {
	using FunctionType = decltype(updateReverb(p0, p1))(*)(FMODAudioEngine*, FMODReverbPreset, bool);
	static auto func = wrapFunction(base::get() + 0x3bbca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FMODAudioEngine::clearAllAudio() -> decltype(clearAllAudio()) {
	using FunctionType = decltype(clearAllAudio())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bc380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::pauseAllAudio() -> decltype(pauseAllAudio()) {
	using FunctionType = decltype(pauseAllAudio())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bc2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::pauseAllMusic() -> decltype(pauseAllMusic()) {
	using FunctionType = decltype(pauseAllMusic())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3c50c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::enableMetering() -> decltype(enableMetering()) {
	using FunctionType = decltype(enableMetering())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3c1a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::isMusicPlaying(int p0) -> decltype(isMusicPlaying(p0)) {
	using FunctionType = decltype(isMusicPlaying(p0))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x3c5170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::loadAudioState(FMODAudioState& p0) -> decltype(loadAudioState(p0)) {
	using FunctionType = decltype(loadAudioState(p0))(*)(FMODAudioEngine*, FMODAudioState&);
	static auto func = wrapFunction(base::get() + 0x3be930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::resumeAllAudio() -> decltype(resumeAllAudio()) {
	using FunctionType = decltype(resumeAllAudio())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bc330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::resumeAllMusic() -> decltype(resumeAllMusic()) {
	using FunctionType = decltype(resumeAllMusic())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3c5110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::stopAllEffects() -> decltype(stopAllEffects()) {
	using FunctionType = decltype(stopAllEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bc450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::disableMetering() -> decltype(disableMetering()) {
	using FunctionType = decltype(disableMetering())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3c1a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::setChannelPitch(int p0, AudioTargetType p1, float p2) -> decltype(setChannelPitch(p0, p1, p2)) {
	using FunctionType = decltype(setChannelPitch(p0, p1, p2))(*)(FMODAudioEngine*, int, AudioTargetType, float);
	static auto func = wrapFunction(base::get() + 0x3c1700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::getEffectsVolume() -> decltype(getEffectsVolume()) {
	using FunctionType = decltype(getEffectsVolume())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3c5050, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::getMeteringValue() -> decltype(getMeteringValue()) {
	using FunctionType = decltype(getMeteringValue())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3c1a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::setChannelVolume(int p0, AudioTargetType p1, float p2) -> decltype(setChannelVolume(p0, p1, p2)) {
	using FunctionType = decltype(setChannelVolume(p0, p1, p2))(*)(FMODAudioEngine*, int, AudioTargetType, float);
	static auto func = wrapFunction(base::get() + 0x3c18f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::setupAudioEngine() -> decltype(setupAudioEngine()) {
	using FunctionType = decltype(setupAudioEngine())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bb700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::unloadAllEffects() -> decltype(unloadAllEffects()) {
	using FunctionType = decltype(unloadAllEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3c4c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::channelForChannelID(int p0) -> decltype(channelForChannelID(p0)) {
	using FunctionType = decltype(channelForChannelID(p0))(*)(FMODAudioEngine*, int);
	static auto func = wrapFunction(base::get() + 0x3be510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::setChannelVolumeMod(int p0, AudioTargetType p1, float p2) -> decltype(setChannelVolumeMod(p0, p1, p2)) {
	using FunctionType = decltype(setChannelVolumeMod(p0, p1, p2))(*)(FMODAudioEngine*, int, AudioTargetType, float);
	static auto func = wrapFunction(base::get() + 0x3c48b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODAudioEngine::updateChannelTweens(float p0) -> decltype(updateChannelTweens(p0)) {
	using FunctionType = decltype(updateChannelTweens(p0))(*)(FMODAudioEngine*, float);
	static auto func = wrapFunction(base::get() + 0x3bdea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::updateQueuedEffects() -> decltype(updateQueuedEffects()) {
	using FunctionType = decltype(updateQueuedEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bd380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::fadeInBackgroundMusic(float p0) -> decltype(fadeInBackgroundMusic(p0)) {
	using FunctionType = decltype(fadeInBackgroundMusic(p0))(*)(FMODAudioEngine*, float);
	static auto func = wrapFunction(base::get() + 0x3c4fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FMODAudioEngine::updateTemporaryEffects() -> decltype(updateTemporaryEffects()) {
	using FunctionType = decltype(updateTemporaryEffects())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bd520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::getBackgroundMusicVolume() -> decltype(getBackgroundMusicVolume()) {
	using FunctionType = decltype(getBackgroundMusicVolume())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3c5010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::stop() -> decltype(stop()) {
	throw std::runtime_error("FMODAudioEngine::stop not implemented");
}

auto FMODAudioEngine::setup() -> decltype(setup()) {
	using FunctionType = decltype(setup())(*)(FMODAudioEngine*);
	static auto func = wrapFunction(base::get() + 0x3bb2c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto FMODAudioEngine::loadMusic(gd::string p0, float p1, float p2, float p3, bool p4, int p5, int p6) -> decltype(loadMusic(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(loadMusic(p0, p1, p2, p3, p4, p5, p6))(*)(FMODAudioEngine*, gd::string, float, float, float, bool, int, int);
	static auto func = wrapFunction(base::get() + 0x3bf920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto FMODAudioEngine::playMusic(gd::string p0, bool p1, float p2, int p3) -> decltype(playMusic(p0, p1, p2, p3)) {
	using FunctionType = decltype(playMusic(p0, p1, p2, p3))(*)(FMODAudioEngine*, gd::string, bool, float, int);
	static auto func = wrapFunction(base::get() + 0x3c5500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3);
}

auto FMODAudioEngine::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&FMODAudioEngine::update), this);
	using FunctionType = decltype(update(p0))(*)(FMODAudioEngine*, float);
	static auto func = wrapFunction(base::get() + 0x3bcec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FMODLevelVisualizer::updateVisualizer(float p0, float p1, float p2) -> decltype(updateVisualizer(p0, p1, p2)) {
	using FunctionType = decltype(updateVisualizer(p0, p1, p2))(*)(FMODLevelVisualizer*, float, float, float);
	static auto func = wrapFunction(base::get() + 0x28c6e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto FMODLevelVisualizer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x28c230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto FMODLevelVisualizer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FMODLevelVisualizer::init), this);
	using FunctionType = decltype(init())(*)(FMODLevelVisualizer*);
	static auto func = wrapFunction(base::get() + 0x28c2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJActionManager::runInternalAction(cocos2d::CCAction* p0, cocos2d::CCNode* p1) -> decltype(runInternalAction(p0, p1)) {
	using FunctionType = decltype(runInternalAction(p0, p1))(*)(GJActionManager*, cocos2d::CCAction*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x5cdf00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJActionManager::stopInternalAction(int p0) -> decltype(stopInternalAction(p0)) {
	using FunctionType = decltype(stopInternalAction(p0))(*)(GJActionManager*, int);
	static auto func = wrapFunction(base::get() + 0x5cdf50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJActionManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJActionManager::init), this);
	using FunctionType = decltype(init())(*)(GJActionManager*);
	static auto func = wrapFunction(base::get() + 0x5cded0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJBigSpriteNode::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJBigSpriteNode::init), this);
	using FunctionType = decltype(init())(*)(GJBigSpriteNode*);
	static auto func = wrapFunction(base::get() + 0x247f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJFriendRequest::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJFriendRequest::init), this);
	using FunctionType = decltype(init())(*)(GJFriendRequest*);
	static auto func = wrapFunction(base::get() + 0x52d040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGradientLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGradientLayer::init), this);
	using FunctionType = decltype(init())(*)(GJGradientLayer*);
	static auto func = wrapFunction(base::get() + 0x150ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ObjectDecoderDelegate::getDecodedObject(int p0, DS_Dictionary* p1) -> decltype(getDecodedObject(p0, p1)) {
	throw std::runtime_error("ObjectDecoderDelegate::getDecodedObject not implemented");
}

auto GJObjectDecoder::sharedDecoder() -> decltype(sharedDecoder()) {
	using FunctionType = decltype(sharedDecoder())(*)(GJObjectDecoder*);
	static auto func = wrapFunction(base::get() + 0x6e7c70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJObjectDecoder::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJObjectDecoder::init), this);
	using FunctionType = decltype(init())(*)(GJObjectDecoder*);
	static auto func = wrapFunction(base::get() + 0x6e7cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJObjectDecoder::getDecodedObject(int p0, DS_Dictionary* p1) -> decltype(getDecodedObject(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, DS_Dictionary*>::func(&GJObjectDecoder::getDecodedObject), this);
	using FunctionType = decltype(getDecodedObject(p0, p1))(*)(GJObjectDecoder*, int, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x6e7d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSmartTemplate::getNoCornerKey(gd::string p0) -> decltype(getNoCornerKey(p0)) {
	using FunctionType = decltype(getNoCornerKey(p0))(*)(GJSmartTemplate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x403360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartTemplate::getSimplifiedKey(gd::string p0) -> decltype(getSimplifiedKey(p0)) {
	using FunctionType = decltype(getSimplifiedKey(p0))(*)(GJSmartTemplate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x402b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartTemplate::getVerySimplifiedKey(gd::string p0) -> decltype(getVerySimplifiedKey(p0)) {
	using FunctionType = decltype(getVerySimplifiedKey(p0))(*)(GJSmartTemplate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x4034a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartTemplate::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(GJSmartTemplate*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x407300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartTemplate::createWithCoder(DS_Dictionary* p0) -> decltype(createWithCoder(p0)) {
	using FunctionType = decltype(createWithCoder(p0))(*)(GJSmartTemplate*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x407250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartTemplate::saveRemapToDict(gd::string p0, gd::string p1, cocos2d::CCDictionary* p2) -> decltype(saveRemapToDict(p0, p1, p2)) {
	using FunctionType = decltype(saveRemapToDict(p0, p1, p2))(*)(GJSmartTemplate*, gd::string, gd::string, cocos2d::CCDictionary*);
	static auto func = wrapFunction(base::get() + 0x403130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto GJSmartTemplate::logTemplateStatus(bool p0) -> decltype(logTemplateStatus(p0)) {
	using FunctionType = decltype(logTemplateStatus(p0))(*)(GJSmartTemplate*, bool);
	static auto func = wrapFunction(base::get() + 0x406780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartTemplate::saveRemap(gd::string p0) -> decltype(saveRemap(p0)) {
	using FunctionType = decltype(saveRemap(p0))(*)(GJSmartTemplate*, gd::string);
	static auto func = wrapFunction(base::get() + 0x402210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJSmartTemplate::encodeWithCoder(DS_Dictionary* p0) -> decltype(encodeWithCoder(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DS_Dictionary*>::func(&GJSmartTemplate::encodeWithCoder), this);
	using FunctionType = decltype(encodeWithCoder(p0))(*)(GJSmartTemplate*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x4075e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJSmartTemplate::canEncode() -> decltype(canEncode()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSmartTemplate::canEncode), this);
	using FunctionType = decltype(canEncode())(*)(GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x407240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoAlertButton::create(gd::string p0, gd::string p1, float p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(gd::string, gd::string, float);
	static auto func = wrapFunction(base::get() + 0x540d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto InfoAlertButton::activate() -> decltype(activate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoAlertButton::activate), this);
	using FunctionType = decltype(activate())(*)(InfoAlertButton*);
	static auto func = wrapFunction(base::get() + 0x540f40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreSearchLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x5efc80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MoreSearchLayer::onFeatured(cocos2d::CCObject* sender) -> decltype(onFeatured(sender)) {
	using FunctionType = decltype(onFeatured(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onOriginal(cocos2d::CCObject* sender) -> decltype(onOriginal(sender)) {
	using FunctionType = decltype(onOriginal(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onSongMode(cocos2d::CCObject* sender) -> decltype(onSongMode(sender)) {
	using FunctionType = decltype(onSongMode(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onCompleted(cocos2d::CCObject* sender) -> decltype(onCompleted(sender)) {
	using FunctionType = decltype(onCompleted(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onLegendary(cocos2d::CCObject* sender) -> decltype(onLegendary(sender)) {
	using FunctionType = decltype(onLegendary(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onTwoPlayer(cocos2d::CCObject* sender) -> decltype(onTwoPlayer(sender)) {
	using FunctionType = decltype(onTwoPlayer(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f29d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onSongFilter(cocos2d::CCObject* sender) -> decltype(onSongFilter(sender)) {
	using FunctionType = decltype(onSongFilter(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onUncompleted(cocos2d::CCObject* sender) -> decltype(onUncompleted(sender)) {
	using FunctionType = decltype(onUncompleted(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f28d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onEpic(cocos2d::CCObject* sender) -> decltype(onEpic(sender)) {
	using FunctionType = decltype(onEpic(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f25d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onCoins(cocos2d::CCObject* sender) -> decltype(onCoins(sender)) {
	using FunctionType = decltype(onCoins(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onMythic(cocos2d::CCObject* sender) -> decltype(onMythic(sender)) {
	using FunctionType = decltype(onMythic(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2bf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::onNoStar(cocos2d::CCObject* sender) -> decltype(onNoStar(sender)) {
	using FunctionType = decltype(onNoStar(sender))(*)(MoreSearchLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f2af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreSearchLayer::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4) -> decltype(createToggleButton(p0, p1, p2, p3, p4)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4))(*)(MoreSearchLayer*, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x5f26b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4);
}

auto MoreSearchLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreSearchLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x5f11e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreSearchLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreSearchLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MoreSearchLayer*);
	static auto func = wrapFunction(base::get() + 0x5f33b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreSearchLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&MoreSearchLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(MoreSearchLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x5f3240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MoreSearchLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MoreSearchLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(MoreSearchLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5f3300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RetryLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x4d46e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&RetryLevelLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(RetryLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4d4610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RetryLevelLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x4d3530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::showLayer(bool p0) -> decltype(showLayer(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&RetryLevelLayer::showLayer), this);
	using FunctionType = decltype(showLayer(p0))(*)(RetryLevelLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4d40f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto RetryLevelLayer::enterAnimFinished() -> decltype(enterAnimFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::enterAnimFinished), this);
	using FunctionType = decltype(enterAnimFinished())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x4d41f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x4d45f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::shouldOffsetRewardCurrency() -> decltype(shouldOffsetRewardCurrency()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RetryLevelLayer::shouldOffsetRewardCurrency), this);
	using FunctionType = decltype(shouldOffsetRewardCurrency())(*)(RetryLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x4d4730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RetryLevelLayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&RetryLevelLayer::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(RetryLevelLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4d46c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SelectFontLayer::create(LevelEditorLayer* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x277c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SelectFontLayer::init(LevelEditorLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SelectFontLayer*, LevelEditorLayer*);
	static auto func = wrapFunction(base::get() + 0x277da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SelectFontLayer::onChangeFont(cocos2d::CCObject* sender) -> decltype(onChangeFont(sender)) {
	using FunctionType = decltype(onChangeFont(sender))(*)(SelectFontLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2783b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectFontLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SelectFontLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x278380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectFontLayer::updateFontLabel() -> decltype(updateFontLabel()) {
	using FunctionType = decltype(updateFontLabel())(*)(SelectFontLayer*);
	static auto func = wrapFunction(base::get() + 0x278450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SelectFontLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectFontLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectFontLayer*);
	static auto func = wrapFunction(base::get() + 0x278560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetColorIDPopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJSpecialColorSelect*, int>::func(&SetColorIDPopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0, p1))(*)(SetColorIDPopup*, GJSpecialColorSelect*, int);
	static auto func = wrapFunction(base::get() + 0x288cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetGroupIDLayer::init(GameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetGroupIDLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x2ef4a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetGroupIDLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetGroupIDLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetGroupIDLayer*);
	static auto func = wrapFunction(base::get() + 0x2f43c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetGroupIDLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetGroupIDLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetGroupIDLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2f3c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetGroupIDLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetGroupIDLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetGroupIDLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2f3c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupPulsePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupPulsePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x38d4c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupPulsePopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupPulsePopup::show), this);
	using FunctionType = decltype(show())(*)(SetupPulsePopup*);
	static auto func = wrapFunction(base::get() + 0x38dc40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupPulsePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupPulsePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupPulsePopup*);
	static auto func = wrapFunction(base::get() + 0x38c900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupPulsePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupPulsePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupPulsePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x38dcc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupPulsePopup::colorValueChanged(cocos2d::_ccColor3B p0) -> decltype(colorValueChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B>::func(&SetupPulsePopup::colorValueChanged), this);
	using FunctionType = decltype(colorValueChanged(p0))(*)(SetupPulsePopup*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x38d6a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupPulsePopup::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupPulsePopup::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SetupPulsePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x38dca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupPulsePopup::colorSelectClosed(GJSpecialColorSelect* p0, int p1) -> decltype(colorSelectClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJSpecialColorSelect*, int>::func(&SetupPulsePopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0, p1))(*)(SetupPulsePopup*, GJSpecialColorSelect*, int);
	static auto func = wrapFunction(base::get() + 0x38ce40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupShakePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupShakePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x628fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupShakePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupShakePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupShakePopup*);
	static auto func = wrapFunction(base::get() + 0x6288d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupShakePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupShakePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupShakePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x628c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto OptionsObjectDelegate::stateChanged(OptionsObject* p0) -> decltype(stateChanged(p0)) {
	throw std::runtime_error("OptionsObjectDelegate::stateChanged not implemented");
}

auto MusicSearchResult::updateObjects(AudioSortType p0) -> decltype(updateObjects(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AudioSortType>::func(&MusicSearchResult::updateObjects), this);
	using FunctionType = decltype(updateObjects(p0))(*)(MusicSearchResult*, AudioSortType);
	static auto func = wrapFunction(base::get() + 0x561cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MusicSearchResult::stateChanged(OptionsObject* p0) -> decltype(stateChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<OptionsObject*>::func(&MusicSearchResult::stateChanged), this);
	using FunctionType = decltype(stateChanged(p0))(*)(MusicSearchResult*, OptionsObject*);
	static auto func = wrapFunction(base::get() + 0x561c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SFXSearchResult::updateObjects(AudioSortType p0) -> decltype(updateObjects(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AudioSortType>::func(&SFXSearchResult::updateObjects), this);
	using FunctionType = decltype(updateObjects(p0))(*)(SFXSearchResult*, AudioSortType);
	static auto func = wrapFunction(base::get() + 0x5625c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareLevelLayer::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(ShareLevelLayer*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x25dc20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto ShareLevelLayer::onShare(cocos2d::CCObject* sender) -> decltype(onShare(sender)) {
	using FunctionType = decltype(onShare(sender))(*)(ShareLevelLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x25ed60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto ShareLevelLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ShareLevelLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ShareLevelLayer*);
	static auto func = wrapFunction(base::get() + 0x25f410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(TopArtistsLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x2ee360, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto TopArtistsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::init), this);
	using FunctionType = decltype(init())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x2ed8a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x2ee210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x2ee1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TopArtistsLayer::show), this);
	using FunctionType = decltype(show())(*)(TopArtistsLayer*);
	static auto func = wrapFunction(base::get() + 0x2eebf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TopArtistsLayer::loadListFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadListFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&TopArtistsLayer::loadListFinished), this);
	using FunctionType = decltype(loadListFinished(p0, p1))(*)(TopArtistsLayer*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x2ee260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto TopArtistsLayer::loadListFailed(char const* p0) -> decltype(loadListFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&TopArtistsLayer::loadListFailed), this);
	using FunctionType = decltype(loadListFailed(p0))(*)(TopArtistsLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x2ee320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UploadListPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadListPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UploadListPopup*);
	static auto func = wrapFunction(base::get() + 0x342eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadListPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UploadListPopup::show), this);
	using FunctionType = decltype(show())(*)(UploadListPopup*);
	static auto func = wrapFunction(base::get() + 0x342e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UploadListPopup::listUploadFinished(GJLevelList* p0) -> decltype(listUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJLevelList*>::func(&UploadListPopup::listUploadFinished), this);
	using FunctionType = decltype(listUploadFinished(p0))(*)(UploadListPopup*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x342960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UploadListPopup::listUploadFailed(GJLevelList* p0, int p1) -> decltype(listUploadFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<GJLevelList*, int>::func(&UploadListPopup::listUploadFailed), this);
	using FunctionType = decltype(listUploadFailed(p0, p1))(*)(UploadListPopup*, GJLevelList*, int);
	static auto func = wrapFunction(base::get() + 0x342b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountHelpLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountHelpLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0xcab60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountHelpLayer::layerHidden() -> decltype(layerHidden()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountHelpLayer::layerHidden), this);
	using FunctionType = decltype(layerHidden())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0xcb740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountHelpLayer::accountStatusChanged() -> decltype(accountStatusChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountHelpLayer::accountStatusChanged), this);
	using FunctionType = decltype(accountStatusChanged())(*)(AccountHelpLayer*);
	static auto func = wrapFunction(base::get() + 0xcb600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountHelpLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountHelpLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountHelpLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0xcb630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCPartAnimSprite::setColor(cocos2d::_ccColor3B p0) -> decltype(setColor(p0)) {
	using FunctionType = decltype(setColor(p0))(*)(CCPartAnimSprite*, cocos2d::_ccColor3B);
	static auto func = wrapFunction(base::get() + 0x353390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCPartAnimSprite::setScaleX(float p0) -> decltype(setScaleX(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCPartAnimSprite::setScaleX), this);
	using FunctionType = decltype(setScaleX(p0))(*)(CCPartAnimSprite*, float);
	static auto func = wrapFunction(base::get() + 0x3531d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setScaleY(float p0) -> decltype(setScaleY(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCPartAnimSprite::setScaleY), this);
	using FunctionType = decltype(setScaleY(p0))(*)(CCPartAnimSprite*, float);
	static auto func = wrapFunction(base::get() + 0x3531f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setScale(float p0) -> decltype(setScale(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CCPartAnimSprite::setScale), this);
	using FunctionType = decltype(setScale(p0))(*)(CCPartAnimSprite*, float);
	static auto func = wrapFunction(base::get() + 0x3531b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&CCPartAnimSprite::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(CCPartAnimSprite*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x353460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setBlendFunc(cocos2d::_ccBlendFunc p0) -> decltype(setBlendFunc(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccBlendFunc>::func(&CCPartAnimSprite::setBlendFunc), this);
	using FunctionType = decltype(setBlendFunc(p0))(*)(CCPartAnimSprite*, cocos2d::_ccBlendFunc);
	static auto func = wrapFunction(base::get() + 0x353210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::setDisplayFrame(cocos2d::CCSpriteFrame* p0) -> decltype(setDisplayFrame(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&CCPartAnimSprite::setDisplayFrame), this);
	using FunctionType = decltype(setDisplayFrame(p0))(*)(CCPartAnimSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x352d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::isFrameDisplayed(cocos2d::CCSpriteFrame* p0) -> decltype(isFrameDisplayed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCSpriteFrame*>::func(&CCPartAnimSprite::isFrameDisplayed), this);
	using FunctionType = decltype(isFrameDisplayed(p0))(*)(CCPartAnimSprite*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x352ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CCPartAnimSprite::displayFrame() -> decltype(displayFrame()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCPartAnimSprite::displayFrame), this);
	using FunctionType = decltype(displayFrame())(*)(CCPartAnimSprite*);
	static auto func = wrapFunction(base::get() + 0x352f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongWidget::create(SongInfoObject* p0, CustomSongDelegate* p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7) -> decltype(create(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(create(p0, p1, p2, p3, p4, p5, p6, p7))(*)(SongInfoObject*, CustomSongDelegate*, bool, bool, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x5de780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2, p3, p4, p5, p6, p7);
}

auto CustomSongWidget::init(SongInfoObject* p0, CustomSongDelegate* p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7) -> decltype(init(p0, p1, p2, p3, p4, p5, p6, p7)) {
	using FunctionType = decltype(init(p0, p1, p2, p3, p4, p5, p6, p7))(*)(CustomSongWidget*, SongInfoObject*, CustomSongDelegate*, bool, bool, bool, bool, bool, bool);
	static auto func = wrapFunction(base::get() + 0x5de910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6, p7);
}

CustomSongWidget::~CustomSongWidget() {
	// basically we destruct it once by calling the gd function, 
	// then lock it, so that other gd destructors dont get called
	if (CCDestructor::lock(this)) return;
	using FunctionType = void(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x5de750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	reinterpret_cast<FunctionType>(func)(this);
	// we need to construct it back so that it uhhh ummm doesnt crash
	// while going to the child destructors
	auto thing = new (this) CustomSongWidget(geode::CutoffConstructor, sizeof(CustomSongWidget));
	CCDestructor::lock(this) = true;
}

auto CustomSongWidget::onDownload(cocos2d::CCObject* sender) -> decltype(onDownload(sender)) {
	using FunctionType = decltype(onDownload(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5dfbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onPlayback(cocos2d::CCObject* sender) -> decltype(onPlayback(sender)) {
	using FunctionType = decltype(onPlayback(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5e0080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onGetSongInfo(cocos2d::CCObject* sender) -> decltype(onGetSongInfo(sender)) {
	using FunctionType = decltype(onGetSongInfo(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5dfff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onCancelDownload(cocos2d::CCObject* sender) -> decltype(onCancelDownload(sender)) {
	using FunctionType = decltype(onCancelDownload(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5dfe70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onMore(cocos2d::CCObject* sender) -> decltype(onMore(sender)) {
	using FunctionType = decltype(onMore(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5e02e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onDelete(cocos2d::CCObject* sender) -> decltype(onDelete(sender)) {
	using FunctionType = decltype(onDelete(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5dfeb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::onSelect(cocos2d::CCObject* sender) -> decltype(onSelect(sender)) {
	using FunctionType = decltype(onSelect(sender))(*)(CustomSongWidget*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5dff90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomSongWidget::deleteSong() -> decltype(deleteSong()) {
	using FunctionType = decltype(deleteSong())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x5e1850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::updateSongInfo() -> decltype(updateSongInfo()) {
	using FunctionType = decltype(updateSongInfo())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x5e0a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::updateSongObject(SongInfoObject* p0) -> decltype(updateSongObject(p0)) {
	using FunctionType = decltype(updateSongObject(p0))(*)(CustomSongWidget*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x5e09e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::updatePlaybackBtn() -> decltype(updatePlaybackBtn()) {
	using FunctionType = decltype(updatePlaybackBtn())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x5e1780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomSongWidget::updateWithMultiAssets(gd::string p0, gd::string p1, int p2) -> decltype(updateWithMultiAssets(p0, p1, p2)) {
	using FunctionType = decltype(updateWithMultiAssets(p0, p1, p2))(*)(CustomSongWidget*, gd::string, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x5e2370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CustomSongWidget::showError(bool p0) -> decltype(showError(p0)) {
	using FunctionType = decltype(showError(p0))(*)(CustomSongWidget*, bool);
	static auto func = wrapFunction(base::get() + 0x5e1990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomSongWidget::loadSongInfoFinished(SongInfoObject* p0) -> decltype(loadSongInfoFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SongInfoObject*>::func(&CustomSongWidget::loadSongInfoFinished), this);
	using FunctionType = decltype(loadSongInfoFinished(p0))(*)(CustomSongWidget*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x5e3290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::loadSongInfoFailed(int p0, GJSongError p1) -> decltype(loadSongInfoFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSongWidget::loadSongInfoFailed), this);
	using FunctionType = decltype(loadSongInfoFailed(p0, p1))(*)(CustomSongWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x5e3440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::downloadSongFinished(int p0) -> decltype(downloadSongFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongWidget::downloadSongFinished), this);
	using FunctionType = decltype(downloadSongFinished(p0))(*)(CustomSongWidget*, int);
	static auto func = wrapFunction(base::get() + 0x5e3640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::downloadSongFailed(int p0, GJSongError p1) -> decltype(downloadSongFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSongWidget::downloadSongFailed), this);
	using FunctionType = decltype(downloadSongFailed(p0, p1))(*)(CustomSongWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x5e3920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::downloadSFXFinished(int p0) -> decltype(downloadSFXFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomSongWidget::downloadSFXFinished), this);
	using FunctionType = decltype(downloadSFXFinished(p0))(*)(CustomSongWidget*, int);
	static auto func = wrapFunction(base::get() + 0x5e3ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::downloadSFXFailed(int p0, GJSongError p1) -> decltype(downloadSFXFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, GJSongError>::func(&CustomSongWidget::downloadSFXFailed), this);
	using FunctionType = decltype(downloadSFXFailed(p0, p1))(*)(CustomSongWidget*, int, GJSongError);
	static auto func = wrapFunction(base::get() + 0x5e3ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomSongWidget::musicActionFinished(GJMusicAction p0) -> decltype(musicActionFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&CustomSongWidget::musicActionFinished), this);
	using FunctionType = decltype(musicActionFinished(p0))(*)(CustomSongWidget*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x5e3da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::musicActionFailed(GJMusicAction p0) -> decltype(musicActionFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJMusicAction>::func(&CustomSongWidget::musicActionFailed), this);
	using FunctionType = decltype(musicActionFailed(p0))(*)(CustomSongWidget*, GJMusicAction);
	static auto func = wrapFunction(base::get() + 0x5e3e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomSongWidget::songStateChanged() -> decltype(songStateChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomSongWidget::songStateChanged), this);
	using FunctionType = decltype(songStateChanged())(*)(CustomSongWidget*);
	static auto func = wrapFunction(base::get() + 0x5e2300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomSongWidget::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&CustomSongWidget::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(CustomSongWidget*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5e3ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FollowRewardPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::init), this);
	using FunctionType = decltype(init())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x3ff7b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x401930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x4018c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::show), this);
	using FunctionType = decltype(show())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x401690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&FollowRewardPage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(FollowRewardPage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x401810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FollowRewardPage::rewardedVideoFinished() -> decltype(rewardedVideoFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::rewardedVideoFinished), this);
	using FunctionType = decltype(rewardedVideoFinished())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x401670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FollowRewardPage::updateRate() -> decltype(updateRate()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FollowRewardPage::updateRate), this);
	using FunctionType = decltype(updateRate())(*)(FollowRewardPage*);
	static auto func = wrapFunction(base::get() + 0x401320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameOptionsLayer::create(GJBaseGameLayer* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x28c970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GameOptionsLayer::onPracticeMusicSync(cocos2d::CCObject* sender) -> decltype(onPracticeMusicSync(sender)) {
	using FunctionType = decltype(onPracticeMusicSync(sender))(*)(GameOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x28d090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GameOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(GameOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x28cc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GameOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(GameOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x28d610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GhostTrailEffect::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GhostTrailEffect::init), this);
	using FunctionType = decltype(init())(*)(GhostTrailEffect*);
	static auto func = wrapFunction(base::get() + 0x5bece0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GhostTrailEffect::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GhostTrailEffect::draw), this);
	using FunctionType = decltype(draw())(*)(GhostTrailEffect*);
	static auto func = wrapFunction(base::get() + 0x5bf290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJFlyGroundLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJFlyGroundLayer::init), this);
	using FunctionType = decltype(init())(*)(GJFlyGroundLayer*);
	static auto func = wrapFunction(base::get() + 0x5b0840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLevelScoreCell::loadFromScore(GJUserScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJLevelScoreCell*, GJUserScore*);
	static auto func = wrapFunction(base::get() + 0x229660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLevelScoreCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLevelScoreCell::init), this);
	using FunctionType = decltype(init())(*)(GJLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0x234030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLevelScoreCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLevelScoreCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0x234080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMoreGamesLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMoreGamesLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(GJMoreGamesLayer*);
	static auto func = wrapFunction(base::get() + 0x757290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeybindingsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeybindingsLayer::init), this);
	using FunctionType = decltype(init())(*)(KeybindingsLayer*);
	static auto func = wrapFunction(base::get() + 0x5ce680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto KeybindingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeybindingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(KeybindingsLayer*);
	static auto func = wrapFunction(base::get() + 0x5cff50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::create(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x3b8480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto LevelLeaderboard::init(GJGameLevel* p0, LevelLeaderboardType p1, LevelLeaderboardMode p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(LevelLeaderboard*, GJGameLevel*, LevelLeaderboardType, LevelLeaderboardMode);
	static auto func = wrapFunction(base::get() + 0x3b8610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto LevelLeaderboard::getLocalScores() -> decltype(getLocalScores()) {
	using FunctionType = decltype(getLocalScores())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3b9fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelLeaderboard::getSpriteButton(gd::string p0, cocos2d::SEL_MenuHandler p1, cocos2d::CCMenu* p2, float p3, cocos2d::CCPoint p4, int p5) -> decltype(getSpriteButton(p0, p1, p2, p3, p4, p5)) {
	using FunctionType = decltype(getSpriteButton(p0, p1, p2, p3, p4, p5))(*)(LevelLeaderboard*, gd::string, cocos2d::SEL_MenuHandler, cocos2d::CCMenu*, float, cocos2d::CCPoint, int);
	static auto func = wrapFunction(base::get() + 0x3b9640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5);
}

auto LevelLeaderboard::onChangeMode(cocos2d::CCObject* sender) -> decltype(onChangeMode(sender)) {
	using FunctionType = decltype(onChangeMode(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b97f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onChangeType(cocos2d::CCObject* sender) -> decltype(onChangeType(sender)) {
	using FunctionType = decltype(onChangeType(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b9a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onDeleteLocalScores(cocos2d::CCObject* sender) -> decltype(onDeleteLocalScores(sender)) {
	using FunctionType = decltype(onDeleteLocalScores(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b9840, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b9910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(LevelLeaderboard*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b9940, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelLeaderboard::loadScores() -> decltype(loadScores()) {
	using FunctionType = decltype(loadScores())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3b9a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelLeaderboard::setupLeaderboard(cocos2d::CCArray* p0) -> decltype(setupLeaderboard(p0)) {
	using FunctionType = decltype(setupLeaderboard(p0))(*)(LevelLeaderboard*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x3b9c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelLeaderboard::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3ba380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3ba310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::show), this);
	using FunctionType = decltype(show())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3ba8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadLeaderboardFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&LevelLeaderboard::loadLeaderboardFinished), this);
	using FunctionType = decltype(loadLeaderboardFinished(p0, p1))(*)(LevelLeaderboard*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x3ba5d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelLeaderboard::loadLeaderboardFailed(char const* p0) -> decltype(loadLeaderboardFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&LevelLeaderboard::loadLeaderboardFailed), this);
	using FunctionType = decltype(loadLeaderboardFailed(p0))(*)(LevelLeaderboard*, char const*);
	static auto func = wrapFunction(base::get() + 0x3ba710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelLeaderboard::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LevelLeaderboard::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LevelLeaderboard*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x3b9f60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelLeaderboard::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3ba160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelLeaderboard::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelLeaderboard::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(LevelLeaderboard*);
	static auto func = wrapFunction(base::get() + 0x3ba190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x75cfc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MoreOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x75f210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreOptionsLayer::onToggle(cocos2d::CCObject* sender) -> decltype(onToggle(sender)) {
	using FunctionType = decltype(onToggle(sender))(*)(MoreOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x75fa80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MoreOptionsLayer::addToggle(char const* p0, char const* p1, char const* p2) -> decltype(addToggle(p0, p1, p2)) {
	using FunctionType = decltype(addToggle(p0, p1, p2))(*)(MoreOptionsLayer*, char const*, char const*, char const*);
	static auto func = wrapFunction(base::get() + 0x75e760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto MoreOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x75d590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x760630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&MoreOptionsLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(MoreOptionsLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x760660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MoreOptionsLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&MoreOptionsLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(MoreOptionsLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x760720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MoreOptionsLayer::googlePlaySignedIn() -> decltype(googlePlaySignedIn()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreOptionsLayer::googlePlaySignedIn), this);
	using FunctionType = decltype(googlePlaySignedIn())(*)(MoreOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7607d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreOptionsLayer::dropDownLayerWillClose(GJDropDownLayer* p0) -> decltype(dropDownLayerWillClose(p0)) {
	auto self = addresser::thunkAdjust(Resolve<GJDropDownLayer*>::func(&MoreOptionsLayer::dropDownLayerWillClose), this);
	using FunctionType = decltype(dropDownLayerWillClose(p0))(*)(MoreOptionsLayer*, GJDropDownLayer*);
	static auto func = wrapFunction(base::get() + 0x7604b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MultiplayerLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MultiplayerLayer::init), this);
	using FunctionType = decltype(init())(*)(MultiplayerLayer*);
	static auto func = wrapFunction(base::get() + 0x3789a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MultiplayerLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MultiplayerLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MultiplayerLayer*);
	static auto func = wrapFunction(base::get() + 0x378a90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectEventLayer::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SelectEventLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x545320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectEventLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SelectEventLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x545550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SelectEventLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectEventLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectEventLayer*);
	static auto func = wrapFunction(base::get() + 0x545620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTargetIDLayer::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetTargetIDLayer::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetTargetIDLayer*);
	static auto func = wrapFunction(base::get() + 0x294a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetTargetIDLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetTargetIDLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetTargetIDLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x294a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupPortalPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupPortalPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupPortalPopup*);
	static auto func = wrapFunction(base::get() + 0x53c1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupReverbPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupReverbPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x493d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRotatePopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupRotatePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x565060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRotatePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupRotatePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x564fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SongOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SongOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x1f60a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UserListDelegate::getUserListFinished(cocos2d::CCArray* p0, UserListType p1) -> decltype(getUserListFinished(p0, p1)) {
	throw std::runtime_error("UserListDelegate::getUserListFinished not implemented");
}

auto UserListDelegate::getUserListFailed(UserListType p0, GJErrorCode p1) -> decltype(getUserListFailed(p0, p1)) {
	throw std::runtime_error("UserListDelegate::getUserListFailed not implemented");
}

auto UserListDelegate::userListChanged(cocos2d::CCArray* p0, UserListType p1) -> decltype(userListChanged(p0, p1)) {
	throw std::runtime_error("UserListDelegate::userListChanged not implemented");
}

auto UserListDelegate::forceReloadList(UserListType p0) -> decltype(forceReloadList(p0)) {
	throw std::runtime_error("UserListDelegate::forceReloadList not implemented");
}

auto WorldSelectLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(WorldSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3a02a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto WorldSelectLayer::onGarage(cocos2d::CCObject* sender) -> decltype(onGarage(sender)) {
	using FunctionType = decltype(onGarage(sender))(*)(WorldSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3a0aa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto WorldSelectLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&WorldSelectLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(WorldSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto WorldSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&WorldSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(WorldSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x3a1ed0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto WorldSelectLayer::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&WorldSelectLayer::scrollLayerWillScrollToPage), this);
	using FunctionType = decltype(scrollLayerWillScrollToPage(p0, p1))(*)(WorldSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3a1de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto WorldSelectLayer::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&WorldSelectLayer::scrollLayerScrolledToPage), this);
	using FunctionType = decltype(scrollLayerScrolledToPage(p0, p1))(*)(WorldSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x3a1cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto WorldSelectLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&WorldSelectLayer::scrollLayerMoved), this);
	using FunctionType = decltype(scrollLayerMoved(p0))(*)(WorldSelectLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x3a2000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountLoginLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLoginLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(AccountLoginLayer*);
	static auto func = wrapFunction(base::get() + 0x476860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLoginLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountLoginLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(AccountLoginLayer*);
	static auto func = wrapFunction(base::get() + 0x476720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountLoginLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountLoginLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountLoginLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x476560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLoginLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountLoginLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(AccountLoginLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x476a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountLoginLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountLoginLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(AccountLoginLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4768a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountLoginLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountLoginLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(AccountLoginLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x476a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountLoginLayer::loginAccountFinished(int p0, int p1) -> decltype(loginAccountFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&AccountLoginLayer::loginAccountFinished), this);
	using FunctionType = decltype(loginAccountFinished(p0, p1))(*)(AccountLoginLayer*, int, int);
	static auto func = wrapFunction(base::get() + 0x475f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountLoginLayer::loginAccountFailed(AccountError p0) -> decltype(loginAccountFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AccountError>::func(&AccountLoginLayer::loginAccountFailed), this);
	using FunctionType = decltype(loginAccountFailed(p0))(*)(AccountLoginLayer*, AccountError);
	static auto func = wrapFunction(base::get() + 0x476230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AchievementsLayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&AchievementsLayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(AchievementsLayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x351660, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AchievementsLayer::customSetup() -> decltype(customSetup()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementsLayer::customSetup), this);
	using FunctionType = decltype(customSetup())(*)(AchievementsLayer*);
	static auto func = wrapFunction(base::get() + 0x3511a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AudioEffectsLayer::create(gd::string p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(gd::string);
	static auto func = wrapFunction(base::get() + 0x48afb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto AudioEffectsLayer::init(gd::string p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(AudioEffectsLayer*, gd::string);
	static auto func = wrapFunction(base::get() + 0x48b0e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AudioEffectsLayer::triggerEffect(float p0) -> decltype(triggerEffect(p0)) {
	using FunctionType = decltype(triggerEffect(p0))(*)(AudioEffectsLayer*, float);
	static auto func = wrapFunction(base::get() + 0x48b650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AudioEffectsLayer::audioStep(float p0) -> decltype(audioStep(p0)) {
	using FunctionType = decltype(audioStep(p0))(*)(AudioEffectsLayer*, float);
	static auto func = wrapFunction(base::get() + 0x48b580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AudioEffectsLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AudioEffectsLayer::draw), this);
	using FunctionType = decltype(draw())(*)(AudioEffectsLayer*);
	static auto func = wrapFunction(base::get() + 0x48b8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AudioEffectsLayer::updateTweenAction(float p0, char const* p1) -> decltype(updateTweenAction(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<float, char const*>::func(&AudioEffectsLayer::updateTweenAction), this);
	using FunctionType = decltype(updateTweenAction(p0, p1))(*)(AudioEffectsLayer*, float, char const*);
	static auto func = wrapFunction(base::get() + 0x48b790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CCSpriteGrayscale::createWithSpriteFrame(cocos2d::CCSpriteFrame* p0) -> decltype(createWithSpriteFrame(p0)) {
	using FunctionType = decltype(createWithSpriteFrame(p0))(*)(CCSpriteGrayscale*, cocos2d::CCSpriteFrame*);
	static auto func = wrapFunction(base::get() + 0x5b6a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CCSpriteGrayscale::createWithSpriteFrameName(gd::string const& p0) -> decltype(createWithSpriteFrameName(p0)) {
	using FunctionType = decltype(createWithSpriteFrameName(p0))(*)(gd::string const&);
	static auto func = wrapFunction(base::get() + 0x5b6b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto CCSpriteGrayscale::getShaderName() -> decltype(getShaderName()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteGrayscale::getShaderName), this);
	using FunctionType = decltype(getShaderName())(*)(CCSpriteGrayscale*);
	static auto func = wrapFunction(base::get() + 0x5b66f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CCSpriteGrayscale::shaderBody() -> decltype(shaderBody()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CCSpriteGrayscale::shaderBody), this);
	using FunctionType = decltype(shaderBody())(*)(CCSpriteGrayscale*);
	static auto func = wrapFunction(base::get() + 0x5b64f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DungeonBarsSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DungeonBarsSprite::init), this);
	using FunctionType = decltype(init())(*)(DungeonBarsSprite*);
	static auto func = wrapFunction(base::get() + 0x4843e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DungeonBarsSprite::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DungeonBarsSprite::visit), this);
	using FunctionType = decltype(visit())(*)(DungeonBarsSprite*);
	static auto func = wrapFunction(base::get() + 0x484460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditTriggersPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(EditTriggersPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x278b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditTriggersPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditTriggersPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(EditTriggersPopup*);
	static auto func = wrapFunction(base::get() + 0x278b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ExplodeItemSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ExplodeItemSprite::init), this);
	using FunctionType = decltype(init())(*)(ExplodeItemSprite*);
	static auto func = wrapFunction(base::get() + 0x1f38e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJColorSetupLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJColorSetupLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJColorSetupLayer*);
	static auto func = wrapFunction(base::get() + 0x1eac60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJColorSetupLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&GJColorSetupLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(GJColorSetupLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x1eac30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJPathRewardPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPathRewardPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJPathRewardPopup*);
	static auto func = wrapFunction(base::get() + 0x2dffb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotationControl::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0xf450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJRotationControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRotationControl::init), this);
	using FunctionType = decltype(init())(*)(GJRotationControl*);
	static auto func = wrapFunction(base::get() + 0x54a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotationControl::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRotationControl::draw), this);
	using FunctionType = decltype(draw())(*)(GJRotationControl*);
	static auto func = wrapFunction(base::get() + 0x55010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotationControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x54c80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x54da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x54f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJRotationControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJRotationControl::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(GJRotationControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x54fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GooglePlayManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)(GooglePlayManager*);
	static auto func = wrapFunction(base::get() + 0x455950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GooglePlayManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GooglePlayManager::init), this);
	using FunctionType = decltype(init())(*)(GooglePlayManager*);
	static auto func = wrapFunction(base::get() + 0x4559b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::create(LeaderboardState p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x4ea500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LeaderboardsLayer::init(LeaderboardState p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LeaderboardsLayer*, LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x4ea600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LeaderboardsLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LeaderboardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4eb380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LeaderboardsLayer::refreshTabs() -> decltype(refreshTabs()) {
	using FunctionType = decltype(refreshTabs())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x4eb590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LeaderboardsLayer::selectLeaderboard(LeaderboardState p0) -> decltype(selectLeaderboard(p0)) {
	using FunctionType = decltype(selectLeaderboard(p0))(*)(LeaderboardsLayer*, LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x4eb260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LeaderboardsLayer::setupLevelBrowser(cocos2d::CCArray* p0) -> decltype(setupLevelBrowser(p0)) {
	using FunctionType = decltype(setupLevelBrowser(p0))(*)(LeaderboardsLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x4eb450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LeaderboardsLayer::scene(LeaderboardState p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(LeaderboardsLayer*, LeaderboardState);
	static auto func = wrapFunction(base::get() + 0x4ea3d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LeaderboardsLayer::setupTabs() -> decltype(setupTabs()) {
	using FunctionType = decltype(setupTabs())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x4eae30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LeaderboardsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LeaderboardsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x4ec1a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&LeaderboardsLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(LeaderboardsLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4ec140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LeaderboardsLayer::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LeaderboardsLayer::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x4eb820, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::updateUserScoreFailed() -> decltype(updateUserScoreFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LeaderboardsLayer::updateUserScoreFailed), this);
	using FunctionType = decltype(updateUserScoreFailed())(*)(LeaderboardsLayer*);
	static auto func = wrapFunction(base::get() + 0x4eb880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LeaderboardsLayer::loadLeaderboardFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadLeaderboardFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&LeaderboardsLayer::loadLeaderboardFinished), this);
	using FunctionType = decltype(loadLeaderboardFinished(p0, p1))(*)(LeaderboardsLayer*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x4eb920, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LeaderboardsLayer::loadLeaderboardFailed(char const* p0) -> decltype(loadLeaderboardFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&LeaderboardsLayer::loadLeaderboardFailed), this);
	using FunctionType = decltype(loadLeaderboardFailed(p0))(*)(LeaderboardsLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x4ebea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelFeatureLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelFeatureLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelFeatureLayer*);
	static auto func = wrapFunction(base::get() + 0x4e0430, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelOptionsLayer::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&LevelOptionsLayer::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(LevelOptionsLayer*, int, float);
	static auto func = wrapFunction(base::get() + 0x24fbc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelOptionsLayer::getValue(int p0) -> decltype(getValue(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelOptionsLayer::getValue), this);
	using FunctionType = decltype(getValue(p0))(*)(LevelOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x24fbe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LevelOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(LevelOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x24f5f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelOptionsLayer::didToggle(int p0) -> decltype(didToggle(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&LevelOptionsLayer::didToggle), this);
	using FunctionType = decltype(didToggle(p0))(*)(LevelOptionsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x24fc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto PromoInterstitial::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&PromoInterstitial::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(PromoInterstitial*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2aeef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PromoInterstitial::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&PromoInterstitial::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(PromoInterstitial*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2af110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PromoInterstitial::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&PromoInterstitial::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(PromoInterstitial*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2aeff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PromoInterstitial::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&PromoInterstitial::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(PromoInterstitial*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x2af090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PromoInterstitial::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PromoInterstitial::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(PromoInterstitial*);
	static auto func = wrapFunction(base::get() + 0x2aed50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PromoInterstitial::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PromoInterstitial::show), this);
	using FunctionType = decltype(show())(*)(PromoInterstitial*);
	static auto func = wrapFunction(base::get() + 0x2aed20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PulseEffectAction::step(float p0) -> decltype(step(p0)) {
	throw std::runtime_error("PulseEffectAction::step not implemented");
}

auto PurchaseItemPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PurchaseItemPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(PurchaseItemPopup*);
	static auto func = wrapFunction(base::get() + 0x305650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardUnlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&RewardUnlockLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(RewardUnlockLayer*);
	static auto func = wrapFunction(base::get() + 0x1fd870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto RewardUnlockLayer::currencyWillExit(CurrencyRewardLayer* p0) -> decltype(currencyWillExit(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CurrencyRewardLayer*>::func(&RewardUnlockLayer::currencyWillExit), this);
	using FunctionType = decltype(currencyWillExit(p0))(*)(RewardUnlockLayer*, CurrencyRewardLayer*);
	static auto func = wrapFunction(base::get() + 0x1fd830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretNumberLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretNumberLayer::init), this);
	using FunctionType = decltype(init())(*)(SecretNumberLayer*);
	static auto func = wrapFunction(base::get() + 0x47f190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupOpacityPopup::create(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x59f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto SetupOpacityPopup::init(EffectGameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(SetupOpacityPopup*, EffectGameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x5a1e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto SetupOpacityPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupOpacityPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5b9c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupOpacityPopup::sliderChanged(cocos2d::CCObject* p0) -> decltype(sliderChanged(p0)) {
	using FunctionType = decltype(sliderChanged(p0))(*)(SetupOpacityPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5b000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupOpacityPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupOpacityPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupOpacityPopup*);
	static auto func = wrapFunction(base::get() + 0x5b3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupOpacityPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupOpacityPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupOpacityPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5b720, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupOpacityPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupOpacityPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupOpacityPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5b760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SmartTemplateCell::loadFromObject(GJSmartTemplate* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(SmartTemplateCell*, GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x22bb00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SmartTemplateCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SmartTemplateCell::init), this);
	using FunctionType = decltype(init())(*)(SmartTemplateCell*);
	static auto func = wrapFunction(base::get() + 0x237000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SmartTemplateCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SmartTemplateCell::draw), this);
	using FunctionType = decltype(draw())(*)(SmartTemplateCell*);
	static auto func = wrapFunction(base::get() + 0x2370d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto VideoOptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x75d140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto VideoOptionsLayer::onApply(cocos2d::CCObject* sender) -> decltype(onApply(sender)) {
	using FunctionType = decltype(onApply(sender))(*)(VideoOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x761e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto VideoOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&VideoOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(VideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x760bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto VideoOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&VideoOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(VideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x7625b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AchievementManager::getAchievementsWithID(char const* p0) -> decltype(getAchievementsWithID(p0)) {
	using FunctionType = decltype(getAchievementsWithID(p0))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x746b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(AchievementManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x7467f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)(AchievementManager*);
	static auto func = wrapFunction(base::get() + 0x6eed90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto AchievementManager::isAchievementEarned(char const* p0) -> decltype(isAchievementEarned(p0)) {
	using FunctionType = decltype(isAchievementEarned(p0))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x7469d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::limitForAchievement(gd::string p0) -> decltype(limitForAchievement(p0)) {
	using FunctionType = decltype(limitForAchievement(p0))(*)(AchievementManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x746c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::achievementForUnlock(int p0, UnlockType p1) -> decltype(achievementForUnlock(p0, p1)) {
	using FunctionType = decltype(achievementForUnlock(p0, p1))(*)(AchievementManager*, int, UnlockType);
	static auto func = wrapFunction(base::get() + 0x746d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto AchievementManager::percentForAchievement(char const* p0) -> decltype(percentForAchievement(p0)) {
	using FunctionType = decltype(percentForAchievement(p0))(*)(AchievementManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x7469f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AchievementManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AchievementManager::init), this);
	using FunctionType = decltype(init())(*)(AchievementManager*);
	static auto func = wrapFunction(base::get() + 0x6eeea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AnimatedGameObject::playAnimation(int p0) -> decltype(playAnimation(p0)) {
	using FunctionType = decltype(playAnimation(p0))(*)(AnimatedGameObject*, int);
	static auto func = wrapFunction(base::get() + 0x1a13a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto AnimatedGameObject::displayFrameChanged(cocos2d::CCObject* p0, gd::string p1) -> decltype(displayFrameChanged(p0, p1)) {
	using FunctionType = decltype(displayFrameChanged(p0, p1))(*)(AnimatedGameObject*, cocos2d::CCObject*, gd::string);
	static auto func = wrapFunction(base::get() + 0x1a0fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto AnimatedGameObject::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&AnimatedGameObject::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(AnimatedGameObject*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x19fa60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::setChildColor(cocos2d::_ccColor3B const& p0) -> decltype(setChildColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&AnimatedGameObject::setChildColor), this);
	using FunctionType = decltype(setChildColor(p0))(*)(AnimatedGameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x1a17a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::resetObject() -> decltype(resetObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AnimatedGameObject::resetObject), this);
	using FunctionType = decltype(resetObject())(*)(AnimatedGameObject*);
	static auto func = wrapFunction(base::get() + 0x1a1730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AnimatedGameObject::activateObject() -> decltype(activateObject()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AnimatedGameObject::activateObject), this);
	using FunctionType = decltype(activateObject())(*)(AnimatedGameObject*);
	static auto func = wrapFunction(base::get() + 0x19f990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AnimatedGameObject::deactivateObject(bool p0) -> decltype(deactivateObject(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&AnimatedGameObject::deactivateObject), this);
	using FunctionType = decltype(deactivateObject(p0))(*)(AnimatedGameObject*, bool);
	static auto func = wrapFunction(base::get() + 0x19f9d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::setObjectColor(cocos2d::_ccColor3B const& p0) -> decltype(setObjectColor(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::_ccColor3B const&>::func(&AnimatedGameObject::setObjectColor), this);
	using FunctionType = decltype(setObjectColor(p0))(*)(AnimatedGameObject*, cocos2d::_ccColor3B const&);
	static auto func = wrapFunction(base::get() + 0x19fb40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedGameObject::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&AnimatedGameObject::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(AnimatedGameObject*, char const*);
	static auto func = wrapFunction(base::get() + 0x19fb70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AnimatedShopKeeper::animationFinished(char const* p0) -> decltype(animationFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&AnimatedShopKeeper::animationFinished), this);
	using FunctionType = decltype(animationFinished(p0))(*)(AnimatedShopKeeper*, char const*);
	static auto func = wrapFunction(base::get() + 0x3057b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CharacterColorPage::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x61fec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto CharacterColorPage::onPlayerColor(cocos2d::CCObject* sender) -> decltype(onPlayerColor(sender)) {
	using FunctionType = decltype(onPlayerColor(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x621a50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::onMode(cocos2d::CCObject* sender) -> decltype(onMode(sender)) {
	using FunctionType = decltype(onMode(sender))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x620db0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CharacterColorPage::toggleGlow(cocos2d::CCObject* p0) -> decltype(toggleGlow(p0)) {
	using FunctionType = decltype(toggleGlow(p0))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x6214b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::toggleShip(cocos2d::CCObject* p0) -> decltype(toggleShip(p0)) {
	using FunctionType = decltype(toggleShip(p0))(*)(CharacterColorPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x620d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::colorForIndex(int p0) -> decltype(colorForIndex(p0)) {
	using FunctionType = decltype(colorForIndex(p0))(*)(CharacterColorPage*, int);
	static auto func = wrapFunction(base::get() + 0x621a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::offsetForIndex(int p0) -> decltype(offsetForIndex(p0)) {
	using FunctionType = decltype(offsetForIndex(p0))(*)(CharacterColorPage*, int);
	static auto func = wrapFunction(base::get() + 0x621ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::createColorMenu() -> decltype(createColorMenu()) {
	using FunctionType = decltype(createColorMenu())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x6210e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CharacterColorPage::updateColorMode(int p0) -> decltype(updateColorMode(p0)) {
	using FunctionType = decltype(updateColorMode(p0))(*)(CharacterColorPage*, int);
	static auto func = wrapFunction(base::get() + 0x6214f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CharacterColorPage::updateIconColors() -> decltype(updateIconColors()) {
	using FunctionType = decltype(updateIconColors())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x620f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

int CharacterColorPage::activeColorForMode(int mode) {
		switch (mode) {
			case 0:
				return GameManager::get()->m_playerColor;
			case 1:
				return GameManager::get()->m_playerColor2;
			case 2:
				return GameManager::get()->m_playerGlowColor;
			default:
				return 0;
		}
	}

auto CharacterColorPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::init), this);
	using FunctionType = decltype(init())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x620020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x621ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x621f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CharacterColorPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CharacterColorPage::show), this);
	using FunctionType = decltype(show())(*)(CharacterColorPage*);
	static auto func = wrapFunction(base::get() + 0x621dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ColorSetupDelegate::colorSetupClosed(int p0) -> decltype(colorSetupClosed(p0)) {
	throw std::runtime_error("ColorSetupDelegate::colorSetupClosed not implemented");
}

auto ConfigureHSVWidget::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureHSVWidget::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(ConfigureHSVWidget*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x410320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ConfigureHSVWidget::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureHSVWidget::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(ConfigureHSVWidget*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x410340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ConfigureHSVWidget::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&ConfigureHSVWidget::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(ConfigureHSVWidget*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x410380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto EditorOptionsLayer::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x27b7d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto EditorOptionsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(EditorOptionsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27c3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto EditorOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(EditorOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x27ba30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto EditorOptionsLayer::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&EditorOptionsLayer::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(EditorOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x27ba60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FriendRequestPopup::create(GJFriendRequest* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJFriendRequest*);
	static auto func = wrapFunction(base::get() + 0x280e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto FriendRequestPopup::init(GJFriendRequest* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FriendRequestPopup*, GJFriendRequest*);
	static auto func = wrapFunction(base::get() + 0x280f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FriendRequestPopup::onBlock(cocos2d::CCObject* sender) -> decltype(onBlock(sender)) {
	using FunctionType = decltype(onBlock(sender))(*)(FriendRequestPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x282090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FriendRequestPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(FriendRequestPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x281550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FriendRequestPopup::onAccept(cocos2d::CCObject* sender) -> decltype(onAccept(sender)) {
	using FunctionType = decltype(onAccept(sender))(*)(FriendRequestPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x281ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FriendRequestPopup::onRemove(cocos2d::CCObject* sender) -> decltype(onRemove(sender)) {
	using FunctionType = decltype(onRemove(sender))(*)(FriendRequestPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x281fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto FriendRequestPopup::loadFromGJFriendRequest(GJFriendRequest* p0) -> decltype(loadFromGJFriendRequest(p0)) {
	using FunctionType = decltype(loadFromGJFriendRequest(p0))(*)(FriendRequestPopup*, GJFriendRequest*);
	static auto func = wrapFunction(base::get() + 0x2815c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FriendRequestPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FriendRequestPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FriendRequestPopup*);
	static auto func = wrapFunction(base::get() + 0x282380, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FriendRequestPopup::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FriendRequestPopup::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(FriendRequestPopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x282470, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendRequestPopup::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FriendRequestPopup::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(FriendRequestPopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x282630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendRequestPopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&FriendRequestPopup::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(FriendRequestPopup*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x282700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FriendRequestPopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&FriendRequestPopup::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(FriendRequestPopup*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x282870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendsProfilePage::create(UserListType p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(UserListType);
	static auto func = wrapFunction(base::get() + 0x61b4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto FriendsProfilePage::init(UserListType p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FriendsProfilePage*, UserListType);
	static auto func = wrapFunction(base::get() + 0x61b640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FriendsProfilePage::setupUsersBrowser(cocos2d::CCArray* p0, UserListType p1) -> decltype(setupUsersBrowser(p0, p1)) {
	using FunctionType = decltype(setupUsersBrowser(p0, p1))(*)(FriendsProfilePage*, cocos2d::CCArray*, UserListType);
	static auto func = wrapFunction(base::get() + 0x61bef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FriendsProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FriendsProfilePage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FriendsProfilePage*);
	static auto func = wrapFunction(base::get() + 0x61c510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FriendsProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FriendsProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FriendsProfilePage*);
	static auto func = wrapFunction(base::get() + 0x61c4e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FriendsProfilePage::getUserListFinished(cocos2d::CCArray* p0, UserListType p1) -> decltype(getUserListFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, UserListType>::func(&FriendsProfilePage::getUserListFinished), this);
	using FunctionType = decltype(getUserListFinished(p0, p1))(*)(FriendsProfilePage*, cocos2d::CCArray*, UserListType);
	static auto func = wrapFunction(base::get() + 0x61c160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendsProfilePage::getUserListFailed(UserListType p0, GJErrorCode p1) -> decltype(getUserListFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<UserListType, GJErrorCode>::func(&FriendsProfilePage::getUserListFailed), this);
	using FunctionType = decltype(getUserListFailed(p0, p1))(*)(FriendsProfilePage*, UserListType, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x61c2a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendsProfilePage::userListChanged(cocos2d::CCArray* p0, UserListType p1) -> decltype(userListChanged(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, UserListType>::func(&FriendsProfilePage::userListChanged), this);
	using FunctionType = decltype(userListChanged(p0, p1))(*)(FriendsProfilePage*, cocos2d::CCArray*, UserListType);
	static auto func = wrapFunction(base::get() + 0x61c3b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FriendsProfilePage::forceReloadList(UserListType p0) -> decltype(forceReloadList(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UserListType>::func(&FriendsProfilePage::forceReloadList), this);
	using FunctionType = decltype(forceReloadList(p0))(*)(FriendsProfilePage*, UserListType);
	static auto func = wrapFunction(base::get() + 0x61c3f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJDifficultySprite::create(int p0, GJDifficultyName p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x291d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJDifficultySprite::getDifficultyFrame(int p0, GJDifficultyName p1) -> decltype(getDifficultyFrame(p0, p1)) {
	using FunctionType = decltype(getDifficultyFrame(p0, p1))(*)(GJDifficultySprite*, int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x291e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJDifficultySprite::updateFeatureState(GJFeatureState p0) -> decltype(updateFeatureState(p0)) {
	using FunctionType = decltype(updateFeatureState(p0))(*)(GJDifficultySprite*, GJFeatureState);
	static auto func = wrapFunction(base::get() + 0x292100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJDifficultySprite::updateDifficultyFrame(int p0, GJDifficultyName p1) -> decltype(updateDifficultyFrame(p0, p1)) {
	using FunctionType = decltype(updateDifficultyFrame(p0, p1))(*)(GJDifficultySprite*, int, GJDifficultyName);
	static auto func = wrapFunction(base::get() + 0x291f80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJDifficultySprite::updateFeatureStateFromLevel(GJGameLevel* p0) -> decltype(updateFeatureStateFromLevel(p0)) {
	using FunctionType = decltype(updateFeatureStateFromLevel(p0))(*)(GJDifficultySprite*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x2920b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJGameLoadingLayer::create(GJGameLevel* p0, bool p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x151030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJGameLoadingLayer::init(GJGameLevel* p0, bool p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJGameLoadingLayer*, GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x151390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJGameLoadingLayer::gameLayerDidUnload() -> decltype(gameLayerDidUnload()) {
	using FunctionType = decltype(gameLayerDidUnload())(*)(GJGameLoadingLayer*);
	static auto func = wrapFunction(base::get() + 0xfa680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLoadingLayer::transitionToLoadingLayer(GJGameLevel* p0, bool p1) -> decltype(transitionToLoadingLayer(p0, p1)) {
	using FunctionType = decltype(transitionToLoadingLayer(p0, p1))(*)(GJGameLevel*, bool);
	static auto func = wrapFunction(base::get() + 0x150f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJGameLoadingLayer::loadLevel() -> decltype(loadLevel()) {
	using FunctionType = decltype(loadLevel())(*)(GJGameLoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x151490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJGameLoadingLayer::onEnter() -> decltype(onEnter()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLoadingLayer::onEnter), this);
	using FunctionType = decltype(onEnter())(*)(GJGameLoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x151500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJGameLoadingLayer::onEnterTransitionDidFinish() -> decltype(onEnterTransitionDidFinish()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJGameLoadingLayer::onEnterTransitionDidFinish), this);
	using FunctionType = decltype(onEnterTransitionDidFinish())(*)(GJGameLoadingLayer*);
	static auto func = wrapFunction(base::get() + 0x1514f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJTransformControl::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x57e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto GJTransformControl::updateButtons(bool p0, bool p1) -> decltype(updateButtons(p0, p1)) {
	using FunctionType = decltype(updateButtons(p0, p1))(*)(GJTransformControl*, bool, bool);
	static auto func = wrapFunction(base::get() + 0x4df90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJTransformControl::refreshControl() -> decltype(refreshControl()) {
	using FunctionType = decltype(refreshControl())(*)(GJTransformControl*);
	static auto func = wrapFunction(base::get() + 0x4d980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJTransformControl::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJTransformControl::init), this);
	using FunctionType = decltype(init())(*)(GJTransformControl*);
	static auto func = wrapFunction(base::get() + 0x561e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJTransformControl::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x56650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x56b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x570d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJTransformControl::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&GJTransformControl::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(GJTransformControl*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x572e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto KeybindingsManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(KeybindingsManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x4c12a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto KeybindingsManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)(KeybindingsManager*);
	static auto func = wrapFunction(base::get() + 0x4c0c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto KeybindingsManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&KeybindingsManager::init), this);
	using FunctionType = decltype(init())(*)(KeybindingsManager*);
	static auto func = wrapFunction(base::get() + 0x4c0de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelOptionsLayer2::setupOptions() -> decltype(setupOptions()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelOptionsLayer2::setupOptions), this);
	using FunctionType = decltype(setupOptions())(*)(LevelOptionsLayer2*);
	static auto func = wrapFunction(base::get() + 0x24feb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsScrollLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsScrollLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(OptionsScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x5d4d60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsScrollLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&OptionsScrollLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(OptionsScrollLayer*);
	static auto func = wrapFunction(base::get() + 0x5d4c30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto OptionsScrollLayer::cellPerformedAction(TableViewCell* p0, int p1, CellAction p2, cocos2d::CCNode* p3) -> decltype(cellPerformedAction(p0, p1, p2, p3)) {
	auto self = addresser::thunkAdjust(Resolve<TableViewCell*, int, CellAction, cocos2d::CCNode*>::func(&OptionsScrollLayer::cellPerformedAction), this);
	using FunctionType = decltype(cellPerformedAction(p0, p1, p2, p3))(*)(OptionsScrollLayer*, TableViewCell*, int, CellAction, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x5d4da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2, p3);
}

auto SecretRewardsLayer::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x5f41b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SecretRewardsLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SecretRewardsLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5f42d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::onChestType(cocos2d::CCObject* sender) -> decltype(onChestType(sender)) {
	using FunctionType = decltype(onChestType(sender))(*)(SecretRewardsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5f5de0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SecretRewardsLayer::updateBackButton() -> decltype(updateBackButton()) {
	using FunctionType = decltype(updateBackButton())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x5f6b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretRewardsLayer::updateUnlockedLabel() -> decltype(updateUnlockedLabel()) {
	using FunctionType = decltype(updateUnlockedLabel())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x5f5ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SecretRewardsLayer::moveToSecondaryLayer(int p0) -> decltype(moveToSecondaryLayer(p0)) {
	using FunctionType = decltype(moveToSecondaryLayer(p0))(*)(SecretRewardsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x5f6830, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::scene(bool p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(SecretRewardsLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5f4170, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SecretRewardsLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretRewardsLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x5fdb10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretRewardsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SecretRewardsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SecretRewardsLayer*);
	static auto func = wrapFunction(base::get() + 0x5fda80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SecretRewardsLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&SecretRewardsLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(SecretRewardsLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x5fd930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SecretRewardsLayer::scrollLayerMoved(cocos2d::CCPoint p0) -> decltype(scrollLayerMoved(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCPoint>::func(&SecretRewardsLayer::scrollLayerMoved), this);
	using FunctionType = decltype(scrollLayerMoved(p0))(*)(SecretRewardsLayer*, cocos2d::CCPoint);
	static auto func = wrapFunction(base::get() + 0x5f6310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SelectPremadeLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectPremadeLayer::init), this);
	using FunctionType = decltype(init())(*)(SelectPremadeLayer*);
	static auto func = wrapFunction(base::get() + 0x2e6ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectPremadeLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectPremadeLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectPremadeLayer*);
	static auto func = wrapFunction(base::get() + 0x2e73b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectSFXSortLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectSFXSortLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectSFXSortLayer*);
	static auto func = wrapFunction(base::get() + 0x41f2e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupGradientPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupGradientPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5b8ca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupGradientPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupGradientPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupGradientPopup*);
	static auto func = wrapFunction(base::get() + 0x5b8b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupGradientPopup::updateToggleItem(int p0, bool p1) -> decltype(updateToggleItem(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupGradientPopup::updateToggleItem), this);
	using FunctionType = decltype(updateToggleItem(p0, p1))(*)(SetupGradientPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x5b8cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGradientPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGradientPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupGradientPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x5b8eb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupKeyframePopup::onCustomButton(cocos2d::CCObject* sender) -> decltype(onCustomButton(sender)) {
	using FunctionType = decltype(onCustomButton(sender))(*)(SetupKeyframePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1e0870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupKeyframePopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupKeyframePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1e07e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupKeyframePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupKeyframePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1e0c20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupKeyframePopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupKeyframePopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupKeyframePopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x1e05b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTeleportPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTeleportPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupTeleportPopup*);
	static auto func = wrapFunction(base::get() + 0x338fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTeleportPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTeleportPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupTeleportPopup*);
	static auto func = wrapFunction(base::get() + 0x338fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTeleportPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupTeleportPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupTeleportPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3390e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTimeWarpPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupTimeWarpPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4de0b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTimeWarpPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTimeWarpPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupTimeWarpPopup*);
	static auto func = wrapFunction(base::get() + 0x4ddf20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SpawnTriggerAction::step(float p0) -> decltype(step(p0)) {
	throw std::runtime_error("SpawnTriggerAction::step not implemented");
}

auto BrowseSmartTemplateLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(BrowseSmartTemplateLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4c6290, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto BrowseSmartTemplateLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&BrowseSmartTemplateLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(BrowseSmartTemplateLayer*);
	static auto func = wrapFunction(base::get() + 0x4c6250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto BrowseSmartKeyLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(BrowseSmartKeyLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4c7670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CollisionBlockPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CollisionBlockPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CollisionBlockPopup*);
	static auto func = wrapFunction(base::get() + 0x2653a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CollisionBlockPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CollisionBlockPopup::show), this);
	using FunctionType = decltype(show())(*)(CollisionBlockPopup*);
	static auto func = wrapFunction(base::get() + 0x265340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CollisionBlockPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CollisionBlockPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(CollisionBlockPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x265180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CollisionBlockPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CollisionBlockPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CollisionBlockPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2651c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CollisionBlockPopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&CollisionBlockPopup::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(CollisionBlockPopup*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x2653d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CollisionBlockPopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CollisionBlockPopup::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(CollisionBlockPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x265490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::init(ParticleGameObject* p0, cocos2d::CCArray* p1, gd::string p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(CreateParticlePopup*, ParticleGameObject*, cocos2d::CCArray*, gd::string);
	static auto func = wrapFunction(base::get() + 0x44c7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto CreateParticlePopup::update(float p0) -> decltype(update(p0)) {
	auto self = addresser::thunkAdjust(Resolve<float>::func(&CreateParticlePopup::update), this);
	using FunctionType = decltype(update(p0))(*)(CreateParticlePopup*, float);
	static auto func = wrapFunction(base::get() + 0x454030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x454bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x454cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x455090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&CreateParticlePopup::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(CreateParticlePopup*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4550e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CreateParticlePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CreateParticlePopup*);
	static auto func = wrapFunction(base::get() + 0x454a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CreateParticlePopup::sliderBegan(Slider* p0) -> decltype(sliderBegan(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&CreateParticlePopup::sliderBegan), this);
	using FunctionType = decltype(sliderBegan(p0))(*)(CreateParticlePopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x4548d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::sliderEnded(Slider* p0) -> decltype(sliderEnded(p0)) {
	auto self = addresser::thunkAdjust(Resolve<Slider*>::func(&CreateParticlePopup::sliderEnded), this);
	using FunctionType = decltype(sliderEnded(p0))(*)(CreateParticlePopup*, Slider*);
	static auto func = wrapFunction(base::get() + 0x4549b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&CreateParticlePopup::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(CreateParticlePopup*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x453da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&CreateParticlePopup::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(CreateParticlePopup*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x454a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CreateParticlePopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CreateParticlePopup::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(CreateParticlePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x454b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CreateParticlePopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(CreateParticlePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4541a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CreateParticlePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CreateParticlePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CreateParticlePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4541e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FriendRequestDelegate::loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadFRequestsFinished(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::loadFRequestsFinished not implemented");
}

auto FriendRequestDelegate::loadFRequestsFailed(char const* p0, GJErrorCode p1) -> decltype(loadFRequestsFailed(p0, p1)) {
	throw std::runtime_error("FriendRequestDelegate::loadFRequestsFailed not implemented");
}

auto FriendRequestDelegate::forceReloadRequests(bool p0) -> decltype(forceReloadRequests(p0)) {
	throw std::runtime_error("FriendRequestDelegate::forceReloadRequests not implemented");
}

auto FRequestProfilePage::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x7515d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto FRequestProfilePage::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(FRequestProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x751780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FRequestProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(FRequestProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x753750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto FRequestProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(FRequestProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x753390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FRequestProfilePage::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(FRequestProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x7527d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto FRequestProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FRequestProfilePage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(FRequestProfilePage*);
	static auto func = wrapFunction(base::get() + 0x752ef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FRequestProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&FRequestProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(FRequestProfilePage*);
	static auto func = wrapFunction(base::get() + 0x752ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto FRequestProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&FRequestProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(FRequestProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x752dd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&FRequestProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(FRequestProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x752f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto FRequestProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FRequestProfilePage::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(FRequestProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x752fa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&FRequestProfilePage::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(FRequestProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x753140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::loadFRequestsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadFRequestsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&FRequestProfilePage::loadFRequestsFinished), this);
	using FunctionType = decltype(loadFRequestsFinished(p0, p1))(*)(FRequestProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x753510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::loadFRequestsFailed(char const* p0, GJErrorCode p1) -> decltype(loadFRequestsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, GJErrorCode>::func(&FRequestProfilePage::loadFRequestsFailed), this);
	using FunctionType = decltype(loadFRequestsFailed(p0, p1))(*)(FRequestProfilePage*, char const*, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x753600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto FRequestProfilePage::forceReloadRequests(bool p0) -> decltype(forceReloadRequests(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&FRequestProfilePage::forceReloadRequests), this);
	using FunctionType = decltype(forceReloadRequests(p0))(*)(FRequestProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x753710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GauntletSelectLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x53cd80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GauntletSelectLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GauntletSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x53ce70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletSelectLayer::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x53e4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::onRefresh(cocos2d::CCObject* sender) -> decltype(onRefresh(sender)) {
	using FunctionType = decltype(onRefresh(sender))(*)(GauntletSelectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x53dad0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GauntletSelectLayer::setupGauntlets() -> decltype(setupGauntlets()) {
	using FunctionType = decltype(setupGauntlets())(*)(GauntletSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x53db90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GauntletSelectLayer::scene(int p0) -> decltype(scene(p0)) {
	using FunctionType = decltype(scene(p0))(*)(GauntletSelectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x53cc60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GauntletSelectLayer::goToPage(int p0, bool p1) -> decltype(goToPage(p0, p1)) {
	using FunctionType = decltype(goToPage(p0, p1))(*)(GauntletSelectLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x53e950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GauntletSelectLayer::onExit() -> decltype(onExit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GauntletSelectLayer::onExit), this);
	using FunctionType = decltype(onExit())(*)(GauntletSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x53ecc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GauntletSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GauntletSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x53eb90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GauntletSelectLayer::scrollLayerWillScrollToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerWillScrollToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&GauntletSelectLayer::scrollLayerWillScrollToPage), this);
	using FunctionType = decltype(scrollLayerWillScrollToPage(p0, p1))(*)(GauntletSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x53eaf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GauntletSelectLayer::scrollLayerScrolledToPage(BoomScrollLayer* p0, int p1) -> decltype(scrollLayerScrolledToPage(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<BoomScrollLayer*, int>::func(&GauntletSelectLayer::scrollLayerScrolledToPage), this);
	using FunctionType = decltype(scrollLayerScrolledToPage(p0, p1))(*)(GauntletSelectLayer*, BoomScrollLayer*, int);
	static auto func = wrapFunction(base::get() + 0x53ea50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GauntletSelectLayer::loadLevelsFinished(cocos2d::CCArray* p0, char const* p1, int p2) -> decltype(loadLevelsFinished(p0, p1, p2)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*, int>::func(&GauntletSelectLayer::loadLevelsFinished), this);
	using FunctionType = decltype(loadLevelsFinished(p0, p1, p2))(*)(GauntletSelectLayer*, cocos2d::CCArray*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x53e100, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1, p2);
}

auto GauntletSelectLayer::loadLevelsFailed(char const* p0, int p1) -> decltype(loadLevelsFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, int>::func(&GauntletSelectLayer::loadLevelsFailed), this);
	using FunctionType = decltype(loadLevelsFailed(p0, p1))(*)(GauntletSelectLayer*, char const*, int);
	static auto func = wrapFunction(base::get() + 0x53e2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UploadMessageDelegate::uploadMessageFinished(int p0) -> decltype(uploadMessageFinished(p0)) {
	throw std::runtime_error("UploadMessageDelegate::uploadMessageFinished not implemented");
}

auto UploadMessageDelegate::uploadMessageFailed(int p0) -> decltype(uploadMessageFailed(p0)) {
	throw std::runtime_error("UploadMessageDelegate::uploadMessageFailed not implemented");
}

auto GJWriteMessagePopup::create(int p0, int p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(int, int);
	static auto func = wrapFunction(base::get() + 0x283ff0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto GJWriteMessagePopup::init(int p0, int p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(GJWriteMessagePopup*, int, int);
	static auto func = wrapFunction(base::get() + 0x284a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJWriteMessagePopup::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJWriteMessagePopup::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(GJWriteMessagePopup*);
	static auto func = wrapFunction(base::get() + 0x286000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJWriteMessagePopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJWriteMessagePopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJWriteMessagePopup*);
	static auto func = wrapFunction(base::get() + 0x285fd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJWriteMessagePopup::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJWriteMessagePopup::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(GJWriteMessagePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x286080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJWriteMessagePopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(GJWriteMessagePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x286040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJWriteMessagePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJWriteMessagePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2860a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::uploadMessageFinished(int p0) -> decltype(uploadMessageFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJWriteMessagePopup::uploadMessageFinished), this);
	using FunctionType = decltype(uploadMessageFinished(p0))(*)(GJWriteMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x286690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::uploadMessageFailed(int p0) -> decltype(uploadMessageFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&GJWriteMessagePopup::uploadMessageFailed), this);
	using FunctionType = decltype(uploadMessageFailed(p0))(*)(GJWriteMessagePopup*, int);
	static auto func = wrapFunction(base::get() + 0x2867a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&GJWriteMessagePopup::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(GJWriteMessagePopup*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x2868c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJWriteMessagePopup::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&GJWriteMessagePopup::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(GJWriteMessagePopup*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x286a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJWriteMessagePopup::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&GJWriteMessagePopup::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(GJWriteMessagePopup*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x286af0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJWriteMessagePopup::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJWriteMessagePopup::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(GJWriteMessagePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x286bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GravityEffectSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GravityEffectSprite::init), this);
	using FunctionType = decltype(init())(*)(GravityEffectSprite*);
	static auto func = wrapFunction(base::get() + 0xb8f00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GravityEffectSprite::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GravityEffectSprite::draw), this);
	using FunctionType = decltype(draw())(*)(GravityEffectSprite*);
	static auto func = wrapFunction(base::get() + 0xb9160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GroupCommandObject2::step(float p0) -> decltype(step(p0)) {
	throw std::runtime_error("GroupCommandObject2::step not implemented");
}

auto LevelAreaInnerLayer::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelAreaInnerLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x2579a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelAreaInnerLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2586b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaInnerLayer::onDoor(cocos2d::CCObject* sender) -> decltype(onDoor(sender)) {
	using FunctionType = decltype(onDoor(sender))(*)(LevelAreaInnerLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x258700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelAreaInnerLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelAreaInnerLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(LevelAreaInnerLayer*);
	static auto func = wrapFunction(base::get() + 0x259590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelAreaInnerLayer::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&LevelAreaInnerLayer::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(LevelAreaInnerLayer*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x2593b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto LoadingCircleSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LoadingCircleSprite::init), this);
	using FunctionType = decltype(init())(*)(LoadingCircleSprite*);
	static auto func = wrapFunction(base::get() + 0x49ab60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MessageListDelegate::loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadMessagesFinished(p0, p1)) {
	throw std::runtime_error("MessageListDelegate::loadMessagesFinished not implemented");
}

auto MessageListDelegate::loadMessagesFailed(char const* p0, GJErrorCode p1) -> decltype(loadMessagesFailed(p0, p1)) {
	throw std::runtime_error("MessageListDelegate::loadMessagesFailed not implemented");
}

auto MessageListDelegate::forceReloadMessages(bool p0) -> decltype(forceReloadMessages(p0)) {
	throw std::runtime_error("MessageListDelegate::forceReloadMessages not implemented");
}

auto MessagesProfilePage::create(bool p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(bool);
	static auto func = wrapFunction(base::get() + 0x20cdd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto MessagesProfilePage::init(bool p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(MessagesProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x20cf80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x20de00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x20dde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onSentMessages(cocos2d::CCObject* sender) -> decltype(onSentMessages(sender)) {
	using FunctionType = decltype(onSentMessages(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x20daa0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onDeleteSelected(cocos2d::CCObject* sender) -> decltype(onDeleteSelected(sender)) {
	using FunctionType = decltype(onDeleteSelected(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x20db30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onToggleAllObjects(cocos2d::CCObject* sender) -> decltype(onToggleAllObjects(sender)) {
	using FunctionType = decltype(onToggleAllObjects(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x20dd20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x20d970, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::onUpdate(cocos2d::CCObject* sender) -> decltype(onUpdate(sender)) {
	using FunctionType = decltype(onUpdate(sender))(*)(MessagesProfilePage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x20de20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto MessagesProfilePage::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(MessagesProfilePage*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x20ee60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MessagesProfilePage::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(MessagesProfilePage*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x20ea70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::loadPage(int p0) -> decltype(loadPage(p0)) {
	using FunctionType = decltype(loadPage(p0))(*)(MessagesProfilePage*, int);
	static auto func = wrapFunction(base::get() + 0x20de90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MessagesProfilePage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MessagesProfilePage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(MessagesProfilePage*);
	static auto func = wrapFunction(base::get() + 0x20e900, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MessagesProfilePage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MessagesProfilePage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MessagesProfilePage*);
	static auto func = wrapFunction(base::get() + 0x20e8d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MessagesProfilePage::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&MessagesProfilePage::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(MessagesProfilePage*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x20e4b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::onClosePopup(UploadActionPopup* p0) -> decltype(onClosePopup(p0)) {
	auto self = addresser::thunkAdjust(Resolve<UploadActionPopup*>::func(&MessagesProfilePage::onClosePopup), this);
	using FunctionType = decltype(onClosePopup(p0))(*)(MessagesProfilePage*, UploadActionPopup*);
	static auto func = wrapFunction(base::get() + 0x20e520, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MessagesProfilePage::uploadActionFinished(int p0, int p1) -> decltype(uploadActionFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MessagesProfilePage::uploadActionFinished), this);
	using FunctionType = decltype(uploadActionFinished(p0, p1))(*)(MessagesProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x20e590, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::uploadActionFailed(int p0, int p1) -> decltype(uploadActionFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, int>::func(&MessagesProfilePage::uploadActionFailed), this);
	using FunctionType = decltype(uploadActionFailed(p0, p1))(*)(MessagesProfilePage*, int, int);
	static auto func = wrapFunction(base::get() + 0x20e730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::loadMessagesFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadMessagesFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&MessagesProfilePage::loadMessagesFinished), this);
	using FunctionType = decltype(loadMessagesFinished(p0, p1))(*)(MessagesProfilePage*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x20ebe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::loadMessagesFailed(char const* p0, GJErrorCode p1) -> decltype(loadMessagesFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<char const*, GJErrorCode>::func(&MessagesProfilePage::loadMessagesFailed), this);
	using FunctionType = decltype(loadMessagesFailed(p0, p1))(*)(MessagesProfilePage*, char const*, GJErrorCode);
	static auto func = wrapFunction(base::get() + 0x20ed10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto MessagesProfilePage::forceReloadMessages(bool p0) -> decltype(forceReloadMessages(p0)) {
	auto self = addresser::thunkAdjust(Resolve<bool>::func(&MessagesProfilePage::forceReloadMessages), this);
	using FunctionType = decltype(forceReloadMessages(p0))(*)(MessagesProfilePage*, bool);
	static auto func = wrapFunction(base::get() + 0x20ee20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MultilineBitmapFont::initWithFont(char const* p0, gd::string p1, float p2, float p3, cocos2d::CCPoint p4, int p5, bool p6) -> decltype(initWithFont(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(initWithFont(p0, p1, p2, p3, p4, p5, p6))(*)(MultilineBitmapFont*, char const*, gd::string, float, float, cocos2d::CCPoint, int, bool);
	static auto func = wrapFunction(base::get() + 0x463bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto MultilineBitmapFont::readColorInfo(gd::string p0) -> decltype(readColorInfo(p0)) {
	using FunctionType = decltype(readColorInfo(p0))(*)(MultilineBitmapFont*, gd::string);
	static auto func = wrapFunction(base::get() + 0x464480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MultilineBitmapFont::createWithFont(char const* p0, gd::string p1, float p2, float p3, cocos2d::CCPoint p4, int p5, bool p6) -> decltype(createWithFont(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(createWithFont(p0, p1, p2, p3, p4, p5, p6))(*)(MultilineBitmapFont*, char const*, gd::string, float, float, cocos2d::CCPoint, int, bool);
	static auto func = wrapFunction(base::get() + 0x463a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto MultilineBitmapFont::stringWithMaxWidth(gd::string p0, float p1, float p2) -> decltype(stringWithMaxWidth(p0, p1, p2)) {
	using FunctionType = decltype(stringWithMaxWidth(p0, p1, p2))(*)(MultilineBitmapFont*, gd::string, float, float);
	static auto func = wrapFunction(base::get() + 0x465060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

auto MultilineBitmapFont::setOpacity(unsigned char p0) -> decltype(setOpacity(p0)) {
	auto self = addresser::thunkAdjust(Resolve<unsigned char>::func(&MultilineBitmapFont::setOpacity), this);
	using FunctionType = decltype(setOpacity(p0))(*)(MultilineBitmapFont*, unsigned char);
	static auto func = wrapFunction(base::get() + 0x4654e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto NewgroundsInfoLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NewgroundsInfoLayer::init), this);
	using FunctionType = decltype(init())(*)(NewgroundsInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x1f60d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NewgroundsInfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&NewgroundsInfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(NewgroundsInfoLayer*);
	static auto func = wrapFunction(base::get() + 0x1f6bc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto NewgroundsInfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&NewgroundsInfoLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(NewgroundsInfoLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1f6b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto OpacityEffectAction::step(float p0) -> decltype(step(p0)) {
	throw std::runtime_error("OpacityEffectAction::step not implemented");
}

auto SelectListIconLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SelectListIconLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SelectListIconLayer*);
	static auto func = wrapFunction(base::get() + 0x340490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SelectPremadeDelegate::selectPremadeClosed(SelectPremadeLayer* p0, int p1) -> decltype(selectPremadeClosed(p0, p1)) {
	throw std::runtime_error("SelectPremadeDelegate::selectPremadeClosed not implemented");
}

auto SetupAdvFollowPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupAdvFollowPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e6750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupAdvFollowPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupAdvFollowPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2e6e00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupAdvFollowPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAdvFollowPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAdvFollowPopup*);
	static auto func = wrapFunction(base::get() + 0x2e63b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAdvFollowPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAdvFollowPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAdvFollowPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x2e64f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAdvFollowPopup::selectPremadeClosed(SelectPremadeLayer* p0, int p1) -> decltype(selectPremadeClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<SelectPremadeLayer*, int>::func(&SetupAdvFollowPopup::selectPremadeClosed), this);
	using FunctionType = decltype(selectPremadeClosed(p0, p1))(*)(SetupAdvFollowPopup*, SelectPremadeLayer*, int);
	static auto func = wrapFunction(base::get() + 0x2e6980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAnimationPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupAnimationPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3b42b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupAnimationPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAnimationPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupAnimationPopup*);
	static auto func = wrapFunction(base::get() + 0x3b3e90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAnimationPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupAnimationPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupAnimationPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3b40c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupArtSwitchPopup::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&SetupArtSwitchPopup::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(SetupArtSwitchPopup*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x551000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::init), this);
	using FunctionType = decltype(init())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x471180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x473c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x473ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&AccountRegisterLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(AccountRegisterLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x473610, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountRegisterLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4746a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x473cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4746c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&AccountRegisterLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(AccountRegisterLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x4746e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto AccountRegisterLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4747a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::allowTextInput(CCTextInputNode* p0) -> decltype(allowTextInput(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&AccountRegisterLayer::allowTextInput), this);
	using FunctionType = decltype(allowTextInput(p0))(*)(AccountRegisterLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x474850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto AccountRegisterLayer::registerAccountFinished() -> decltype(registerAccountFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&AccountRegisterLayer::registerAccountFinished), this);
	using FunctionType = decltype(registerAccountFinished())(*)(AccountRegisterLayer*);
	static auto func = wrapFunction(base::get() + 0x472e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AccountRegisterLayer::registerAccountFailed(AccountError p0) -> decltype(registerAccountFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<AccountError>::func(&AccountRegisterLayer::registerAccountFailed), this);
	using FunctionType = decltype(registerAccountFailed(p0))(*)(AccountRegisterLayer*, AccountError);
	static auto func = wrapFunction(base::get() + 0x473010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CommunityCreditsPage::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::init), this);
	using FunctionType = decltype(init())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x2faf40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommunityCreditsPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x2fe2d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommunityCreditsPage::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x2fe260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CommunityCreditsPage::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CommunityCreditsPage::show), this);
	using FunctionType = decltype(show())(*)(CommunityCreditsPage*);
	static auto func = wrapFunction(base::get() + 0x2fe0d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomizeObjectLayer::init(GameObject* p0, cocos2d::CCArray* p1) -> decltype(init(p0, p1)) {
	using FunctionType = decltype(init(p0, p1))(*)(CustomizeObjectLayer*, GameObject*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x1d4180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto CustomizeObjectLayer::getActiveMode(bool p0) -> decltype(getActiveMode(p0)) {
	using FunctionType = decltype(getActiveMode(p0))(*)(CustomizeObjectLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x1d73f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::onSelectMode(cocos2d::CCObject* sender) -> decltype(onSelectMode(sender)) {
	using FunctionType = decltype(onSelectMode(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1d6550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onSelectColor(cocos2d::CCObject* sender) -> decltype(onSelectColor(sender)) {
	using FunctionType = decltype(onSelectColor(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1d6ac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::onUpdateCustomColor(cocos2d::CCObject* sender) -> decltype(onUpdateCustomColor(sender)) {
	using FunctionType = decltype(onUpdateCustomColor(sender))(*)(CustomizeObjectLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1d6b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectLayer::toggleVisible() -> decltype(toggleVisible()) {
	using FunctionType = decltype(toggleVisible())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x1d8230, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateSelected(int p0) -> decltype(updateSelected(p0)) {
	using FunctionType = decltype(updateSelected(p0))(*)(CustomizeObjectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1d7b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::highlightSelected(ButtonSprite* p0) -> decltype(highlightSelected(p0)) {
	using FunctionType = decltype(highlightSelected(p0))(*)(CustomizeObjectLayer*, ButtonSprite*);
	static auto func = wrapFunction(base::get() + 0x1d7d10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto CustomizeObjectLayer::updateColorSprite() -> decltype(updateColorSprite()) {
	using FunctionType = decltype(updateColorSprite())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x1d75c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::updateCustomColorLabels() -> decltype(updateCustomColorLabels()) {
	using FunctionType = decltype(updateCustomColorLabels())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x1d6c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto CustomizeObjectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&CustomizeObjectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(CustomizeObjectLayer*);
	static auto func = wrapFunction(base::get() + 0x1d8750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto CustomizeObjectLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomizeObjectLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(CustomizeObjectLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1d8390, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomizeObjectLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(CustomizeObjectLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1d84c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&CustomizeObjectLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(CustomizeObjectLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x1d8500, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::_ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<HSVWidgetPopup*, cocos2d::_ccHSVValue>::func(&CustomizeObjectLayer::hsvPopupClosed), this);
	using FunctionType = decltype(hsvPopupClosed(p0, p1))(*)(CustomizeObjectLayer*, HSVWidgetPopup*, cocos2d::_ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x1d8140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomizeObjectLayer::colorSelectClosed(cocos2d::CCNode* p0) -> decltype(colorSelectClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCNode*>::func(&CustomizeObjectLayer::colorSelectClosed), this);
	using FunctionType = decltype(colorSelectClosed(p0))(*)(CustomizeObjectLayer*, cocos2d::CCNode*);
	static auto func = wrapFunction(base::get() + 0x1d7ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto CustomizeObjectLayer::colorSetupClosed(int p0) -> decltype(colorSetupClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&CustomizeObjectLayer::colorSetupClosed), this);
	using FunctionType = decltype(colorSetupClosed(p0))(*)(CustomizeObjectLayer*, int);
	static auto func = wrapFunction(base::get() + 0x1d7a70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJFollowCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(GJFollowCommandLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2b1d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJFollowCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJFollowCommandLayer::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(GJFollowCommandLayer*);
	static auto func = wrapFunction(base::get() + 0x2b1160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJFollowCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJFollowCommandLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJFollowCommandLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x2b1770, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJMultiplayerManager::onJoinLobbyCompleted(gd::string p0, gd::string p1) -> decltype(onJoinLobbyCompleted(p0, p1)) {
	using FunctionType = decltype(onJoinLobbyCompleted(p0, p1))(*)(GJMultiplayerManager*, gd::string, gd::string);
	static auto func = wrapFunction(base::get() + 0x61cf30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMultiplayerManager::addComment(gd::string p0, int p1) -> decltype(addComment(p0, p1)) {
	using FunctionType = decltype(addComment(p0, p1))(*)(GJMultiplayerManager*, gd::string, int);
	static auto func = wrapFunction(base::get() + 0x61e550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMultiplayerManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMultiplayerManager::init), this);
	using FunctionType = decltype(init())(*)(GJMultiplayerManager*);
	static auto func = wrapFunction(base::get() + 0x61da60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotateCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(GJRotateCommandLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x8ab0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJRotateCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJRotateCommandLayer::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(GJRotateCommandLayer*);
	static auto func = wrapFunction(base::get() + 0x7b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJRotateCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJRotateCommandLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJRotateCommandLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x8510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto GJRotateCommandLayer::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&GJRotateCommandLayer::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(GJRotateCommandLayer*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x8080, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto PlatformDownloadDelegate::downloadFinished(char const* p0) -> decltype(downloadFinished(p0)) {
	throw std::runtime_error("PlatformDownloadDelegate::downloadFinished not implemented");
}

auto PlatformDownloadDelegate::downloadFailed(char const* p0) -> decltype(downloadFailed(p0)) {
	throw std::runtime_error("PlatformDownloadDelegate::downloadFailed not implemented");
}

auto MusicDownloadManager::getSongInfo(int p0, bool p1) -> decltype(getSongInfo(p0, p1)) {
	using FunctionType = decltype(getSongInfo(p0, p1))(*)(MusicDownloadManager*, int, bool);
	static auto func = wrapFunction(base::get() + 0x556950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::getSongInfoObject(int p0) -> decltype(getSongInfoObject(p0)) {
	using FunctionType = decltype(getSongInfoObject(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x556810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::onDownloadSongCompleted(cocos2d::extension::CCHttpClient* p0, cocos2d::extension::CCHttpResponse* p1) -> decltype(onDownloadSongCompleted(p0, p1)) {
	using FunctionType = decltype(onDownloadSongCompleted(p0, p1))(*)(MusicDownloadManager*, cocos2d::extension::CCHttpClient*, cocos2d::extension::CCHttpResponse*);
	static auto func = wrapFunction(base::get() + 0x558f70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::dataLoaded(DS_Dictionary* p0) -> decltype(dataLoaded(p0)) {
	using FunctionType = decltype(dataLoaded(p0))(*)(MusicDownloadManager*, DS_Dictionary*);
	static auto func = wrapFunction(base::get() + 0x55a150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::deleteSong(int p0) -> decltype(deleteSong(p0)) {
	using FunctionType = decltype(deleteSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x5585a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::isDLActive(char const* p0) -> decltype(isDLActive(p0)) {
	using FunctionType = decltype(isDLActive(p0))(*)(MusicDownloadManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x5565e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::pathForSFX(int sfxID) -> decltype(pathForSFX(sfxID)) {
	using FunctionType = decltype(pathForSFX(sfxID))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x559cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sfxID);
}

auto MusicDownloadManager::pathForSong(int songID) -> decltype(pathForSong(songID)) {
	using FunctionType = decltype(pathForSong(songID))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x5586d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, songID);
}

auto MusicDownloadManager::sharedState() -> decltype(sharedState()) {
	using FunctionType = decltype(sharedState())(*)();
	static auto func = wrapFunction(base::get() + 0x5552f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

auto MusicDownloadManager::downloadSong(int songID) -> decltype(downloadSong(songID)) {
	using FunctionType = decltype(downloadSong(songID))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x558880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, songID);
}

auto MusicDownloadManager::addDLToActive(char const* p0, cocos2d::CCObject* p1) -> decltype(addDLToActive(p0, p1)) {
	using FunctionType = decltype(addDLToActive(p0, p1))(*)(MusicDownloadManager*, char const*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x559210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto MusicDownloadManager::responseToDict(gd::string p0, char const* p1) -> decltype(responseToDict(p0, p1)) {
	using FunctionType = decltype(responseToDict(p0, p1))(*)(gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x556fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto MusicDownloadManager::createSongsInfo(gd::string p0) -> decltype(createSongsInfo(p0)) {
	using FunctionType = decltype(createSongsInfo(p0))(*)(MusicDownloadManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x557a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::isSFXDownloaded(int sfxID) -> decltype(isSFXDownloaded(sfxID)) {
	using FunctionType = decltype(isSFXDownloaded(sfxID))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x559880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sfxID);
}

auto MusicDownloadManager::isSongDownloaded(int p0) -> decltype(isSongDownloaded(p0)) {
	using FunctionType = decltype(isSongDownloaded(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x558160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::pathForSFXFolder(int p0) -> decltype(pathForSFXFolder(p0)) {
	using FunctionType = decltype(pathForSFXFolder(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x559d70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::pathForSongFolder(int p0) -> decltype(pathForSongFolder(p0)) {
	using FunctionType = decltype(pathForSongFolder(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x559640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::downloadCustomSong(int p0) -> decltype(downloadCustomSong(p0)) {
	using FunctionType = decltype(downloadCustomSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x558d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::removeDLFromActive(char const* p0) -> decltype(removeDLFromActive(p0)) {
	using FunctionType = decltype(removeDLFromActive(p0))(*)(MusicDownloadManager*, char const*);
	static auto func = wrapFunction(base::get() + 0x5566b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::limitDownloadedSongs() -> decltype(limitDownloadedSongs()) {
	using FunctionType = decltype(limitDownloadedSongs())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x558460, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto MusicDownloadManager::addSongObjectFromString(gd::string p0) -> decltype(addSongObjectFromString(p0)) {
	using FunctionType = decltype(addSongObjectFromString(p0))(*)(MusicDownloadManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x556e20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::addMusicDownloadDelegate(MusicDownloadDelegate* p0) -> decltype(addMusicDownloadDelegate(p0)) {
	using FunctionType = decltype(addMusicDownloadDelegate(p0))(*)(MusicDownloadManager*, MusicDownloadDelegate*);
	static auto func = wrapFunction(base::get() + 0x556340, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::incrementPriorityForSong(int p0) -> decltype(incrementPriorityForSong(p0)) {
	using FunctionType = decltype(incrementPriorityForSong(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x5567e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::isRunningActionForSongID(int p0) -> decltype(isRunningActionForSongID(p0)) {
	using FunctionType = decltype(isRunningActionForSongID(p0))(*)(MusicDownloadManager*, int);
	static auto func = wrapFunction(base::get() + 0x5564c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::showTOS(FLAlertLayerProtocol* p0) -> decltype(showTOS(p0)) {
	using FunctionType = decltype(showTOS(p0))(*)(MusicDownloadManager*, FLAlertLayerProtocol*);
	static auto func = wrapFunction(base::get() + 0x559fb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto MusicDownloadManager::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MusicDownloadManager::init), this);
	using FunctionType = decltype(init())(*)(MusicDownloadManager*);
	static auto func = wrapFunction(base::get() + 0x556190, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParentalOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParentalOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(ParentalOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x764f10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParentalOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParentalOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(ParentalOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x766640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticlePreviewLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticlePreviewLayer::draw), this);
	using FunctionType = decltype(draw())(*)(ParticlePreviewLayer*);
	static auto func = wrapFunction(base::get() + 0x455300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ParticlePreviewLayer::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ParticlePreviewLayer::visit), this);
	using FunctionType = decltype(visit())(*)(ParticlePreviewLayer*);
	static auto func = wrapFunction(base::get() + 0x455180, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCameraEdgePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupCameraEdgePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x554ce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupCameraEdgePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCameraEdgePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCameraEdgePopup*);
	static auto func = wrapFunction(base::get() + 0x554a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCameraEdgePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCameraEdgePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCameraEdgePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x554bd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCameraModePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupCameraModePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x485e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupCameraModePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCameraModePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCameraModePopup*);
	static auto func = wrapFunction(base::get() + 0x485b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupForceBlockPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupForceBlockPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupForceBlockPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x550730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGravityModPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupGravityModPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupGravityModPopup*);
	static auto func = wrapFunction(base::get() + 0x3b7be0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupGravityModPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupGravityModPopup::show), this);
	using FunctionType = decltype(show())(*)(SetupGravityModPopup*);
	static auto func = wrapFunction(base::get() + 0x3b7b80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupGravityModPopup::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupGravityModPopup::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupGravityModPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3b7a40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupGravityModPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupGravityModPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupGravityModPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x3b7a80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartBlockLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSmartBlockLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupSmartBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4c3160, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSmartBlockLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSmartBlockLayer::show), this);
	using FunctionType = decltype(show())(*)(SetupSmartBlockLayer*);
	static auto func = wrapFunction(base::get() + 0x4c30d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSmartBlockLayer::selectArtClosed(SelectArtLayer* p0) -> decltype(selectArtClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectArtLayer*>::func(&SetupSmartBlockLayer::selectArtClosed), this);
	using FunctionType = decltype(selectArtClosed(p0))(*)(SetupSmartBlockLayer*, SelectArtLayer*);
	static auto func = wrapFunction(base::get() + 0x4c3130, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SongPlaybackDelegate::onPlayback(SongInfoObject* p0) -> decltype(onPlayback(p0)) {
	throw std::runtime_error("SongPlaybackDelegate::onPlayback not implemented");
}

auto GJLocalLevelScoreCell::loadFromScore(GJLocalScore* p0) -> decltype(loadFromScore(p0)) {
	using FunctionType = decltype(loadFromScore(p0))(*)(GJLocalLevelScoreCell*, GJLocalScore*);
	static auto func = wrapFunction(base::get() + 0x229fc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJLocalLevelScoreCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLocalLevelScoreCell::init), this);
	using FunctionType = decltype(init())(*)(GJLocalLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0x233e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJLocalLevelScoreCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJLocalLevelScoreCell::draw), this);
	using FunctionType = decltype(draw())(*)(GJLocalLevelScoreCell*);
	static auto func = wrapFunction(base::get() + 0x233e60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPFollowCommandLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(GJPFollowCommandLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3461d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJPFollowCommandLayer::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJPFollowCommandLayer::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(GJPFollowCommandLayer*);
	static auto func = wrapFunction(base::get() + 0x345440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJPFollowCommandLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJPFollowCommandLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(GJPFollowCommandLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x345a60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto MoreVideoOptionsLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreVideoOptionsLayer::init), this);
	using FunctionType = decltype(init())(*)(MoreVideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x762a30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto MoreVideoOptionsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&MoreVideoOptionsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(MoreVideoOptionsLayer*);
	static auto func = wrapFunction(base::get() + 0x764ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto PlayerFireBoostSprite::create() -> decltype(create()) {
	using FunctionType = decltype(create())(*)();
	static auto func = wrapFunction(base::get() + 0x3dd7e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)();
}

void PlayerFireBoostSprite::animateFireIn() {
		this->stopAllActions();

		auto scaleto = cocos2d::CCScaleTo::create(0.06f, m_someFloat * 0.6f, m_someFloat * 1.5f);
		auto callfunc = cocos2d::CCCallFunc::create(this, callfunc_selector(PlayerFireBoostSprite::loopFireAnimation));
		auto sequence = cocos2d::CCSequence::create(scaleto, callfunc, nullptr);
		this->runAction(sequence);
	}

void PlayerFireBoostSprite::animateFireOut() {
		this->stopAllActions();
		auto action = cocos2d::CCScaleTo::create(0.4f, 0.01f, 0.01f);
		this->runAction(action);
	}

auto PlayerFireBoostSprite::loopFireAnimation() -> decltype(loopFireAnimation()) {
	using FunctionType = decltype(loopFireAnimation())(*)(PlayerFireBoostSprite*);
	static auto func = wrapFunction(base::get() + 0x3f8530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto PlayerFireBoostSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&PlayerFireBoostSprite::init), this);
	using FunctionType = decltype(init())(*)(PlayerFireBoostSprite*);
	static auto func = wrapFunction(base::get() + 0x3fd6c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaMoveTriggerPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupAreaMoveTriggerPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0x4afcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAreaMoveTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAreaMoveTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x4af850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaMoveTriggerPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4afca0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4afb60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4afc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaMoveTriggerPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaMoveTriggerPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupAreaMoveTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4afc70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupEnterEffectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3d4f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupEnterEffectPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupEnterEffectPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupEnterEffectPopup*);
	static auto func = wrapFunction(base::get() + 0x3d4b00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupEnterEffectPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupEnterEffectPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupEnterEffectPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0x3d50c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupEnterEffectPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupEnterEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3d5090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupEnterEffectPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupEnterEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3d4cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupEnterEffectPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupEnterEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3d5020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupEnterEffectPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupEnterEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3d5060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupEnterEffectPopup::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::_ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<HSVWidgetPopup*, cocos2d::_ccHSVValue>::func(&SetupEnterEffectPopup::hsvPopupClosed), this);
	using FunctionType = decltype(hsvPopupClosed(p0, p1))(*)(SetupEnterEffectPopup*, HSVWidgetPopup*, cocos2d::_ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x3d4d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupMoveCommandPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5cd6d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupMoveCommandPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupMoveCommandPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupMoveCommandPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0x5cd490, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupMoveCommandPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupMoveCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x5cd450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupMoveCommandPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupMoveCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x5cd4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupMoveCommandPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupMoveCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x5cd370, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupMoveCommandPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupMoveCommandPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupMoveCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x5cd3c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRandTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupRandTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ab930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRandTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupRandTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupRandTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x5ab350, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupRandTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupRandTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupRandTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5ab640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSongTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupSongTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2ae810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupSongTriggerPopup::pageChanged() -> decltype(pageChanged()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSongTriggerPopup::pageChanged), this);
	using FunctionType = decltype(pageChanged())(*)(SetupSongTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x2ae780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSongTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupSongTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupSongTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x2ae680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupSongTriggerPopup::onPlayback(SongInfoObject* p0) -> decltype(onPlayback(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SongInfoObject*>::func(&SetupSongTriggerPopup::onPlayback), this);
	using FunctionType = decltype(onPlayback(p0))(*)(SetupSongTriggerPopup*, SongInfoObject*);
	static auto func = wrapFunction(base::get() + 0x2ae450, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupStopTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupStopTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x551990, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupStopTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupStopTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x551a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTouchTogglePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupTouchTogglePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x294270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupTouchTogglePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupTouchTogglePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupTouchTogglePopup*);
	static auto func = wrapFunction(base::get() + 0x293f30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupTouchTogglePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupTouchTogglePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupTouchTogglePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x294150, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupZoomTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupZoomTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2fea60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupZoomTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupZoomTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupZoomTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x2fea50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UIObjectSettingsPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(UIObjectSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x548b40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto DemonFilterSelectLayer::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DemonFilterSelectLayer::init), this);
	using FunctionType = decltype(init())(*)(DemonFilterSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x5f3710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto DemonFilterSelectLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&DemonFilterSelectLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(DemonFilterSelectLayer*);
	static auto func = wrapFunction(base::get() + 0x5f3d00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountSettingsLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x27cea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJAccountSettingsLayer::init(int p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJAccountSettingsLayer*, int);
	static auto func = wrapFunction(base::get() + 0x27d020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJAccountSettingsLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(GJAccountSettingsLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x27eac0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto GJAccountSettingsLayer::createToggleButton(gd::string p0, cocos2d::SEL_MenuHandler p1, bool p2, cocos2d::CCMenu* p3, cocos2d::CCPoint p4, float p5, float p6) -> decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6)) {
	using FunctionType = decltype(createToggleButton(p0, p1, p2, p3, p4, p5, p6))(*)(GJAccountSettingsLayer*, gd::string, cocos2d::SEL_MenuHandler, bool, cocos2d::CCMenu*, cocos2d::CCPoint, float, float);
	static auto func = wrapFunction(base::get() + 0x27e750, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2, p3, p4, p5, p6);
}

auto GJAccountSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJAccountSettingsLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(GJAccountSettingsLayer*);
	static auto func = wrapFunction(base::get() + 0x27f320, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJAccountSettingsLayer::textInputShouldOffset(CCTextInputNode* p0, float p1) -> decltype(textInputShouldOffset(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*, float>::func(&GJAccountSettingsLayer::textInputShouldOffset), this);
	using FunctionType = decltype(textInputShouldOffset(p0, p1))(*)(GJAccountSettingsLayer*, CCTextInputNode*, float);
	static auto func = wrapFunction(base::get() + 0x27ee30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJAccountSettingsLayer::textInputReturn(CCTextInputNode* p0) -> decltype(textInputReturn(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&GJAccountSettingsLayer::textInputReturn), this);
	using FunctionType = decltype(textInputReturn(p0))(*)(GJAccountSettingsLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x27eef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupAnimSettingsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupAnimSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x95300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupCameraRotatePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupCameraRotatePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x499d90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupCameraRotatePopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCameraRotatePopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCameraRotatePopup*);
	static auto func = wrapFunction(base::get() + 0x4995d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCameraRotatePopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCameraRotatePopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCameraRotatePopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x499b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCameraRotatePopup::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupCameraRotatePopup::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupCameraRotatePopup*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x499850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupCountTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupCountTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x296ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupCountTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCountTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCountTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x296930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCountTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCountTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCountTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x296c60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupEnterTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupEnterTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupEnterTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x279480, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupInstantCountPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupInstantCountPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5af240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupInstantCountPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupInstantCountPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupInstantCountPopup*);
	static auto func = wrapFunction(base::get() + 0x5aec10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupInstantCountPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupInstantCountPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupInstantCountPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x5aef50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupObjectTogglePopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupObjectTogglePopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x354710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupObjectTogglePopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupObjectTogglePopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupObjectTogglePopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x354690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupShaderEffectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupShaderEffectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2aa8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupShaderEffectPopup::toggleGroup(int p0, bool p1) -> decltype(toggleGroup(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, bool>::func(&SetupShaderEffectPopup::toggleGroup), this);
	using FunctionType = decltype(toggleGroup(p0, p1))(*)(SetupShaderEffectPopup*, int, bool);
	static auto func = wrapFunction(base::get() + 0x2aa870, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupShaderEffectPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupShaderEffectPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupShaderEffectPopup*);
	static auto func = wrapFunction(base::get() + 0x2aa010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupShaderEffectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupShaderEffectPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupShaderEffectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x2aa550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupStaticCameraPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupStaticCameraPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x3799a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupStaticCameraPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupStaticCameraPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupStaticCameraPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x379910, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SpriteAnimationManager::runAnimation(gd::string p0) -> decltype(runAnimation(p0)) {
	using FunctionType = decltype(runAnimation(p0))(*)(SpriteAnimationManager*, gd::string);
	static auto func = wrapFunction(base::get() + 0x6e69b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SpriteAnimationManager::stopAnimations() -> decltype(stopAnimations()) {
	using FunctionType = decltype(stopAnimations())(*)(SpriteAnimationManager*);
	static auto func = wrapFunction(base::get() + 0x6e74f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto SpriteAnimationManager::updateAnimationSpeed(float p0) -> decltype(updateAnimationSpeed(p0)) {
	using FunctionType = decltype(updateAnimationSpeed(p0))(*)(SpriteAnimationManager*, float);
	static auto func = wrapFunction(base::get() + 0x6e6790, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SpriteAnimationManager::offsetCurrentAnimation(float p0) -> decltype(offsetCurrentAnimation(p0)) {
	using FunctionType = decltype(offsetCurrentAnimation(p0))(*)(SpriteAnimationManager*, float);
	static auto func = wrapFunction(base::get() + 0x6e7890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupObjectOptionsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupObjectOptionsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f77e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupObjectOptionsPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupObjectOptionsPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupObjectOptionsPopup*);
	static auto func = wrapFunction(base::get() + 0x2f7740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupObjectOptionsPopup::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupObjectOptionsPopup::show), this);
	using FunctionType = decltype(show())(*)(SetupObjectOptionsPopup*);
	static auto func = wrapFunction(base::get() + 0x2f7780, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupObjectOptionsPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupObjectOptionsPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupObjectOptionsPopup*);
	static auto func = wrapFunction(base::get() + 0x2f7330, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupPickupTriggerPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupPickupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5c4f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupPickupTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupPickupTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5c530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRotateCommandPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupRotateCommandPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0xa650, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRotateCommandPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateCommandPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupRotateCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0xa300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRotateCommandPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateCommandPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupRotateCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0xa310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRotateCommandPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateCommandPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupRotateCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0xa2b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupRotateCommandPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateCommandPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupRotateCommandPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0xa2f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupSmartTemplateLayer::create(GJSmartTemplate* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x4c3540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto SetupSmartTemplateLayer::init(GJSmartTemplate* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(SetupSmartTemplateLayer*, GJSmartTemplate*);
	static auto func = wrapFunction(base::get() + 0x4c36a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SetupSmartTemplateLayer::onBack(cocos2d::CCObject* sender) -> decltype(onBack(sender)) {
	using FunctionType = decltype(onBack(sender))(*)(SetupSmartTemplateLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4c3f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupSmartTemplateLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupSmartTemplateLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(SetupSmartTemplateLayer*);
	static auto func = wrapFunction(base::get() + 0x4c45f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupSmartTemplateLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&SetupSmartTemplateLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(SetupSmartTemplateLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4c4300, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupSmartTemplateLayer::textInputOpened(CCTextInputNode* p0) -> decltype(textInputOpened(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupSmartTemplateLayer::textInputOpened), this);
	using FunctionType = decltype(textInputOpened(p0))(*)(SetupSmartTemplateLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4c4510, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartTemplateLayer::textInputClosed(CCTextInputNode* p0) -> decltype(textInputClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupSmartTemplateLayer::textInputClosed), this);
	using FunctionType = decltype(textInputClosed(p0))(*)(SetupSmartTemplateLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4c43e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupSmartTemplateLayer::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupSmartTemplateLayer::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupSmartTemplateLayer*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x4c45d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto ShareLevelSettingsLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	throw std::runtime_error("ShareLevelSettingsLayer::keyBackClicked not implemented");
}

auto ShareLevelSettingsLayer::numberInputClosed(NumberInputLayer* p0) -> decltype(numberInputClosed(p0)) {
	throw std::runtime_error("ShareLevelSettingsLayer::numberInputClosed not implemented");
}

auto SetupAudioLineGuidePopup::selectSettingClosed(SelectSettingLayer* p0) -> decltype(selectSettingClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<SelectSettingLayer*>::func(&SetupAudioLineGuidePopup::selectSettingClosed), this);
	using FunctionType = decltype(selectSettingClosed(p0))(*)(SetupAudioLineGuidePopup*, SelectSettingLayer*);
	static auto func = wrapFunction(base::get() + 0x54f530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCameraOffsetTrigger::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupCameraOffsetTrigger*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x627640, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupCameraOffsetTrigger::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCameraOffsetTrigger::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCameraOffsetTrigger*);
	static auto func = wrapFunction(base::get() + 0x626b10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCameraOffsetTrigger::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCameraOffsetTrigger::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCameraOffsetTrigger*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x627310, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupCameraOffsetTrigger::valuePopupClosed(ConfigureValuePopup* p0, float p1) -> decltype(valuePopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<ConfigureValuePopup*, float>::func(&SetupCameraOffsetTrigger::valuePopupClosed), this);
	using FunctionType = decltype(valuePopupClosed(p0, p1))(*)(SetupCameraOffsetTrigger*, ConfigureValuePopup*, float);
	static auto func = wrapFunction(base::get() + 0x626ee0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGameplayOffsetPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupGameplayOffsetPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x75ad70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupGameplayOffsetPopup::updateInputValue(int p0, float& p1) -> decltype(updateInputValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float&>::func(&SetupGameplayOffsetPopup::updateInputValue), this);
	using FunctionType = decltype(updateInputValue(p0, p1))(*)(SetupGameplayOffsetPopup*, int, float&);
	static auto func = wrapFunction(base::get() + 0x75ae80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGameplayOffsetPopup::updateInputNode(int p0, float p1) -> decltype(updateInputNode(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGameplayOffsetPopup::updateInputNode), this);
	using FunctionType = decltype(updateInputNode(p0, p1))(*)(SetupGameplayOffsetPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x75ae60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGameplayOffsetPopup::triggerValueFromSliderValue(int p0, float p1) -> decltype(triggerValueFromSliderValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGameplayOffsetPopup::triggerValueFromSliderValue), this);
	using FunctionType = decltype(triggerValueFromSliderValue(p0, p1))(*)(SetupGameplayOffsetPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x75ae10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGameplayOffsetPopup::triggerSliderValueFromValue(int p0, float p1) -> decltype(triggerSliderValueFromValue(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGameplayOffsetPopup::triggerSliderValueFromValue), this);
	using FunctionType = decltype(triggerSliderValueFromValue(p0, p1))(*)(SetupGameplayOffsetPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x75ae40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupGravityTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupGravityTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupGravityTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4a08a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupInteractObjectPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupInteractObjectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e6b60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupInteractObjectPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupInteractObjectPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4e6c50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupInteractObjectPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupInteractObjectPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupInteractObjectPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4e6ba0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupObjectOptions2Popup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupObjectOptions2Popup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2f7dc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupOptionsTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupOptionsTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x5ac540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRandAdvTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupRandAdvTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x36bc50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRandAdvTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupRandAdvTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupRandAdvTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x36bc30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto SetupRotateGameplayPopup::onPlusButton(cocos2d::CCObject* sender) -> decltype(onPlusButton(sender)) {
	using FunctionType = decltype(onPlusButton(sender))(*)(SetupRotateGameplayPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x75a240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupRotateGameplayPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupRotateGameplayPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupRotateGameplayPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x75a280, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto GJSmartBlockPreviewSprite::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSmartBlockPreviewSprite::init), this);
	using FunctionType = decltype(init())(*)(GJSmartBlockPreviewSprite*);
	static auto func = wrapFunction(base::get() + 0x408950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJSmartBlockPreviewSprite::visit() -> decltype(visit()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJSmartBlockPreviewSprite::visit), this);
	using FunctionType = decltype(visit())(*)(GJSmartBlockPreviewSprite*);
	static auto func = wrapFunction(base::get() + 0x408960, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaTintTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupAreaTintTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4b40b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupAreaTintTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAreaTintTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupAreaTintTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x4b3da0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaTintTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaTintTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAreaTintTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4b3cb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaTintTriggerPopup::hsvPopupClosed(HSVWidgetPopup* p0, cocos2d::_ccHSVValue p1) -> decltype(hsvPopupClosed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<HSVWidgetPopup*, cocos2d::_ccHSVValue>::func(&SetupAreaTintTriggerPopup::hsvPopupClosed), this);
	using FunctionType = decltype(hsvPopupClosed(p0, p1))(*)(SetupAreaTintTriggerPopup*, HSVWidgetPopup*, cocos2d::_ccHSVValue);
	static auto func = wrapFunction(base::get() + 0x4b3f20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupAreaAnimTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAreaAnimTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAreaAnimTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x4b7670, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAreaAnimTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAreaAnimTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAreaAnimTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x4b7810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupItemEditTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupItemEditTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x54b700, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupItemEditTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupItemEditTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupItemEditTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x54b8e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupSequenceTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupSequenceTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4ba110, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupCollisionTriggerPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(SetupCollisionTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x374fe0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupCollisionTriggerPopup::determineStartValues() -> decltype(determineStartValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupCollisionTriggerPopup::determineStartValues), this);
	using FunctionType = decltype(determineStartValues())(*)(SetupCollisionTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x374950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupCollisionTriggerPopup::textChanged(CCTextInputNode* p0) -> decltype(textChanged(p0)) {
	auto self = addresser::thunkAdjust(Resolve<CCTextInputNode*>::func(&SetupCollisionTriggerPopup::textChanged), this);
	using FunctionType = decltype(textChanged(p0))(*)(SetupCollisionTriggerPopup*, CCTextInputNode*);
	static auto func = wrapFunction(base::get() + 0x374cf0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UpdateAccountSettingsPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UpdateAccountSettingsPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UpdateAccountSettingsPopup*);
	static auto func = wrapFunction(base::get() + 0x27fef0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UpdateAccountSettingsPopup::updateSettingsFinished() -> decltype(updateSettingsFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UpdateAccountSettingsPopup::updateSettingsFinished), this);
	using FunctionType = decltype(updateSettingsFinished())(*)(UpdateAccountSettingsPopup*);
	static auto func = wrapFunction(base::get() + 0x27fce0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UpdateAccountSettingsPopup::updateSettingsFailed() -> decltype(updateSettingsFailed()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UpdateAccountSettingsPopup::updateSettingsFailed), this);
	using FunctionType = decltype(updateSettingsFailed())(*)(UpdateAccountSettingsPopup*);
	static auto func = wrapFunction(base::get() + 0x27fe00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAdvFollowRetargetPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupAdvFollowRetargetPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupAdvFollowRetargetPopup*);
	static auto func = wrapFunction(base::get() + 0x2e8e10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupAdvFollowRetargetPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAdvFollowRetargetPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAdvFollowRetargetPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x2e8f50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto CustomizeObjectSettingsPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(CustomizeObjectSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1d8cc0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto CustomizeObjectSettingsPopup::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(CustomizeObjectSettingsPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x1d8d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupItemCompareTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupItemCompareTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x54dc00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupItemCompareTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupItemCompareTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupItemCompareTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x54dd60, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupTimerControlTriggerPopup::onCustomToggleTriggerValue(cocos2d::CCObject* sender) -> decltype(onCustomToggleTriggerValue(sender)) {
	using FunctionType = decltype(onCustomToggleTriggerValue(sender))(*)(SetupTimerControlTriggerPopup*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x37ff30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto SetupAdvFollowEditPhysicsPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupAdvFollowEditPhysicsPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupAdvFollowEditPhysicsPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x2e8540, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto SetupInstantCollisionTriggerPopup::updateDefaultTriggerValues() -> decltype(updateDefaultTriggerValues()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SetupInstantCollisionTriggerPopup::updateDefaultTriggerValues), this);
	using FunctionType = decltype(updateDefaultTriggerValues())(*)(SetupInstantCollisionTriggerPopup*);
	static auto func = wrapFunction(base::get() + 0x375cd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SetupInstantCollisionTriggerPopup::valueDidChange(int p0, float p1) -> decltype(valueDidChange(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, float>::func(&SetupInstantCollisionTriggerPopup::valueDidChange), this);
	using FunctionType = decltype(valueDidChange(p0, p1))(*)(SetupInstantCollisionTriggerPopup*, int, float);
	static auto func = wrapFunction(base::get() + 0x3759c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::init(GJBaseGameLayer* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(UILayer*, GJBaseGameLayer*);
	static auto func = wrapFunction(base::get() + 0x4a2e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UILayer::onDeleteCheck(cocos2d::CCObject* sender) -> decltype(onDeleteCheck(sender)) {
	using FunctionType = decltype(onDeleteCheck(sender))(*)(UILayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4a3760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UILayer::onPause(cocos2d::CCObject* sender) -> decltype(onPause(sender)) {
	using FunctionType = decltype(onPause(sender))(*)(UILayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4a3630, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto UILayer::enableMenu() -> decltype(enableMenu()) {
	using FunctionType = decltype(enableMenu())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4a4600, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::disableMenu() -> decltype(disableMenu()) {
	using FunctionType = decltype(disableMenu())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4a3ea0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::refreshDpad() -> decltype(refreshDpad()) {
	using FunctionType = decltype(refreshDpad())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4a3950, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::handleKeypress(cocos2d::enumKeyCodes p0, bool p1) -> decltype(handleKeypress(p0, p1)) {
	using FunctionType = decltype(handleKeypress(p0, p1))(*)(UILayer*, cocos2d::enumKeyCodes, bool);
	static auto func = wrapFunction(base::get() + 0x4a4090, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto UILayer::resetAllButtons() -> decltype(resetAllButtons()) {
	using FunctionType = decltype(resetAllButtons())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4a4710, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto UILayer::toggleMenuVisibility(bool p0) -> decltype(toggleMenuVisibility(p0)) {
	using FunctionType = decltype(toggleMenuVisibility(p0))(*)(UILayer*, bool);
	static auto func = wrapFunction(base::get() + 0x4a4620, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto UILayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UILayer::draw), this);
	using FunctionType = decltype(draw())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4a4800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UILayer::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a4850, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a4c90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a5140, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&UILayer::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(UILayer*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x4a57c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto UILayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UILayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4a5800, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UILayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&UILayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(UILayer*);
	static auto func = wrapFunction(base::get() + 0x4a4580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto UILayer::keyDown(cocos2d::enumKeyCodes p0) -> decltype(keyDown(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&UILayer::keyDown), this);
	using FunctionType = decltype(keyDown(p0))(*)(UILayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4a44e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto UILayer::keyUp(cocos2d::enumKeyCodes p0) -> decltype(keyUp(p0)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::enumKeyCodes>::func(&UILayer::keyUp), this);
	using FunctionType = decltype(keyUp(p0))(*)(UILayer*, cocos2d::enumKeyCodes);
	static auto func = wrapFunction(base::get() + 0x4a4530, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto URLCell::loadFromObject(CCURLObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(URLCell*, CCURLObject*);
	static auto func = wrapFunction(base::get() + 0x2264c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto URLCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&URLCell::init), this);
	using FunctionType = decltype(init())(*)(URLCell*);
	static auto func = wrapFunction(base::get() + 0x237810, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto URLCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&URLCell::draw), this);
	using FunctionType = decltype(draw())(*)(URLCell*);
	static auto func = wrapFunction(base::get() + 0x237880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameCell::init), this);
	using FunctionType = decltype(init())(*)(GameCell*);
	static auto func = wrapFunction(base::get() + 0x2ea680, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GameCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GameCell::draw), this);
	using FunctionType = decltype(draw())(*)(GameCell*);
	static auto func = wrapFunction(base::get() + 0x2ea740, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJUINode::create(UIButtonConfig& p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(UIButtonConfig&);
	static auto func = wrapFunction(base::get() + 0x4a3560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJUINode::init(UIButtonConfig& p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(GJUINode*, UIButtonConfig&);
	static auto func = wrapFunction(base::get() + 0x4a5bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJUINode::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJUINode::draw), this);
	using FunctionType = decltype(draw())(*)(GJUINode*);
	static auto func = wrapFunction(base::get() + 0x4a6880, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ListCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ListCell::init), this);
	using FunctionType = decltype(init())(*)(ListCell*);
	static auto func = wrapFunction(base::get() + 0x2ea4d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto ListCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&ListCell::draw), this);
	using FunctionType = decltype(draw())(*)(ListCell*);
	static auto func = wrapFunction(base::get() + 0x2ea560, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongCell::loadFromObject(SongObject* p0) -> decltype(loadFromObject(p0)) {
	using FunctionType = decltype(loadFromObject(p0))(*)(SongCell*, SongObject*);
	static auto func = wrapFunction(base::get() + 0x225d30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto SongCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongCell::init), this);
	using FunctionType = decltype(init())(*)(SongCell*);
	static auto func = wrapFunction(base::get() + 0x231e40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto SongCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&SongCell::draw), this);
	using FunctionType = decltype(draw())(*)(SongCell*);
	static auto func = wrapFunction(base::get() + 0x231e80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TOSPopup::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TOSPopup::init), this);
	using FunctionType = decltype(init())(*)(TOSPopup*);
	static auto func = wrapFunction(base::get() + 0x28b9b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto TOSPopup::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&TOSPopup::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(TOSPopup*);
	static auto func = wrapFunction(base::get() + 0x28c040, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto AdToolbox::setupAds() -> decltype(setupAds()) {
	using FunctionType = decltype(setupAds())(*)(AdToolbox*);
	static auto func = wrapFunction(base::get() + 0xc8250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJMapPack::completedMaps() -> decltype(completedMaps()) {
	using FunctionType = decltype(completedMaps())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x52c930, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto GJMapPack::hasCompletedMapPack() -> decltype(hasCompletedMapPack()) {
	using FunctionType = decltype(hasCompletedMapPack())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x52c9e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

int GJMapPack::totalMaps() {
		if (this->m_levels) {
			return this->m_levels->count();
		}

		return 0;
	}

auto GJMapPack::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMapPack::init), this);
	using FunctionType = decltype(init())(*)(GJMapPack*);
	static auto func = wrapFunction(base::get() + 0x52c8b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMGLayer::create(int p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(int);
	static auto func = wrapFunction(base::get() + 0x5b0860, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto GJMGLayer::updateMG01Blend(bool p0) -> decltype(updateMG01Blend(p0)) {
	using FunctionType = decltype(updateMG01Blend(p0))(*)(GJMGLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5b1250, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJMGLayer::updateMG02Blend(bool p0) -> decltype(updateMG02Blend(p0)) {
	using FunctionType = decltype(updateMG02Blend(p0))(*)(GJMGLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x5b12a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto GJMGLayer::updateGroundColor(cocos2d::_ccColor3B p0, bool p1) -> decltype(updateGroundColor(p0, p1)) {
	using FunctionType = decltype(updateGroundColor(p0, p1))(*)(GJMGLayer*, cocos2d::_ccColor3B, bool);
	static auto func = wrapFunction(base::get() + 0x5b0ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMGLayer::updateGroundOpacity(unsigned char p0, bool p1) -> decltype(updateGroundOpacity(p0, p1)) {
	using FunctionType = decltype(updateGroundOpacity(p0, p1))(*)(GJMGLayer*, unsigned char, bool);
	static auto func = wrapFunction(base::get() + 0x5b1020, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto GJMGLayer::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMGLayer::draw), this);
	using FunctionType = decltype(draw())(*)(GJMGLayer*);
	static auto func = wrapFunction(base::get() + 0x5b1240, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto GJMGLayer::showGround() -> decltype(showGround()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&GJMGLayer::showGround), this);
	using FunctionType = decltype(showGround())(*)(GJMGLayer*);
	static auto func = wrapFunction(base::get() + 0x5b1210, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::create(GJGameLevel* p0, GJUserScore* p1, GJLevelList* p2) -> decltype(create(p0, p1, p2)) {
	using FunctionType = decltype(create(p0, p1, p2))(*)(GJGameLevel*, GJUserScore*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x76fe50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1, p2);
}

auto InfoLayer::init(GJGameLevel* p0, GJUserScore* p1, GJLevelList* p2) -> decltype(init(p0, p1, p2)) {
	using FunctionType = decltype(init(p0, p1, p2))(*)(InfoLayer*, GJGameLevel*, GJUserScore*, GJLevelList*);
	static auto func = wrapFunction(base::get() + 0x770000, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1, p2);
}

int InfoLayer::getID() {
		if(m_score) return m_score->m_userID;
		if(m_levelList) return - m_levelList->m_listID;
		if(m_level) return m_level->m_levelID;
		return 0;
	}

auto InfoLayer::onNextPage(cocos2d::CCObject* sender) -> decltype(onNextPage(sender)) {
	using FunctionType = decltype(onNextPage(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x772a20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onOriginal(cocos2d::CCObject* sender) -> decltype(onOriginal(sender)) {
	using FunctionType = decltype(onOriginal(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x772260, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onPrevPage(cocos2d::CCObject* sender) -> decltype(onPrevPage(sender)) {
	using FunctionType = decltype(onPrevPage(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x772a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onLevelInfo(cocos2d::CCObject* sender) -> decltype(onLevelInfo(sender)) {
	using FunctionType = decltype(onLevelInfo(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7732c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onCopyLevelID(cocos2d::CCObject* sender) -> decltype(onCopyLevelID(sender)) {
	using FunctionType = decltype(onCopyLevelID(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7738c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onMore(cocos2d::CCObject* sender) -> decltype(onMore(sender)) {
	using FunctionType = decltype(onMore(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x772010, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onClose(cocos2d::CCObject* sender) -> decltype(onClose(sender)) {
	using FunctionType = decltype(onClose(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x772980, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::onComment(cocos2d::CCObject* sender) -> decltype(onComment(sender)) {
	using FunctionType = decltype(onComment(sender))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7723a0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto InfoLayer::confirmReport(cocos2d::CCObject* p0) -> decltype(confirmReport(p0)) {
	using FunctionType = decltype(confirmReport(p0))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x7727d0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto InfoLayer::setupPageInfo(gd::string p0, char const* p1) -> decltype(setupPageInfo(p0, p1)) {
	using FunctionType = decltype(setupPageInfo(p0, p1))(*)(InfoLayer*, gd::string, char const*);
	static auto func = wrapFunction(base::get() + 0x774030, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto InfoLayer::setupLevelInfo() -> decltype(setupLevelInfo()) {
	using FunctionType = decltype(setupLevelInfo())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x772060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto InfoLayer::toggleCommentMode(cocos2d::CCObject* p0) -> decltype(toggleCommentMode(p0)) {
	using FunctionType = decltype(toggleCommentMode(p0))(*)(InfoLayer*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x772b20, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto InfoLayer::setupCommentsBrowser(cocos2d::CCArray* p0) -> decltype(setupCommentsBrowser(p0)) {
	using FunctionType = decltype(setupCommentsBrowser(p0))(*)(InfoLayer*, cocos2d::CCArray*);
	static auto func = wrapFunction(base::get() + 0x773120, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto InfoLayer::loadPage(int p0, bool p1) -> decltype(loadPage(p0, p1)) {
	using FunctionType = decltype(loadPage(p0, p1))(*)(InfoLayer*, int, bool);
	static auto func = wrapFunction(base::get() + 0x772d80, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0, p1);
}

auto InfoLayer::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x773d50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::keyBackClicked() -> decltype(keyBackClicked()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::keyBackClicked), this);
	using FunctionType = decltype(keyBackClicked())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x773c40, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::show() -> decltype(show()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::show), this);
	using FunctionType = decltype(show())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x774ae0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::loadCommentsFinished(cocos2d::CCArray* p0, char const* p1) -> decltype(loadCommentsFinished(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCArray*, char const*>::func(&InfoLayer::loadCommentsFinished), this);
	using FunctionType = decltype(loadCommentsFinished(p0, p1))(*)(InfoLayer*, cocos2d::CCArray*, char const*);
	static auto func = wrapFunction(base::get() + 0x773ec0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto InfoLayer::loadCommentsFailed(char const* p0) -> decltype(loadCommentsFailed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<char const*>::func(&InfoLayer::loadCommentsFailed), this);
	using FunctionType = decltype(loadCommentsFailed(p0))(*)(InfoLayer*, char const*);
	static auto func = wrapFunction(base::get() + 0x773f90, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto InfoLayer::commentUploadFinished(int p0) -> decltype(commentUploadFinished(p0)) {
	auto self = addresser::thunkAdjust(Resolve<int>::func(&InfoLayer::commentUploadFinished), this);
	using FunctionType = decltype(commentUploadFinished(p0))(*)(InfoLayer*, int);
	static auto func = wrapFunction(base::get() + 0x774690, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}

auto InfoLayer::commentUploadFailed(int p0, CommentError p1) -> decltype(commentUploadFailed(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<int, CommentError>::func(&InfoLayer::commentUploadFailed), this);
	using FunctionType = decltype(commentUploadFailed(p0, p1))(*)(InfoLayer*, int, CommentError);
	static auto func = wrapFunction(base::get() + 0x7747e0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto InfoLayer::updateUserScoreFinished() -> decltype(updateUserScoreFinished()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&InfoLayer::updateUserScoreFinished), this);
	using FunctionType = decltype(updateUserScoreFinished())(*)(InfoLayer*);
	static auto func = wrapFunction(base::get() + 0x7744f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto InfoLayer::FLAlert_Clicked(FLAlertLayer* p0, bool p1) -> decltype(FLAlert_Clicked(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<FLAlertLayer*, bool>::func(&InfoLayer::FLAlert_Clicked), this);
	using FunctionType = decltype(FLAlert_Clicked(p0, p1))(*)(InfoLayer*, FLAlertLayer*, bool);
	static auto func = wrapFunction(base::get() + 0x773a00, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelCell::create(float p0, float p1) -> decltype(create(p0, p1)) {
	using FunctionType = decltype(create(p0, p1))(*)(float, float);
	static auto func = wrapFunction(base::get() + 0x22d270, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0, p1);
}

auto LevelCell::onViewProfile(cocos2d::CCObject* sender) -> decltype(onViewProfile(sender)) {
	using FunctionType = decltype(onViewProfile(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x230550, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::onClick(cocos2d::CCObject* sender) -> decltype(onClick(sender)) {
	using FunctionType = decltype(onClick(sender))(*)(LevelCell*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x2303f0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelCell::loadFromLevel(GJGameLevel* p0) -> decltype(loadFromLevel(p0)) {
	using FunctionType = decltype(loadFromLevel(p0))(*)(LevelCell*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x223890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelCell::updateCellMode(int p0) -> decltype(updateCellMode(p0)) {
	using FunctionType = decltype(updateCellMode(p0))(*)(LevelCell*, int);
	static auto func = wrapFunction(base::get() + 0x22cde0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelCell::loadLocalLevelCell() -> decltype(loadLocalLevelCell()) {
	using FunctionType = decltype(loadLocalLevelCell())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x22d440, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelCell::loadCustomLevelCell() -> decltype(loadCustomLevelCell()) {
	using FunctionType = decltype(loadCustomLevelCell())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x22dcd0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelCell::init() -> decltype(init()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelCell::init), this);
	using FunctionType = decltype(init())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x22d410, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelCell::draw() -> decltype(draw()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelCell::draw), this);
	using FunctionType = decltype(draw())(*)(LevelCell*);
	static auto func = wrapFunction(base::get() + 0x230580, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelPage::create(GJGameLevel* p0) -> decltype(create(p0)) {
	using FunctionType = decltype(create(p0))(*)(GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x411890, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(p0);
}

auto LevelPage::init(GJGameLevel* p0) -> decltype(init(p0)) {
	using FunctionType = decltype(init(p0))(*)(LevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x414730, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelPage::onInfo(cocos2d::CCObject* sender) -> decltype(onInfo(sender)) {
	using FunctionType = decltype(onInfo(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4140c0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::onPlay(cocos2d::CCObject* sender) -> decltype(onPlay(sender)) {
	using FunctionType = decltype(onPlay(sender))(*)(LevelPage*, cocos2d::CCObject*);
	static auto func = wrapFunction(base::get() + 0x4139b0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, sender);
}

auto LevelPage::addSecretCoin() -> decltype(addSecretCoin()) {
	using FunctionType = decltype(addSecretCoin())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x413060, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this);
}

auto LevelPage::updateDynamicPage(GJGameLevel* p0) -> decltype(updateDynamicPage(p0)) {
	using FunctionType = decltype(updateDynamicPage(p0))(*)(LevelPage*, GJGameLevel*);
	static auto func = wrapFunction(base::get() + 0x411b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(this, p0);
}

auto LevelPage::ccTouchBegan(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchBegan(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelPage::ccTouchBegan), this);
	using FunctionType = decltype(ccTouchBegan(p0, p1))(*)(LevelPage*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x416a10, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelPage::ccTouchMoved(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchMoved(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelPage::ccTouchMoved), this);
	using FunctionType = decltype(ccTouchMoved(p0, p1))(*)(LevelPage*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x416b30, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelPage::ccTouchEnded(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchEnded(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelPage::ccTouchEnded), this);
	using FunctionType = decltype(ccTouchEnded(p0, p1))(*)(LevelPage*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x416b50, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelPage::ccTouchCancelled(cocos2d::CCTouch* p0, cocos2d::CCEvent* p1) -> decltype(ccTouchCancelled(p0, p1)) {
	auto self = addresser::thunkAdjust(Resolve<cocos2d::CCTouch*, cocos2d::CCEvent*>::func(&LevelPage::ccTouchCancelled), this);
	using FunctionType = decltype(ccTouchCancelled(p0, p1))(*)(LevelPage*, cocos2d::CCTouch*, cocos2d::CCEvent*);
	static auto func = wrapFunction(base::get() + 0x416b70, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0, p1);
}

auto LevelPage::registerWithTouchDispatcher() -> decltype(registerWithTouchDispatcher()) {
	auto self = addresser::thunkAdjust(Resolve<>::func(&LevelPage::registerWithTouchDispatcher), this);
	using FunctionType = decltype(registerWithTouchDispatcher())(*)(LevelPage*);
	static auto func = wrapFunction(base::get() + 0x416bb0, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self);
}

auto LevelPage::dialogClosed(DialogLayer* p0) -> decltype(dialogClosed(p0)) {
	auto self = addresser::thunkAdjust(Resolve<DialogLayer*>::func(&LevelPage::dialogClosed), this);
	using FunctionType = decltype(dialogClosed(p0))(*)(LevelPage*, DialogLayer*);
	static auto func = wrapFunction(base::get() + 0x416760, tulip::hook::WrapperMetadata{
		.m_convention = geode::hook::createConvention(tulip::hook::TulipConvention::Default),
		.m_abstract = tulip::hook::AbstractFunction::from(FunctionType(nullptr)),
	});
	return reinterpret_cast<FunctionType>(func)(self, p0);
}
